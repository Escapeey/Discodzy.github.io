<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>锂电池行业概述</title>
      <link href="/post/7416a4f2.html"/>
      <url>/post/7416a4f2.html</url>
      
        <content type="html"><![CDATA[<p>冬天到了，为什么电池充电时间变久了，充的电不耐用了？</p><hr><ul><li>参考视频: <a href="https://www.bilibili.com/video/BV15wHKepEEF/?spm_id_from=333.1007">锂电池行业快速通关</a></li></ul><h1>电池基本原理</h1><p>电池的基本工作原理是将化学能转化为电能。其工作过程可以通过以下几个步骤进行简述：</p><ol><li><strong>化学反应</strong>：电池内部发生化学反应，负极失去电子（氧化反应），正极得到电子（还原反应）。</li><li><strong>电流流动</strong>：电子从负极流向正极，形成电流，供应外部电路所需的电能。</li><li><strong>充放电过程</strong>：<ul><li>放电时，负极释放电子，电流流向正极。</li><li>充电时，电池被电源电流反向充电，电子从正极流向负极。</li></ul></li></ol><h2 id="电池的主要组成部分：">电池的主要组成部分：</h2><ul><li><strong>负极</strong>：失去电子的部分。</li><li><strong>正极</strong>：得到电子的部分。</li><li><strong>电解液</strong>：允许锂离子（或其他离子）在两极之间流动。</li></ul><hr><h1>材料选择</h1><p>电池材料选择是确保电池性能和安全的关键因素。选择合适的材料需要考虑以下几个特性：</p><ul><li><strong>足够的电量</strong>：电池应能存储和释放足够的电能。</li><li><strong>轻便性</strong>：尤其对于移动设备和电动汽车，轻便的材料是必要的。</li><li><strong>安全性</strong>：材料应具有良好的热稳定性和化学稳定性，防止发生过热或短路。</li><li><strong>长寿命</strong>：材料的化学稳定性必须保证电池的长时间循环使用。</li><li><strong>材料常见</strong>：制造电池所需的材料在自然界中普遍存在<br>锂电池材料的一个关键原因是锂的原子结构：</li><li>锂是周期表中质量最轻的金属，外层电子容易失去，使其成为理想的电池材料。</li></ul><hr><h1>正极材料</h1><p>这种材料要在失去锂离子后还能形成稳定的化合价，保证电池的安全与稳定，所以锂不能单独存在，必须与其他物质以一种化合物的形式共存。</p><p>正极材料是锂电池中能量存储的主要材料。常见的正极材料包括：</p><table><thead><tr><th>材料</th><th>特性</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td><strong>磷酸铁锂(<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mi>i</mi><mi>F</mi><mi>e</mi><mi>P</mi><msub><mi>O</mi><mn>4</mn></msub></mrow><annotation encoding="application/x-tex">LiFePO_4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord mathnormal">L</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>)</strong></td><td>能量密度适中，热稳定性好，安全性高。</td><td>高热稳定性，安全性高，成本低。</td><td>能量密度相对较低，续航较短。</td></tr><tr><td><strong>三元材料</strong></td><td>含锰、镍、钴三种金属的化合物，能量密度高。</td><td>能量密度高，适合高续航应用。</td><td>材料成本高，热稳定性较差。</td></tr><tr><td><strong>镍酸锂</strong></td><td>高能量密度，适用于高性能应用。</td><td>高能量密度，续航能力强。</td><td>成本高，供应链紧张，矿产资源集中。</td></tr><tr><td><strong>钴酸锂</strong></td><td>稳定的电化学性能，历史较长。</td><td>高能量密度，续航能力强；商业化较早，技术成熟。</td><td>成本高，钴资源的供应问题。</td></tr></tbody></table><img src="..\..\img\IndustryEntry/锂电池-锂离子电池产量结构图.png" width="100%" height="100%" align="middle"><ul><li>统计时间: 2023-06</li></ul><img src="..\..\img\IndustryEntry/锂电池-电池成本.png" width="100%" height="100%" align="middle"><img src="..\..\img\IndustryEntry/锂电池-性能.png" width="100%" height="100%" align="middle"><ul><li><strong>磷酸铁锂</strong>：是目前应用最广泛的材料之一，特别是在新能源汽车中。其热稳定性好，能防止电池过热引发火灾或爆炸。</li><li><strong>三元材料</strong>：由镍、钴、锰三种金属混合组成，其能量密度高，是现代高续航电池的首选材料。</li></ul><h2 id="磷酸铁锂">磷酸铁锂</h2><ul><li>在失去锂离子时 物质的晶体结构未发生改变，呈现橄榄石结构，不会坍塌或变形，可以让其在充放电时维持良好的<strong>热稳定性</strong>和<strong>循环性能</strong>，从而保证使用安全和寿命</li><li>磷和铁分布广泛，简单易得</li></ul><img src="..\..\img\IndustryEntry/锂电池-磷酸铁锂结构图.png" width="100%" height="100%" align="middle"><h2 id="三元材料">三元材料</h2><ul><li>指含有<strong>锰(Mn)</strong>、<strong>钴(Co)</strong>、**镍(Ni)**三种材料的材料</li></ul><table><thead><tr><th>材料</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td><strong>钴酸锂</strong></td><td>能量密度高，续航时间长</td><td>成本极高，限制了商业化发展</td></tr><tr><td><strong>锰酸锂</strong></td><td>热稳定性好</td><td>能量密度低，使用寿命有限</td></tr><tr><td><strong>镍酸锂</strong></td><td>能量密度高</td><td>极易发生晶体结构变化</td></tr></tbody></table><ul><li><p>都有缺点，取长补短</p><ul><li><strong>钴</strong>稳定晶体结构、提升循环性能</li><li><strong>镍</strong>作为活性金属，提供较大能量密度</li><li><strong>锰</strong>作为非活性金属，稳定材料内部反应、降低生产成本</li></ul></li><li><p>由于镍提供较大的能量密度，所以三元锂电池的发展是<strong>低镍到高镍</strong>的发展</p></li><li><p>比例分配</p><ul><li>NCM333<ul><li>钴成本较高，提升了生产成本</li></ul></li><li>NCM523<ul><li>中镍电池，提供更长的续航时间</li></ul></li><li>NCM811<ul><li>高镍电池</li></ul></li></ul></li></ul><hr><h1>负极材料</h1><p>负极材料用于储存从正极迁移过来的锂离子。常用的负极材料有石墨、硅基材料等。</p><table><thead><tr><th>材料</th><th>特性</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td><strong>石墨</strong></td><td>具有层状结构，锂离子能嵌入石墨层中。</td><td>良好的导电性，较低的成本。</td><td>能量密度较低，限制了充电容量。</td></tr><tr><td><strong>硅基材料</strong></td><td>硅的能量密度高，能储存更多锂离子。</td><td>能量密度是石墨的10倍。</td><td>体积膨胀大，影响安全性和循环寿命。</td></tr></tbody></table><ul><li><strong>石墨</strong>：石墨的层状结构使其能有效地存储锂离子，常用于普通电子设备和中低端的电动汽车电池中。</li><li><strong>硅基材料</strong>：相比石墨，硅基材料具有更高的能量密度，但在充放电过程中会发生膨胀，影响电池的循环寿命和安全性。</li></ul><h2 id="石墨">石墨</h2><ul><li><p>分为<strong>天然石墨</strong>和<strong>人造石墨</strong><br>|材料 | 优点 | 缺点 | 用途 |<br>|<strong>天然石墨</strong>| 便宜量大 | 颗粒大小不一、循环性能较差| 常用于小型电池 |<br>|<strong>人造石墨</strong>| 颗粒大小均衡、循环性能较好 | 价格稍贵 | 用于新能源汽车、中高端电子设备 |</p></li><li><p>缺点：六个碳原子存储一个锂离子，导致锂离子的能量密度比较低<br><img src="..\..\img\IndustryEntry/锂电池-石墨存储锂离子结构图.png" width="100%" height="100%" align="middle"></p></li></ul><h2 id="硅基材料">硅基材料</h2><ul><li>能量密度是石墨的近10倍</li><li>在充放电过程中会发生膨胀，影响电池的循环寿命和安全性<br><img src="..\..\img\IndustryEntry/锂电池-硅负极使用中体积明显变化示意图.png" width="100%" height="100%" align="middle"></li></ul><hr><h1>隔膜</h1><p>隔膜是用于分隔正负极、避免电池短路的薄膜材料。它应具备以下特点：</p><ul><li><strong>良好的离子导电性</strong>：保证锂离子能顺利通过。</li><li><strong>高机械强度</strong>：防止在高温和充放电过程中变形。</li><li><strong>薄且具有低内阻</strong>：减少电池的能量损失。</li></ul><p>主要材料包括<strong>聚乙烯（PE）<strong>和</strong>聚丙烯（PP）</strong>。隔膜的生产工艺有<strong>干法生产</strong>和<strong>湿法生产</strong>，各有优缺点。</p><table><thead><tr><th>工艺</th><th>特性</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td><strong>干法生产</strong></td><td>利用机械拉伸形成膜结构。</td><td>制造成本较低。</td><td>可能导致膜的厚度不均匀，性能不稳定。</td></tr><tr><td><strong>湿法生产</strong></td><td>通过溶液浸渍后成膜，膜的孔隙结构均匀。</td><td>孔隙分布均匀，性能优异。</td><td>工艺复杂，成本较高。</td></tr></tbody></table><img src="..\..\img\IndustryEntry/锂电池-隔膜生产工艺.png" width="100%" height="100%" align="middle"><hr><h1>电解液</h1><p>电解液用于在电池充放电过程中提供锂离子传输通道，通常由<strong>锂盐</strong>和<strong>有机溶剂</strong>组成。</p><table><thead><tr><th>主要成分</th><th>功能</th><th>常见材料</th></tr></thead><tbody><tr><td><strong>溶质(锂盐)</strong></td><td>提供锂离子以支持电池的电荷传递。</td><td>六氟磷酸锂（LiPF6）、四氟硼酸锂（LiBF4）等</td></tr><tr><td><strong>溶剂</strong></td><td>提供锂离子在电解液中的流动性。</td><td>碳酸乙烯酯（EC）、碳酸二甲酯（DMC）等</td></tr></tbody></table><ul><li><p><strong>锂盐</strong>：是电解液的关键成分，能提供锂离子支持电池的充放电过程。</p></li><li><p><strong>溶剂</strong>：溶剂的选择影响锂离子在电解液中的移动速度及电池的性能。</p></li><li><p>还有少量添加剂，可以提升安全性、电导率等</p><ul><li>添加剂的配比是电解液供应商的机密所在</li></ul></li></ul><hr><h1>电池容量</h1><ul><li><p>由于电池内部一直在不间断进行着反应，<strong>锂离子</strong>会不可避免的与电解液中的其他物质发生反应，生产化合物，这些过程是不可逆的，导致锂离子含量会逐渐减少，电池容量也就变少了</p></li><li><p>低温</p><ul><li>电解液的粘度增加，电导率下降，锂离子的迁移速度变慢</li><li>锂离子活性降低，脱嵌能力变差，不能正确插入石墨层之间，反而累积在电池内部，容易形成<strong>锂枝晶</strong>，从而降低可用锂离子含量，甚至还能<strong>刺穿隔膜引发短路</strong></li></ul></li></ul><hr><h1>电池封装</h1><p>电池封装是将<strong>电芯</strong>组合成<strong>模组</strong>，再将模组打包成<strong>电池包</strong>的过程。常见封装方式包括<strong>圆柱形封装</strong>、<strong>方形封装</strong>和<strong>软包封装</strong>。</p><img src="..\..\img\IndustryEntry/锂电池-电池封装.png" width="100%" height="100%" align="middle"><table><thead><tr><th>封装方式</th><th>特性</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td><strong>圆柱形</strong></td><td>电芯呈圆柱形排列，标准化程度高。</td><td>标准统一，生产工艺成熟，稳定性好。</td><td>空间利用率较低，能量密度较小。</td></tr><tr><td><strong>方形</strong></td><td>电芯呈矩形排列。</td><td>空间利用率高，能量密度较大。</td><td>生产效率低，结构较复杂。</td></tr><tr><td><strong>软包</strong></td><td>电芯用铝塑膜封装，重量轻便。</td><td>质量轻，灵活性强。</td><td>极端条件下容易变形，需额外保护层。</td></tr></tbody></table><ul><li>技术革新<ul><li><strong>CTP</strong>(Cell to Pack): 将电芯直接集成到电池包内，省去模组与一部分结构件，提高了空间利用率</li><li><strong>CTC</strong>(Cell to Chassis): 将电芯、电控系统集成到地盘，实现车身与底盘的一体化设计</li></ul></li></ul><hr><h1>中国锂电池发展</h1><ul><li><p>锂电池上下游产业链<br><img src="..\..\img\IndustryEntry/锂电池-锂电池上下游产业链.png" width="100%" height="100%" align="middle"></p></li><li><p>2023年市场占有率<br><img src="..\..\img\IndustryEntry/锂电池-2023年市场占有率.png" width="100%" height="100%" align="middle"></p></li><li><p>锂电池发展历程:<br><a href="https://www.bilibili.com/video/BV15wHKepEEF/?spm_id_from=333.1007">锂电池行业快速通关</a> 16:24</p></li><li><p>中国锂电池行业的崛起经历了多年的技术积累和市场竞争。以下是中国锂电池行业的重要发展里程碑：</p><ul><li><strong>2001年</strong>：中国加入WTO后，锂电池行业迅速发展，开始国产化。</li><li><strong>2008年</strong>：我国成功突破隔膜技术，实现材料国产化。</li><li><strong>2010年</strong>：比亚迪推出自有磷酸铁锂电池，开始进入新能源汽车市场。</li><li><strong>2016年</strong>：宁德时代成为全球动力锂电池销售冠军。</li><li><strong>2021年</strong>：磷酸铁锂电池市场份额回升，超过三元锂电池。</li><li><strong>2024年</strong>：中国锂电池厂商通过投资建厂、技术创新等方式，逐步扩展国际市场</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 行业通关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行业通关 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SD相关推荐</title>
      <link href="/post/49df12fd.html"/>
      <url>/post/49df12fd.html</url>
      
        <content type="html"><![CDATA[<h1>大模型</h1><ul><li>TMND-Mix 二次元-细节惊人</li></ul><h1>扩展插件</h1><h2 id="ADetailer-S">ADetailer (<strong>S</strong>)</h2><ul><li>自动识别面部等重点区域进行强调</li><li>模型目录: <code>根目录\models\adetailer</code></li><li>提供针对脸部的提示词窗口<ul><li><code>detailed face, close-up, portrait</code></li></ul></li><li>识别不到脸, 就尽量下降检测阈值</li><li>能感知到大概明确偏向哪边就用下面的X、Y轴偏移来进行调整</li><li>支持单独对面部的 <code>ControlNet</code>(推荐使用inPaint模型)</li></ul><h2 id="Tiled-Diffusion">Tiled Diffusion</h2><ul><li>由<code>TiledDiffusion</code>和<code>TiledVAE</code>组成</li><li><code>TiledDiffusion</code>负责扩散生成图像</li><li><code>TiledVAE</code>负责编码与解码(将图像打入/捞出潜空间)</li></ul><h3 id="参数">参数</h3><ul><li>方案: 用<code>MultiDiffusion</code></li><li>重绘幅度: 低一点(建议0.3)</li><li>放大设置：<br><img src="..\..\img\SD\TiledDiffusion放大方案一.png" width="100%" height="100%" align="middle"><br><img src="..\..\img\SD\TiledDiffusion放大方案二.png" width="100%" height="100%" align="middle"></li></ul><h3 id="Tiled-VAE">Tiled VAE</h3><ul><li>是降低显存的关键</li><li>一般<strong>维持默认参数不变</strong></li><li>只有在两种情况下改参数：<ul><li><strong>爆显存</strong>: 降低编码器分块大小</li><li>当使用的Tile太小且图片变得<strong>灰暗不清晰</strong>时: 启用<code>快速编码器颜色修复</code></li></ul></li></ul><h3 id="Tiled-Diffusion-2">Tiled Diffusion</h3><ul><li>实现大尺寸下&quot;体面&quot;重绘并还原细节<br><img src="..\..\img\SD\TiledDiffusion块设置.png" width="100%" height="100%" align="middle"></li></ul><h3 id="放大实践">放大实践</h3><p><a href="https://www.bilibili.com/video/BV1Su4y1d7Dp/?spm_id_from=333.788">6K超高清分辨率放大实践</a></p><h1>embeddings</h1><h1>LoRA</h1>]]></content>
      
      
      <categories>
          
          <category> AI绘画 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AI绘画 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SD学习</title>
      <link href="/post/e5cb238c.html"/>
      <url>/post/e5cb238c.html</url>
      
        <content type="html"><![CDATA[<p><strong>参考课程</strong>: <a href="https://space.bilibili.com/1814756990/channel/collectiondetail?sid=1285674">SD绘画</a><br><strong>提示词+参数+模型</strong></p><h1>提示词</h1><ul><li>tips: <strong>多多益善</strong></li><li>提示词工具网站<br><a href="http://www.atoolbox.net/Tool.php?Id=1101">提示词工具箱</a></li><li>提示词格式<ul><li>词组为单位</li><li>分隔符: &quot;, &quot;</li></ul></li></ul><h2 id="内容提示词">内容提示词</h2><h3 id="一些提示词">一些提示词</h3><ul><li>xxx in the background 可以更精确的将东西定义到&quot;背景&quot;的范围里</li><li>depth of field 景深</li></ul><h3 id="人物提示词">人物提示词</h3><ul><li>服装穿搭</li><li>发型发色</li><li>五官特点</li><li>面部表情</li><li>肢体动作</li></ul><h3 id="场景提示词">场景提示词</h3><ul><li>室内、室外(<strong>重要</strong>)<ul><li>indoor / outdoor</li></ul></li><li>大场景<ul><li>forest, city, street</li></ul></li><li>小细节<ul><li>tree, bush, white flower</li></ul></li></ul><h3 id="环境光照">环境光照</h3><ul><li>白天黑夜<ul><li>day / night</li></ul></li><li>特定时段<ul><li>morning, sunset</li></ul></li><li>光环境<ul><li>sunlight, bright, dark</li></ul></li><li>天空<ul><li>blue sky, starry sky</li></ul></li></ul><h3 id="画幅视角">画幅视角</h3><ul><li>距离<ul><li>close-up, distant</li></ul></li><li>人物比例<ul><li>full body, upper body</li></ul></li><li>观察视角<ul><li>from above, view of back</li></ul></li><li>镜头类型<ul><li>wide angle, Sony A7 3</li></ul></li></ul><h2 id="标准化提示词">标准化提示词</h2><h3 id="画质提示词">画质提示词</h3><ul><li>通用高画质<ul><li>best quality, ultra-detailed, masterpiece, hires, 8k</li></ul></li><li>特定高分辨率类型<ul><li>extremely detailed CG unity 8k wallpaper, unreal engine rendered</li></ul></li></ul><h3 id="画风提示词">画风提示词</h3><ul><li>插画风<ul><li>illustration, painting, paintbrush</li></ul></li><li>二次元<ul><li>anime, comic, game CG</li></ul></li><li>写实系<ul><li>photorealistic, realistic, photograph</li></ul></li></ul><h2 id="提示词权重">提示词权重</h2><ul><li>tips:<ul><li>尽量保持权重在<strong>1上下0.5内</strong></li><li>如果想让个别词条很突出，则建议使用多个词条，避免单一词条权重过大</li></ul></li><li>加括号<ul><li>圆括号 <strong>权重*1.1</strong><ul><li>(white flower)</li></ul></li><li>大括号 <strong>权重*1.05</strong><ul><li>{white flower}</li></ul></li><li>方括号 <strong>权重*0.9</strong><ul><li>[white flower]</li></ul></li></ul></li><li>括号加数字权重<ul><li>(white flower:1.5)</li></ul></li></ul><img src="..\..\img\SD\进阶提示词语法.png" width="100%" height="100%" align="middle"><h3 id="反向提示词">反向提示词</h3><p>标准化提示词-抄作业</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSFW, (worst quality:2), (low quality:2), (normal quality:2), lowers, normal quality, ((monochrome)), ((grayscale)), skin spots, acnes, skin blemishes, age spot, (ugly:1.331), (duplicate:1.331), (morbid:1.21), (mutilated:1.21), (tranny:1.331), mutated hands, (poorly drawn hands:1.5), blurry, (bad anatomy:1.21), (bad proportions:1.331), extra limbs, (disfigured:1.331), (missing arms:1.331), (extra legs:1.331), (fused fingers:1.61051), (too many fingers:1.61051), (unclear eyes:1.331), lowers, bad hands, missing fingers, extra digit, bad hands, missing fingers, (((extra arms and legs))),</span><br></pre></td></tr></table></figure><h1>出图参数</h1><ul><li>采样迭代步数(step)<ul><li>一般设为20</li></ul></li><li>采样方法<ul><li>用最下面带有加号的</li><li>模型一般有提示最适合自己的算法</li></ul></li><li>分辨率<ul><li>过大显存不够</li><li>过大容易出现多人、多手(一般模型训练时用的小图片, 分辨率过大会让AI认为是多个图片拼接)<ul><li><strong>避免该问题</strong>：使用低分辨率先绘制，然后用高清修复放大</li></ul></li></ul></li><li>面部修复：勾选上(类似美图P脸)</li><li>平铺：不要勾选</li><li>提示词相关性：类型权重<ul><li>7-12 较安全</li></ul></li><li>生成批次：建议多批次一起</li><li>每批数量：1</li></ul><h1>图生图</h1><p>原理：提取图像特征，并输入到网络中</p><ul><li>tips:<ul><li>一般生成的图片建议和原始图片保持相同的缩放比例</li><li>如果要不同的比例，建议用修图软件裁剪后再导入</li></ul></li></ul><h2 id="参数">参数</h2><ul><li>重绘幅度</li><li>缩放模式<ul><li>直接缩放(放大潜变量)：不建议使用</li></ul></li></ul><h1>模型</h1><h2 id="概述">概述</h2><ul><li>存储地址: <code>根目录\models\Stable-diffusion\</code></li><li>模型类型<ul><li><code>.ckpt</code></li><li><code>.safetensor</code><ul><li>占用空间小</li></ul></li></ul></li></ul><h2 id="风格分类">风格分类</h2><h3 id="二次元">二次元</h3><ul><li>搜索标签：illustration, painting, sketch, drawing, painting, comic, anime, catoon</li><li>推荐:<ul><li>Anything V5</li><li>Counterfeit V2.5<ul><li>精致，类似紫罗兰永恒花园</li></ul></li><li>Dreamlike Diffusion<ul><li>幻想系，超现实</li></ul></li></ul></li></ul><h3 id="真实系">真实系</h3><ul><li>搜索标签：photography, photo, realistic, photorealistic, RAW photo</li><li>推荐:<ul><li>Deliberate</li><li>Realistic Vision</li><li>L.O.F.I</li></ul></li></ul><h3 id="2-5D">2.5D</h3><ul><li>搜索标签：3D, render, chibi, digital art, concept art, {realistic}</li><li>推荐:<ul><li>Never Ending Dream (NED)</li><li>Protogen (Realistic)</li><li>国风3 (GuoFeng3)</li></ul></li></ul><h2 id="VAE">VAE</h2><ul><li>可以理解为AI绘画的一种<strong>调色滤镜</strong></li><li>大多数模型都将其融入大模型内了</li></ul><h2 id="Hypernetwork">Hypernetwork</h2><ul><li>存储地址: <code>根目录\models\hypernetworks\</code></li><li>使用: 在设置里找到 <strong>附加网络</strong> 选项，将对应超网络添加到提示词</li><li>类似lora, 一般用于改变画风, 小区别(类似梵高和莫奈)</li></ul><h2 id="Embeddings">Embeddings</h2><ul><li>存储地址: <code>根目录\embeddings\</code></li><li><strong>WebUI中embeddings不用特别调用，只需要用特定提示词去召唤</strong></li><li>后缀 <strong>.pt</strong></li><li>通常很小</li><li>下载模型时标签为：<strong>textual inversion</strong></li><li>不包含信息, 只是一个标记, 包含特征信息去哪里找, 类似书签</li><li>例子：<ul><li>比如Dva的embeddings 样例中用 <code>corneo_dva</code> 召唤</li><li>可以用特定的embeddings画角色图</li><li>解决画错手的问题(它是在一系列画错的上面学到的，放在负面提示词)<ul><li>Deep Negative (真人模型)</li><li>Easy Negative (二次元)</li></ul></li></ul></li></ul><h2 id="LoRA">LoRA</h2><ul><li>存储地址: <code>根目录\models\Lora</code></li><li>使用: 在提示词框里用 <code>&lt;lora:lora模型名称&gt;</code> 启用</li><li>一般要确定权重</li><li>类似彩页传单，比如要生成佩奇，它直接写明了佩奇是什么，有什么特点，怎么样呈现出佩奇</li><li>一般有一些触发词</li></ul><h2 id="导入方式">导入方式</h2><ul><li>直接放入文件夹中<ul><li>存储地址: <code>根目录\models\Lora</code></li><li>使用<code>&lt;lora:lora模型名称&gt;</code> 启用</li></ul></li><li>使用addtional network选项(额外附加网络 / 扩展模型)<ul><li>一个红色按钮</li></ul></li><li>使用<code>Addtional Network</code>扩展<ul><li>在折叠选单<code>Addtional Networks</code>中添加</li><li>存储地址: <code>根目录\extensions\sd-webui-addtional-networks\models\Lora</code></li><li>可以改为webui默认地址，将两个lora路径统一</li><li>记得勾选启用</li></ul></li></ul><h2 id="使用方法">使用方法</h2><h3 id="人物角色形象">人物角色形象</h3><ul><li>例子：制作赛博coser<ul><li>真实系大模型+lora</li></ul></li><li>有类lora会提供某类特定人物形象展示<ul><li>特定方向上的角色美化</li><li>可以当作调味剂，权重0.2-0.3</li><li>例子：<ul><li>Fashion girl 作者是使用很多个人审美的时尚女性制作的lora</li><li>Asian male 使用亚洲男性</li></ul></li></ul></li></ul><h3 id="画风或风格">画风或风格</h3><ul><li>替代Hypernetwork</li><li>如吉卜力画风lora</li><li>画风类lora比人物类lora影响更大，可以适当降低一点画风类lora的权重</li></ul><h2 id="概念图">概念图</h2><ul><li>Gacha splash LORA (立绘lora)</li><li>Anime Tarot Card Art Style LoRA (塔罗牌)</li><li>zyd232’s Stasis Pod/Chamber (密封舱)</li><li>mugshot lora (档案照片)</li><li>一定要看作者的readme</li></ul><h2 id="服饰">服饰</h2><ul><li><p>权重一定不要太高，如果太高容易没有人只有衣服(这是由训练时只用衣服导致的)</p></li><li><p>绘制特殊、具体的服饰 (比如你就要某个角色穿的衣服)</p></li><li><p>如果你想要强调某一个特质，比如机甲，可以用多个lora叠加强调</p></li><li><p>机甲衣服</p><ul><li>机甲的英文(Mecha)</li><li>推荐的checkpoint：<ul><li>二次元: Cetus-Mix</li><li>真实系: Experience</li></ul></li><li>机甲的lora</li><li>可以加一些提示词：cyberpunk、futuristic</li><li>如果要机甲与人紧密结合：robotic arms/legs、mechanical parts(机械义体)<br><img src="..\..\img\SD\机甲提示词.png" width="100%" height="100%" align="middle"></li></ul></li><li><p>推荐：</p><ul><li>hanfu 汉服</li><li>holographic clothing 镭射服装</li></ul></li></ul><h2 id="物体-特定元素">物体/特定元素</h2><ul><li>产品设计</li><li>可以使用局部重绘的方法将这些物品引入到作品内<ul><li>先画全图(不开LoRA)、再画小的(重绘)(打开LoRA)</li></ul></li><li><a href="https://www.bilibili.com/video/BV1nL411B7XT?spm_id_from=333.788">使用局部重绘引入头盔</a> 22:10</li></ul><h1>高清修复、细节优化、无损放大</h1><h2 id="高清修复-文生图">高清修复(文生图)</h2><ul><li><strong>打回重画，再来一幅</strong></li><li>别名：高分辨率修复、超分辨率(超分)</li><li><strong>tips</strong>:<ul><li>先在低分辨率下反复抽卡，抽到合适的后再固定种子，进行高清修复</li></ul></li></ul><h3 id="参数-2">参数</h3><ul><li>放大倍率</li><li>高清修复采样次数(高清修复需要在生成的图片基础上进行重绘)<ul><li>保持默认0, 表示沿用原始迭代次数</li></ul></li><li>重绘幅度：类似图生图(0.3-0.5)</li><li>重绘算法：<ul><li>无脑选  R-ESRGAN 4x+</li><li>二次元选R-ESRGAN 4x+ Anime6B</li><li>可以用作者推荐的</li></ul></li></ul><h2 id="SD放大">SD放大</h2><p>upscale放大脚本</p><ul><li>为上采样过程</li><li>将图片分成几块分别重绘，并拼在一起, 使用重叠的像素作为缓冲带</li><li>重叠的像素: 为缓冲带</li><li>开启SD放大后, <strong>最终宽高 = (设置的宽高-重叠像素) x 放大倍率</strong></li></ul><h2 id="附加功能放大-无损放大">附加功能放大(无损放大)</h2><ul><li>重绘幅度为0的高清修复</li><li><strong>不涉及再扩散</strong></li><li>类似老照片修复</li></ul><h1>局部重绘</h1><ul><li>使用蒙版</li></ul><h2 id="参数：">参数：</h2><ul><li>蒙版模式:<ul><li>重绘涂黑的 / 重绘未涂黑的</li></ul></li><li>蒙版蒙住的内容：<ul><li>一般用原图</li></ul></li><li>重绘区域:<ul><li>全图: 重绘全图，然后把蒙版部分拼回去(一般用这个)</li><li>仅蒙板: 只重绘蒙版部分(针对性比较强时用这个)</li></ul></li><li>蒙版模糊:<ul><li>类似羽化</li><li>使重绘区域拼接回去时更加自然(保持10以下)</li></ul></li></ul><h2 id="inPaint-Sketch-绘制-局部重绘-手涂蒙版">inPaint Sketch(绘制/局部重绘(手涂蒙版))</h2><ul><li><p>这里用画笔涂的就不是蒙版选区了，是真正的图形内容<br><img src="..\..\img\SD\inPaint_Sketch.png" width="100%" height="100%" align="middle"></p></li><li><p>蒙版透明度: 绘制的颜色印在画面上的显著程度(一般维持默认0,完全不透明)</p></li></ul><h2 id="inPaint-Upload-上传蒙版">inPaint Upload(上传蒙版)</h2><p><a href="https://www.bilibili.com/video/BV1uL411e7Uk/?spm_id_from=333.788">使用PS制作蒙版并上传</a> 12:34</p><h1>扩展插件</h1><ul><li>图库浏览器 image browser</li><li>LLC (Local Latent Couple)<ul><li>将部分区域变得更加精致</li><li>LLUL权重</li></ul></li><li>CutOff<ul><li>解决提示词间的互相干预</li></ul></li></ul><h1>ControlNet</h1><h2 id="基本原理">基本原理</h2><p>类似图生图<br><img src="..\..\img\SD\ControlNet结构.png" width="70%" height="70%" align="middle"></p><h2 id="安装和下载模型">安装和下载模型</h2><ul><li>需要下载模型</li><li>下载模型 <code>.pth</code> 和 对应的 <code>.yaml</code></li><li>模型地址(yaml文件也要放进去): <code>根目录\extensions\sd-webui-controlnet\models</code></li></ul><h2 id="基本使用方法">基本使用方法</h2><ul><li><p>先在ControlNet栏中导入一张图片(目标姿势图片)</p></li><li><p>再选择预处理器(Annotator)</p><ul><li>从图片中提取姿势的叫<code>Openpose</code></li></ul></li><li><p>再选择和当前预处理器匹配的<strong>控制模型</strong></p></li><li><p>PS:</p><ul><li>如果是图生图使用，则如果空着<code>ControlNet</code>栏的图片，则使用原图姿势</li><li>如果导入的是骨骼图，则在预处理器中选<strong>无</strong>, 然后使用生成骨骼图时对应的模型</li></ul></li></ul><h2 id="参数设置-控制效果的强弱">参数设置 (控制效果的强弱)</h2><ul><li><p>低显存模型 (如果cuda out of memory时用, 代价是速度慢一些)</p></li><li><p>Pixel Perfect (推荐选中)</p><ul><li>自动计算预处理器产出图像的最合适分辨率, 避免因为尺寸不合导致的图像模糊变形</li><li>不用手动设置预处理分辨率了</li></ul></li><li><p>Allow Preview 打开小的预处理器窗口</p></li><li><p>可以通过预处理器旁边的 <strong>爆炸</strong> 按钮来生成图片的<strong>骨骼图</strong></p></li><li><p>Control Weight 控制权重 (一般默认1)</p></li><li><p>Starting Control Step 控制ControlNet什么时候(迭代过程)生效</p></li><li><p>Ending Control Step 控制ControlNet什么时候(迭代过程)失效</p></li><li><p>Control Mode 控制ControlNet和提示词哪个更重要 (一般选blance)<br><img src="..\..\img\SD\ControlNet_ControlMode.png" width="70%" height="70%" align="middle"></p></li><li><p>lookback 默认关闭</p></li><li><p>其余一些参数是不同预处理器对应的，一般维持默认即可</p></li></ul><h2 id="ControlNet五大模型">ControlNet五大模型</h2><h3 id="openpose">openpose</h3><ul><li>openpose_face</li><li>openpose_faceonly (适合大头照)</li><li>openpose_hand</li><li>openpose_full (包含所有细节)</li></ul><h3 id="depth">depth</h3><p>用来对场景的还原<br><img src="..\..\img\SD\ControlNet_depth.png" width="70%" height="70%" align="middle"></p><ul><li><p>生成具有空间感的图片</p></li><li><p>可以解决肢体交叉问题, 比如手在头前还是头后 (但人体形状会非常固定)<br><img src="..\..\img\SD\ControlNet_Depth解决肢体交叠问题.png" width="70%" height="70%" align="middle"></p></li></ul><h3 id="canny">canny</h3><ul><li>使用边缘 精准的还原</li><li>如果输入图片是线稿, 用<code>inverse</code>的预处理器交换黑白</li></ul><h3 id="softedge-HED">softedge / HED</h3><ul><li>主要关注轮廓<br><img src="..\..\img\SD\ControlNet_HED和Canny的区别.png" width="70%" height="70%" align="middle"></li></ul><h3 id="scribble-涂鸦乱画">scribble(涂鸦乱画)</h3><ul><li>可以用乌龟图片生成乌龟形太空飞船</li></ul><h2 id="多重ControlNet应用">多重ControlNet应用</h2><ul><li><p>在配置里<code>ControlNet</code>选单中, 通过<code>MultiControlNet(多重ControlNet)</code>来设置最大模型数量</p></li><li><p>经典的组合 OpenPose和depth<br><a href="https://www.bilibili.com/video/BV1Ds4y1e7ZB?spm_id_from=333.788">组合解决手臂挡脸问题</a> 25:15</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> AI绘画 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AI绘画 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>被讨厌的勇气</title>
      <link href="/post/bc644448.html"/>
      <url>/post/bc644448.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++-左值右值</title>
      <link href="/post/2138c1e6.html"/>
      <url>/post/2138c1e6.html</url>
      
        <content type="html"><![CDATA[<h1>左值和右值概念</h1><p>在C++中，<strong>左值</strong>（lvalue）和<strong>右值</strong>（rvalue）是两个重要的概念，它们描述了表达式中对象的不同属性。理解这些概念有助于理解变量的存储、生命周期、以及如何有效地使用C++的高级功能，如移动语义和右值引用。</p><h3 id="左值（Lvalue）">左值（Lvalue）</h3><ul><li><p><strong>定义</strong>：左值（lvalue，locatable value）是指一个有名字并且可以被取地址的对象或变量。在C++中，左值通常指的是内存中的一个对象，该对象可以持久地存在，并且能够读取或修改其值。</p></li><li><p><strong>特点</strong>：</p><ul><li>可以出现在赋值运算符的左侧或右侧。</li><li>可以通过取地址符 <code>&amp;</code> 获得其地址。</li></ul></li><li><p><strong>示例</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">10</span>;   <span class="comment">// x 是一个左值</span></span><br><span class="line"><span class="type">int</span>* p = &amp;x;  <span class="comment">// x 的地址可以被取出，因此 x 是一个左值</span></span><br></pre></td></tr></table></figure><p>在这个例子中，<code>x</code> 是一个左值，因为它是一个变量，可以通过 <code>&amp;x</code> 获取其地址。</p></li></ul><h3 id="右值（Rvalue）">右值（Rvalue）</h3><ul><li><p><strong>定义</strong>：右值（rvalue，read-only value）是指那些没有明确名字，通常是临时创建并且无法取地址的值。这些值通常在表达式计算后就会消失。</p></li><li><p><strong>特点</strong>：</p><ul><li>只能出现在赋值运算符的右侧。</li><li>无法通过取地址符 <code>&amp;</code> 获得地址。</li></ul></li><li><p><strong>示例</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> y = <span class="number">5</span> + <span class="number">3</span>; <span class="comment">// 5 + 3 是一个右值，y 是左值</span></span><br></pre></td></tr></table></figure><p>在这个例子中，<code>5 + 3</code> 的结果是一个右值，因为它是一个临时值，不存在持久的内存地址。</p></li></ul><h3 id="左值引用（Lvalue-Reference）">左值引用（Lvalue Reference）</h3><ul><li><p><strong>定义</strong>：左值引用是对左值的引用，可以通过它访问和修改所引用的对象。在C++中，左值引用的声明使用 <code>&amp;</code> 符号。</p></li><li><p><strong>特点</strong>：</p><ul><li>只能绑定到左值。</li><li>允许通过引用修改对象的值。</li></ul></li><li><p><strong>示例</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span>&amp; ref = x; <span class="comment">// ref 是 x 的左值引用</span></span><br><span class="line">ref = <span class="number">20</span>;     <span class="comment">// 通过 ref 修改 x 的值</span></span><br></pre></td></tr></table></figure><p>在这个例子中，<code>ref</code> 是一个左值引用，引用了变量 <code>x</code>。修改 <code>ref</code> 的值会直接影响到 <code>x</code>。</p></li></ul><h3 id="右值引用（Rvalue-Reference）">右值引用（Rvalue Reference）</h3><ul><li><p><strong>定义</strong>：右值引用是C++11引入的一种引用类型，允许你绑定到右值。右值引用使用 <code>&amp;&amp;</code> 符号声明，主要用于实现<strong>移动语义</strong>和<strong>完美转发</strong>。</p></li><li><p><strong>特点</strong>：</p><ul><li>只能绑定到右值（临时对象）。</li><li>可以通过右值引用转移资源（如内存、文件句柄）以避免不必要的拷贝，从而提高性能。</li></ul></li><li><p><strong>示例</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>&amp;&amp; rref = <span class="number">5</span>; <span class="comment">// rref 是一个右值引用，绑定到临时值 5</span></span><br><span class="line">rref = <span class="number">10</span>;      <span class="comment">// 可以修改右值引用绑定的临时对象</span></span><br></pre></td></tr></table></figure><p>在这个例子中，<code>rref</code> 是一个右值引用，它绑定到一个临时右值 <code>5</code>。虽然是右值，但通过引用 <code>rref</code> 可以修改这个临时对象的值。</p></li></ul><h3 id="右值引用的应用">右值引用的应用</h3><ul><li><p><strong>移动语义</strong>：右值引用主要用于实现<strong>移动构造函数</strong>和<strong>移动赋值运算符</strong>。这些操作允许在不复制对象内容的情况下转移对象的资源，从而提高程序性能。</p></li><li><p><strong>完美转发</strong>：右值引用与模板结合，可以实现函数参数的<strong>完美转发</strong>，即在保持参数的左值或右值特性的同时，转发到另一个函数。</p></li></ul><h3 id="总结">总结</h3><ul><li><strong>左值</strong>：表示内存中的持久对象，可以取地址，常用于表达式的左侧。</li><li><strong>右值</strong>：表示临时对象或字面值，无法取地址，常用于表达式的右侧。</li><li><strong>左值引用</strong>：只能绑定到左值，允许通过引用修改对象。</li><li><strong>右值引用</strong>：只能绑定到右值，主要用于移动语义和完美转发。</li></ul><p>这两个引用概念让C++程序员能够更灵活地控制对象的生命周期和资源管理，从而编写出更加高效和健壮的代码。</p><h1>完美转发</h1><p>完美转发（Perfect Forwarding）是C++11引入的一个技术，用于在模板函数中将参数“完美”地转发给另一个函数，保持其原有的左值或右值特性。这对于编写泛型代码非常有用，因为它确保了参数在被传递时不会丢失任何信息或特性，比如是否是左值、右值，或常量性。</p><h3 id="问题背景">问题背景</h3><p>在模板编程中，通常会遇到需要将参数传递给另一个函数的情况。如果直接使用普通的传递方式（例如传值或引用），可能会丢失一些信息，如参数是否是右值，或者会导致不必要的拷贝。</p><p>例如，假设我们有以下函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(<span class="type">int</span>&amp; x)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Lvalue reference&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(<span class="type">int</span>&amp;&amp; x)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Rvalue reference&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">forward_to_process</span><span class="params">(T&amp;&amp; arg)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">process</span>(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>forward_to_process</code> 是一个模板函数，用来将参数 <code>arg</code> 转发给 <code>process</code> 函数。但是，如果我们调用 <code>forward_to_process</code> 时传入一个右值，那么 <code>arg</code> 在 <code>process(arg)</code> 中会被当作左值来处理，因为 <code>arg</code> 是一个左值表达式（即使它是用右值引用类型 <code>T&amp;&amp;</code> 绑定的）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">forward_to_process(<span class="number">5</span>); <span class="comment">// 传入右值，但会调用左值引用的 process</span></span><br></pre></td></tr></table></figure><h3 id="完美转发的实现">完美转发的实现</h3><p>为了解决这个问题，C++ 提供了 <code>std::forward</code>，它可以根据模板参数的类型特性来正确地转发参数，保持其原有的左值或右值性质。</p><p>修改后的代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span> <span class="comment">// std::forward</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(<span class="type">int</span>&amp; x)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Lvalue reference&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(<span class="type">int</span>&amp;&amp; x)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Rvalue reference&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">forward_to_process</span><span class="params">(T&amp;&amp; arg)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">process</span>(std::forward&lt;T&gt;(arg)); <span class="comment">// 完美转发</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>std::forward&lt;T&gt;(arg)</code> 会根据 <code>T</code> 的类型和 <code>arg</code> 的值类别来决定如何转发：<ul><li>如果 <code>T</code> 是一个左值引用类型，<code>std::forward</code> 会将 <code>arg</code> 转发为左值。</li><li>如果 <code>T</code> 是一个右值引用类型，<code>std::forward</code> 会将 <code>arg</code> 转发为右值。</li></ul></li></ul><h3 id="使用示例">使用示例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line">forward_to_process(x);  <span class="comment">// 输出: Lvalue reference</span></span><br><span class="line">forward_to_process(<span class="number">5</span>);  <span class="comment">// 输出: Rvalue reference</span></span><br></pre></td></tr></table></figure><ul><li>当我们传递 <code>x</code> 时，由于 <code>x</code> 是一个左值，<code>std::forward&lt;T&gt;(x)</code> 会将其转发为左值引用，因此调用了 <code>process(int&amp;)</code>。</li><li>当我们传递 <code>5</code> 时，<code>5</code> 是一个右值，<code>std::forward&lt;T&gt;(5)</code> 会将其转发为右值引用，因此调用了 <code>process(int&amp;&amp;)</code>。</li></ul><h3 id="完美转发的优点">完美转发的优点</h3><ul><li><p><strong>避免不必要的拷贝</strong>：通过完美转发，可以避免在传递参数时进行不必要的拷贝或移动操作，直接传递原始参数，保留其属性。</p></li><li><p><strong>保持参数类型特性</strong>：完美转发能确保参数的类型特性（如左值或右值、常量性等）不会因为转发而丢失。</p></li><li><p><strong>提高代码的泛型性</strong>：使用完美转发，编写的模板函数能够适应更多的场景，更加通用和灵活。</p></li></ul><h3 id="总结-2">总结</h3><p>完美转发通过结合 <code>std::forward</code> 和右值引用，能够在模板函数中精确地传递参数，保留其原有的值类别和类型特性。这使得模板编程更加高效和灵活，避免了传统参数传递方式可能带来的性能损失和不必要的拷贝。</p><h1>move</h1><p><code>std::move</code> 是C++11引入的一个标准库函数，用于显式地将对象转换为右值引用，从而启用对象的移动语义。这在资源管理和性能优化方面非常重要。</p><h3 id="为什么需要-std-move">为什么需要 <code>std::move</code></h3><p>在C++中，<strong>左值</strong>（lvalue）通常是有名字的、持久存在的对象，而<strong>右值</strong>（rvalue）通常是临时对象或字面值。当函数接受一个右值引用参数时，它表示这个函数可能会“窃取”或“移动”传递给它的对象资源，而不是复制它们。</p><p>例如，如果你有一个大型对象，不想在传递它时复制其内容，那么可以使用右值引用和移动语义来避免不必要的拷贝。</p><h3 id="std-move-的作用"><code>std::move</code> 的作用</h3><p><code>std::move</code> 并不会真的移动对象，而是将对象<strong>显式地转换为右值引用</strong>。这意味着它可以将一个左值（如一个变量）强制转换为右值引用，从而告诉编译器这个对象的资源可以被“移动”而不是复制。</p><h3 id="使用-std-move-的场景">使用 <code>std::move</code> 的场景</h3><p>主要用于以下情况：</p><ol><li><strong>在移动构造函数或移动赋值运算符中</strong>：通过 <code>std::move</code>，你可以将一个对象的资源转移到另一个对象中，而不是复制它们。</li><li><strong>在返回值优化中</strong>：返回局部对象时可以使用 <code>std::move</code>，让编译器更好地优化返回值。</li></ol><h3 id="示例">示例</h3><h4 id="1-使用-std-move-实现移动语义">1. 使用 <code>std::move</code> 实现移动语义</h4><p>假设我们有一个简单的类 <code>MyClass</code>，其中包含一个大数组：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span>  <span class="comment">// 包含 std::move</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; data;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">size_t</span> size) : <span class="built_in">data</span>(size) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Constructed&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移动构造函数</span></span><br><span class="line">    <span class="built_in">MyClass</span>(MyClass&amp;&amp; other) <span class="keyword">noexcept</span> : <span class="built_in">data</span>(std::<span class="built_in">move</span>(other.data)) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Move Constructed&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 禁用复制构造函数</span></span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">const</span> MyClass&amp; other) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    MyClass&amp; <span class="keyword">operator</span>=(MyClass&amp;&amp; other) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;other) &#123;</span><br><span class="line">            data = std::<span class="built_in">move</span>(other.data);</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Move Assigned&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 禁用复制赋值运算符</span></span><br><span class="line">    MyClass&amp; <span class="keyword">operator</span>=(<span class="type">const</span> MyClass&amp; other) = <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">MyClass <span class="title">obj1</span><span class="params">(<span class="number">1000000</span>)</span></span>;          <span class="comment">// 构造 obj1</span></span><br><span class="line">    <span class="function">MyClass <span class="title">obj2</span><span class="params">(std::move(obj1))</span></span>;  <span class="comment">// 移动构造 obj2</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中：</p><ul><li><code>MyClass</code> 有一个移动构造函数，使用 <code>std::move</code> 将 <code>other.data</code> 的内容移动到当前对象中。</li><li>在 <code>main</code> 函数中，<code>obj2</code> 被移动构造。<code>std::move(obj1)</code> 将 <code>obj1</code> 转换为右值引用，因此其资源（即 <code>data</code>）被转移到 <code>obj2</code>，而不再复制 <code>data</code> 的内容。</li></ul><p>输出结果会显示对象是如何被移动构造的，而不是复制：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Constructed</span><br><span class="line">Move Constructed</span><br></pre></td></tr></table></figure><h4 id="2-避免不必要的拷贝">2. 避免不必要的拷贝</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">createVector</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">temp</span><span class="params">(<span class="number">1000</span>, <span class="number">42</span>)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">move</span>(temp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个函数中，<code>std::move(temp)</code> 将 <code>temp</code> 转换为右值引用，因此返回时不需要复制 <code>temp</code> 的内容，而是直接移动其资源。</p><h3 id="总结-3">总结</h3><ul><li><strong><code>std::move</code>的主要功能</strong>：将对象转换为右值引用，以便启用移动语义。</li><li><strong><code>std::move</code>的实际用途</strong>：常用于实现移动构造函数、移动赋值运算符，避免不必要的资源复制。</li><li><strong>注意</strong>：<code>std::move</code> 本质上并不移动对象的资源，而是将其标记为可以被“窃取”或“移动”的资源。</li></ul><p><code>std::move</code> 是实现高效 C++ 代码的重要工具，尤其是在处理大量资源时，如内存、文件句柄等。通过移动语义，程序可以避免不必要的资源开销，提高性能。</p><h1>move问题</h1><h2 id="Q">Q</h2><p>移动对象是什么意思，比如上面的obj1. data移动到obj2后，ob j1中还有原来的data吗?</p><h2 id="A">A</h2><p>当我们谈到“移动对象”时，指的是将一个对象的资源（如内存、文件句柄等）从一个对象转移到另一个对象，而不是复制这些资源。移动语义可以极大地提高程序的性能，特别是在处理大对象或资源密集型对象时。</p><h3 id="移动对象的详细解释">移动对象的详细解释</h3><p>在上面的例子中，<code>MyClass</code> 中的 <code>data</code> 是一个 <code>std::vector&lt;int&gt;</code>，它管理着一个动态分配的内存块（数组）。当我们执行移动操作时，这个内存块的所有权从一个对象转移到另一个对象，而不会实际复制这块内存。</p><h3 id="具体示例：std-move-和-obj1-obj2-的移动过程">具体示例：<code>std::move</code> 和 <code>obj1</code>, <code>obj2</code> 的移动过程</h3><p>考虑这段代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">MyClass <span class="title">obj1</span><span class="params">(<span class="number">1000000</span>)</span></span>;          <span class="comment">// 构造 obj1，obj1.data 包含 1000000 个元素</span></span><br><span class="line"><span class="function">MyClass <span class="title">obj2</span><span class="params">(std::move(obj1))</span></span>;  <span class="comment">// 将 obj1.data 移动到 obj2</span></span><br></pre></td></tr></table></figure><p>这里发生了什么：</p><ol><li><p><strong>创建 <code>obj1</code></strong>:</p><ul><li><code>obj1</code> 被构造时，它的 <code>data</code> 成员变量（一个 <code>std::vector&lt;int&gt;</code>）管理了一块内存，内存中有 <code>1000000</code> 个 <code>int</code> 类型的元素。</li><li>这些元素的值是在 <code>obj1</code> 的 <code>data</code> 中分配和管理的。</li></ul></li><li><p><strong>移动构造 <code>obj2</code></strong>:</p><ul><li>当我们使用 <code>std::move(obj1)</code> 来创建 <code>obj2</code> 时，<code>std::move</code> 将 <code>obj1</code> 转换为一个右值引用，这意味着我们告诉编译器：“我们不再需要 <code>obj1</code> 的资源了，您可以将它们转移到 <code>obj2</code> 中去。”</li><li>在 <code>obj2</code> 的移动构造函数中，<code>obj2.data = std::move(obj1.data);</code> 这个操作实际上只是转移了 <code>obj1.data</code> 中的指针或句柄，而没有复制数据。这意味着 <code>obj2</code> 现在管理着 <code>obj1</code> 原来管理的那块内存。</li><li><strong>重要</strong>：此时，<code>obj1.data</code> 中的指针被置为空，或者被设置为一种“空”状态（如一个空的 <code>std::vector</code>），因为 <code>obj1</code> 不再拥有这块内存的所有权。</li></ul></li></ol><h3 id="obj1-在移动后的状态"><code>obj1</code> 在移动后的状态</h3><ul><li><strong><code>obj1</code>的 <code>data</code></strong>：在移动之后，<code>obj1.data</code> 不再指向原来的那块内存。通常，它会被设置为一个“空”状态（如一个空的 <code>std::vector</code>）。这意味着，<code>obj1</code> 不再拥有任何元素，也不能再使用之前的资源。</li><li><strong><code>obj1</code>的有效性</strong>：<code>obj1</code> 本身仍然是有效的，但它的状态通常是“未定义的”，即不能再正常使用它的资源。特别是你不应该再期望 <code>obj1</code> 的 <code>data</code> 还有原来的数据，因为这些数据已经被移动到 <code>obj2</code> 中。</li></ul><h3 id="具体例子和输出">具体例子和输出</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span> <span class="comment">// std::move</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; data;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">size_t</span> size) : <span class="built_in">data</span>(size) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Constructed with &quot;</span> &lt;&lt; data.<span class="built_in">size</span>() &lt;&lt; <span class="string">&quot; elements.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">MyClass</span>(MyClass&amp;&amp; other) <span class="keyword">noexcept</span> : <span class="built_in">data</span>(std::<span class="built_in">move</span>(other.data)) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Move Constructed&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    MyClass&amp; <span class="keyword">operator</span>=(MyClass&amp;&amp; other) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;other) &#123;</span><br><span class="line">            data = std::<span class="built_in">move</span>(other.data);</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Move Assigned&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">MyClass <span class="title">obj1</span><span class="params">(<span class="number">1000000</span>)</span></span>;          <span class="comment">// 创建 obj1，data 包含 1000000 个元素</span></span><br><span class="line">    <span class="function">MyClass <span class="title">obj2</span><span class="params">(std::move(obj1))</span></span>;  <span class="comment">// 移动构造 obj2</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;obj1 size: &quot;</span> &lt;&lt; obj1.data.<span class="built_in">size</span>() &lt;&lt; std::endl; <span class="comment">// 通常为0</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;obj2 size: &quot;</span> &lt;&lt; obj2.data.<span class="built_in">size</span>() &lt;&lt; std::endl; <span class="comment">// 1000000</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Constructed with 1000000 elements.</span><br><span class="line">Move Constructed</span><br><span class="line">obj1 size: 0</span><br><span class="line">obj2 size: 1000000</span><br></pre></td></tr></table></figure><h3 id="关键点">关键点</h3><ul><li><strong>移动后的 <code>obj1</code></strong>：<code>obj1.data</code> 的大小变为 <code>0</code>，因为它的资源已经被移动到 <code>obj2</code>。<code>obj1</code> 不再拥有原来的数据。</li><li><strong>移动后的 <code>obj2</code></strong>：<code>obj2</code> 完全接管了 <code>obj1</code> 的数据，管理着原来那块内存。</li></ul><h3 id="总结-4">总结</h3><ul><li><strong>移动语义</strong>：通过移动语义，可以将一个对象的资源从一个对象转移到另一个对象，而不是复制这些资源。</li><li><strong>移动后的对象状态</strong>：被移动的对象（如 <code>obj1</code>）通常进入一个“空”或“未定义”状态，不能再正常使用它之前的资源。</li><li><strong>性能优化</strong>：移动语义在避免不必要的复制操作上提供了巨大的性能优势，特别是在处理大对象时。</li></ul>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++-异步并发</title>
      <link href="/post/36ef8af9.html"/>
      <url>/post/36ef8af9.html</url>
      
        <content type="html"><![CDATA[<h1>async</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line"><span class="comment">//cout &lt;&lt; &quot;func &quot; &lt;&lt; i &lt;&lt; endl;</span></span><br><span class="line">ret++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// async 自动在后台开启线程</span></span><br><span class="line">future&lt;<span class="type">int</span>&gt; future_ret = <span class="built_in">async</span>(launch::async, func);</span><br><span class="line">cout &lt;&lt; <span class="built_in">func</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; future_ret.<span class="built_in">get</span>() &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1>packaged_task</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line"><span class="comment">//cout &lt;&lt; &quot;func &quot; &lt;&lt; i &lt;&lt; endl;</span></span><br><span class="line">ret++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// packaged 不会自动在后台开启线程</span></span><br><span class="line"><span class="function">packaged_task&lt;<span class="title">int</span><span class="params">()</span>&gt; <span class="title">task</span><span class="params">(func)</span></span>;</span><br><span class="line">future&lt;<span class="type">int</span>&gt; future_ret = task.<span class="built_in">get_future</span>();</span><br><span class="line"></span><br><span class="line"><span class="function">thread <span class="title">t1</span><span class="params">(move(task))</span></span>;</span><br><span class="line"></span><br><span class="line">t1.<span class="built_in">join</span>();</span><br><span class="line">cout &lt;&lt; future_ret.<span class="built_in">get</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1>promise</h1><h2 id="介绍promise">介绍promise</h2><p><code>std::promise</code> 是 C++ 标准库中的一个类，用于在多线程环境中实现异步操作和线程间的同步。它是 <future> 头文件的一部分，与 std::future 配合使用，提供了一个机制来在线程之间传递结果或异常。</p><h3 id="主要概念">主要概念</h3><ul><li>std::promise：用于设置一个值或异常，这个值或异常会被 std::future 读取。std::promise 可以被看作是生产者，它负责提供值或异常。</li><li>std::future：用于获取 std::promise 设置的值或异常。std::future 可以被看作是消费者，它负责接收和处理值或异常。</li></ul><h3 id="典型用法">典型用法</h3><p>std::promise 和 std::future 的常见使用场景包括：线程之间的结果传递、异步操作的实现、以及与 std::async 结合使用等。</p><h3 id="示例代码">示例代码</h3><p>以下是一个示例，演示了如何使用 std::promise 和 std::future：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;exception&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">compute</span><span class="params">(std::promise&lt;<span class="type">int</span>&gt;&amp;&amp; promise)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 进行计算</span></span><br><span class="line">        <span class="type">int</span> result = <span class="number">42</span>; <span class="comment">// 模拟计算结果</span></span><br><span class="line">        <span class="comment">// 设置值</span></span><br><span class="line">        promise.<span class="built_in">set_value</span>(result);</span><br><span class="line">    &#125; <span class="built_in">catch</span> (...) &#123;</span><br><span class="line">        <span class="comment">// 捕获异常并设置异常</span></span><br><span class="line">        promise.<span class="built_in">set_exception</span>(std::<span class="built_in">current_exception</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建 promise 和 future 对象</span></span><br><span class="line">    std::promise&lt;<span class="type">int</span>&gt; promise;</span><br><span class="line">    std::future&lt;<span class="type">int</span>&gt; future = promise.<span class="built_in">get_future</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建线程，传递 promise</span></span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">(compute, std::move(promise))</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 等待计算结果并获取值</span></span><br><span class="line">        <span class="type">int</span> result = future.<span class="built_in">get</span>();</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Result: &quot;</span> &lt;&lt; result &lt;&lt; std::endl; <span class="comment">// 输出 42</span></span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> std::exception&amp; e) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Exception: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    t.<span class="built_in">join</span>(); <span class="comment">// 等待线程结束</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="promise-的主要操作">promise 的主要操作</h3><ul><li><code>set_value(const T&amp; value)</code>：设置成功的结果。</li><li><code>set_value(T&amp;&amp; value)</code>：设置成功的结果，接受右值。</li><li><code>set_exception(std::exception_ptr e)</code>：设置异常。</li><li><code>set_value_at_thread_exit(const T&amp; value)</code>：设置线程结束时的值（此方法在 C++20 中引入）。</li></ul><h3 id="总结">总结</h3><p><code>std::promise</code> 和 <code>std::future</code> 提供了一种简洁的方式来实现线程间的结果传递和同步。std::promise 用于设置值或异常，std::future 用于获取这些值或异常。它们可以帮助你构建更复杂的异步程序，并提供了一种安全的方式来处理线程间的通信。</p><h2 id="问题一：">问题一：</h2><h3 id="Q">Q</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::future&lt;<span class="type">int</span>&gt; future = promise.<span class="built_in">get_future</span>();</span><br><span class="line"><span class="comment">// 创建线程，传递 promise</span></span><br><span class="line"><span class="function">std::thread <span class="title">t</span><span class="params">(compute, std::move(promise))</span></span>; </span><br></pre></td></tr></table></figure><p>这里移动了promise 那么在主进程中的future 还能关联到promise吗，是不是关联到了移动到 子进程里的promise</p><h3 id="A">A</h3><p>是的，当你将 <code>promise</code> 移动到子线程中时，主线程中的 <code>future</code> 仍然与原来的 <code>promise</code> 关联。这是因为 <code>std::promise</code> 和 <code>std::future</code> 之间的关联关系是在调用 <code>promise.get_future()</code> 时就已经建立的，并且这种关联关系是持久的，不会因为 <code>promise</code> 对象的移动而改变。</p><h4 id="详细解释">详细解释</h4><ol><li><p><strong>关联的建立</strong>：</p><ul><li>当你调用 <code>promise.get_future()</code> 时，<code>std::future&lt;int&gt; future</code> 就与 <code>promise</code> 关联起来了。这意味着 <code>future</code> 会等待 <code>promise</code> 设置一个值或异常。</li></ul></li><li><p><strong><code>promise</code> 的移动</strong>：</p><ul><li><code>std::promise</code> 可以被安全地移动，这是因为 <code>std::promise</code> 内部管理的资源（如与 <code>std::future</code> 的关联状态）并不会因为对象的移动而改变。</li><li>当你调用 <code>std::move(promise)</code> 时，<code>promise</code> 对象的内部状态被转移到新对象中（即子线程中的 <code>promise</code> 参数），而原来的 <code>promise</code> 对象在主线程中就变成了一个空的（无效的）状态。</li></ul></li><li><p><strong><code>future</code> 的有效性</strong>：</p><ul><li>即使 <code>promise</code> 被移动到子线程中，<code>future</code> 依然保持有效。它仍然会等待来自子线程中的 <code>promise</code> 设置的值或异常。</li><li>移动 <code>promise</code> 只是将 <code>promise</code> 的所有权转移到另一个作用域（子线程），但与 <code>future</code> 的关联性保持不变。</li></ul></li><li><p><strong>总结</strong>：</p><ul><li>移动 <code>promise</code> 不会影响 <code>future</code> 的功能，<code>future</code> 依然可以从移动后的 <code>promise</code> 中获取结果或异常。因此，<code>future.get()</code> 在主线程中仍然能够正确地获取子线程中通过移动后的 <code>promise</code> 设置的结果。</li></ul></li></ol><p>换句话说，<code>std::promise</code> 和 <code>std::future</code> 之间的关联关系是基于共享状态的，这种状态是独立于 <code>promise</code> 本身的具体位置或所有权的，所以移动 <code>promise</code> 并不会破坏这个关联。</p><h2 id="问题二">问题二</h2><h3 id="Q-2">Q</h3><p>那么在子线程中promise结束被销毁后主线程的future也就不能用了吧?</p><h3 id="A-2">A</h3><p>是的，在子线程中 <code>promise</code> 被销毁后，主线程中的 <code>future</code> 将无法再从这个 <code>promise</code> 获取到值。这是因为 <code>promise</code> 和 <code>future</code> 共享的状态一旦 <code>promise</code> 对象被销毁而没有设置任何值或异常，主线程中的 <code>future</code> 在访问时会抛出一个 <code>std::future_error</code> 异常。</p><h4 id="详细解释-2">详细解释</h4><ol><li><p><strong><code>promise</code> 和 <code>future</code> 的共享状态</strong>：</p><ul><li><code>std::promise</code> 和 <code>std::future</code> 共享一个内部状态，这个状态用于存储 <code>promise</code> 设置的值或异常。</li><li>当 <code>promise</code> 设置了值（<code>set_value()</code>）或异常（<code>set_exception()</code>）时，<code>future</code> 可以通过 <code>get()</code> 方法访问这个状态。</li></ul></li><li><p><strong><code>promise</code> 的销毁</strong>：</p><ul><li>如果 <code>promise</code> 在没有设置值或异常的情况下被销毁（即 <code>promise</code> 的析构函数被调用），那么 <code>future</code> 共享的状态会被标记为 “无效”。</li><li>在这种情况下，如果主线程中的 <code>future</code> 调用 <code>get()</code> 方法，会抛出 <code>std::future_error</code> 异常，具体来说是 <code>std::future_errc::broken_promise</code>。</li></ul></li><li><p><strong><code>promise</code> 销毁的影响</strong>：</p><ul><li>当 <code>promise</code> 被销毁后，主线程中的 <code>future</code> 就无法再获取到有效的结果。任何试图从这个 <code>future</code> 获取结果的操作都会导致异常。</li></ul></li><li><p><strong>示例代码</strong>：</p></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdexcept&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">compute</span><span class="params">(std::promise&lt;<span class="type">int</span>&gt;&amp;&amp; promise)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 不设置值，直接销毁 promise</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::promise&lt;<span class="type">int</span>&gt; promise;</span><br><span class="line">    std::future&lt;<span class="type">int</span>&gt; future = promise.<span class="built_in">get_future</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">(compute, std::move(promise))</span></span>;</span><br><span class="line"></span><br><span class="line">    t.<span class="built_in">join</span>(); <span class="comment">// 等待线程结束</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">int</span> result = future.<span class="built_in">get</span>(); <span class="comment">// 这里会抛出异常，因为 promise 被销毁</span></span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> std::future_error&amp; e) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Exception: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的示例中，因为子线程中的 <code>promise</code> 被销毁而没有设置值或异常，主线程中的 <code>future.get()</code> 调用将会抛出一个 <code>std::future_error</code> 异常，表示 “broken promise”。</p><h4 id="总结-2">总结</h4><ul><li><code>promise</code> 销毁后，如果没有设置任何值或异常，主线程中的 <code>future</code> 将无法正常工作，并且在访问时会抛出异常。</li><li>这意味着你需要确保 <code>promise</code> 在被销毁之前已经设置了一个值或异常，来保证 <code>future</code> 在主线程中的有效性。</li></ul><h2 id="问题三">问题三</h2><h3 id="Q-3">Q</h3><p>如果设置了值并销毁，为什么future还能拿到，它不是以及销毁了吗?</p><h3 id="A-3">A</h3><p>这是因为 <code>std::promise</code> 和 <code>std::future</code> 之间的共享状态是在堆上分配的，并且是独立于 <code>std::promise</code> 对象本身的生命周期的。</p><h4 id="详细解释-3">详细解释</h4><ol><li><p><strong>共享状态的分离</strong>：</p><ul><li>当你创建一个 <code>std::promise</code> 对象并调用 <code>get_future()</code> 时，<code>std::promise</code> 和 <code>std::future</code> 会共享一个内部状态（<code>shared state</code>），这个状态通常包括存储结果值、异常、以及同步机制的内容。</li><li>这个共享状态是动态分配的（通常在堆上），而不是直接存储在 <code>std::promise</code> 或 <code>std::future</code> 对象中。因此，这个状态的生命周期独立于 <code>std::promise</code> 和 <code>std::future</code> 对象本身。</li></ul></li><li><p><strong><code>promise</code> 的作用</strong>：</p><ul><li><code>std::promise</code> 的主要作用是通过 <code>set_value()</code> 或 <code>set_exception()</code> 来设置共享状态的内容。一旦这个值被设置，<code>promise</code> 对象的任务就基本完成了。</li><li>设置完成后，即使 <code>std::promise</code> 对象被销毁，存储的结果（或异常）仍然存在于共享状态中，<code>std::future</code> 仍然能够访问它。</li></ul></li><li><p><strong><code>future</code> 的行为</strong>：</p><ul><li>当你在主线程中使用 <code>future.get()</code> 时，它从共享状态中检索结果值或异常，而不是直接从 <code>promise</code> 对象中获取。</li><li>因为共享状态在 <code>promise</code> 对象销毁后依然存在，所以 <code>future.get()</code> 可以在 <code>promise</code> 销毁后仍然正常工作。</li></ul></li></ol><h4 id="示例代码-2">示例代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">compute</span><span class="params">(std::promise&lt;<span class="type">int</span>&gt;&amp;&amp; promise)</span> </span>&#123;</span><br><span class="line">    promise.<span class="built_in">set_value</span>(<span class="number">42</span>); <span class="comment">// 设置值</span></span><br><span class="line">    <span class="comment">// promise 对象即将被销毁</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::promise&lt;<span class="type">int</span>&gt; promise;</span><br><span class="line">    std::future&lt;<span class="type">int</span>&gt; future = promise.<span class="built_in">get_future</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">(compute, std::move(promise))</span></span>;</span><br><span class="line"></span><br><span class="line">    t.<span class="built_in">join</span>(); <span class="comment">// 等待线程结束</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 即使 promise 对象已销毁，future 仍能从共享状态中获取值</span></span><br><span class="line">    <span class="type">int</span> result = future.<span class="built_in">get</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Result: &quot;</span> &lt;&lt; result &lt;&lt; std::endl; <span class="comment">// 输出：Result: 42</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结-3">总结</h4><ul><li>当 <code>std::promise</code> 设置了值后，它的内部共享状态将包含这个值，即使 <code>promise</code> 对象本身被销毁，这个值仍然存在于共享状态中。</li><li><code>std::future</code> 在访问结果时，实际是从共享状态中获取数据，而不是直接依赖于 <code>promise</code> 对象的存在。这就是为什么即使 <code>promise</code> 被销毁了，<code>future</code> 仍然能够获取到先前设置的值。</li></ul>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++-线程池</title>
      <link href="/post/41fb03b2.html"/>
      <url>/post/41fb03b2.html</url>
      
        <content type="html"><![CDATA[<h1>涉及知识点</h1><ul><li>mutex</li><li>lock</li><li>lamda表达式</li><li>队列queue</li><li>emplace</li><li>可变参数</li><li>模板函数</li><li>万能引用</li><li>左值引用</li><li>右值引用</li><li>完美转发forward</li><li>函数适配器bind</li><li>时间库chrono</li></ul><h1>代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadPool</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">ThreadPool</span>(<span class="type">int</span> numThreads): <span class="built_in">stop</span>(<span class="literal">false</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numThreads; i++) &#123;</span><br><span class="line">threads.<span class="built_in">emplace_back</span>([<span class="keyword">this</span>] &#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">function&lt;<span class="built_in">void</span>()&gt; task;</span><br><span class="line">&#123;</span><br><span class="line">unique_lock&lt;mutex&gt; <span class="built_in">lock</span>(mtx);</span><br><span class="line">condition.<span class="built_in">wait</span>(lock, [<span class="keyword">this</span>] &#123;</span><br><span class="line"><span class="keyword">return</span> !tasks.<span class="built_in">empty</span>() || stop;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">if</span> (stop &amp;&amp; tasks.<span class="built_in">empty</span>()) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">task = <span class="built_in">move</span>(tasks.<span class="built_in">front</span>());</span><br><span class="line">tasks.<span class="built_in">pop</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">task</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~<span class="built_in">ThreadPool</span>() &#123;</span><br><span class="line">&#123;</span><br><span class="line"><span class="function">unique_lock&lt;mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">stop = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">condition.<span class="built_in">notify_all</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; t : threads) &#123;</span><br><span class="line">t.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> F, <span class="keyword">class</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">enqueue</span><span class="params">(F &amp;&amp; f, Args&amp;&amp;... args)</span> </span>&#123;</span><br><span class="line">function&lt;<span class="type">void</span>()&gt;task = <span class="built_in">bind</span>(forward&lt;F&gt;(f), forward&lt;Args&gt;(args)...);</span><br><span class="line">&#123;</span><br><span class="line"><span class="function">unique_lock&lt;mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">tasks.<span class="built_in">emplace</span>(<span class="built_in">move</span>(task));</span><br><span class="line">&#125;</span><br><span class="line">condition.<span class="built_in">notify_one</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">vector&lt;thread&gt; threads;</span><br><span class="line">queue&lt;function&lt;<span class="type">void</span>()&gt; &gt; tasks;</span><br><span class="line"></span><br><span class="line">mutex mtx;</span><br><span class="line">condition_variable condition;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> stop;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">ThreadPool <span class="title">pool</span><span class="params">(<span class="number">4</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">12</span>; i++) &#123;</span><br><span class="line">pool.<span class="built_in">enqueue</span>([i] &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;task : &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;is running !&quot;</span>&lt;&lt;endl;</span><br><span class="line">this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">seconds</span>(<span class="number">2</span>));</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;task : &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;is close !&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++-线程安全</title>
      <link href="/post/b0174cac.html"/>
      <url>/post/b0174cac.html</url>
      
        <content type="html"><![CDATA[<p><a href="http://www.seestudy.cn/?list_9/35.html">参考博客</a></p><h1>thread</h1><h2 id="int">int</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span>&amp; x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">x += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="function">thread <span class="title">t1</span><span class="params">(func, ref(a))</span></span>;</span><br><span class="line">t1.<span class="built_in">join</span>();</span><br><span class="line">cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="类">类</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Hello !&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 智能指针 当当前变量不再被需要时 自动释放</span></span><br><span class="line">shared_ptr&lt;A&gt; a = <span class="built_in">make_shared</span>&lt;A&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function">thread <span class="title">t</span><span class="params">(&amp;A::func, a)</span></span>;</span><br><span class="line">t.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1>mutex</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">timed_mutex mtx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span>&amp; x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line"><span class="function">unique_lock&lt;timed_mutex&gt; <span class="title">lg</span><span class="params">(mtx, defer_lock)</span></span>;</span><br><span class="line"><span class="keyword">if</span> (lg.<span class="built_in">try_lock_for</span>(chrono::<span class="built_in">seconds</span>(<span class="number">2</span>))) &#123;</span><br><span class="line">x++;</span><br><span class="line">this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line"><span class="function">thread <span class="title">thread1</span><span class="params">(func, ref(n))</span></span>;</span><br><span class="line"><span class="function">thread <span class="title">thread2</span><span class="params">(func, ref(n))</span></span>;</span><br><span class="line">thread1.<span class="built_in">join</span>();</span><br><span class="line">thread2.<span class="built_in">join</span>();</span><br><span class="line">cout &lt;&lt; n &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>unique_lock shard_lock</h1><h1>condition_variable</h1><h2 id="生产者-消费者">生产者 消费者</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">mutex mtx;</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; mque;</span><br><span class="line">condition_variable cg;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">productor</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line"><span class="function">unique_lock&lt;mutex&gt; <span class="title">ul</span><span class="params">(mtx)</span></span>;</span><br><span class="line">mque.<span class="built_in">push</span>(i);</span><br><span class="line">cg.<span class="built_in">notify_one</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;生产了&quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">microseconds</span>(<span class="number">100</span>));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">consumer</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"><span class="function">unique_lock&lt;mutex&gt; <span class="title">ul</span><span class="params">(mtx)</span></span>;</span><br><span class="line">cg.<span class="built_in">wait</span>(ul, []() &#123;<span class="keyword">return</span> !mque.<span class="built_in">empty</span>(); &#125;);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> value = mque.<span class="built_in">front</span>();</span><br><span class="line">mque.<span class="built_in">pop</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;消费了&quot;</span>&lt;&lt;value&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">thread <span class="title">prod</span><span class="params">(productor)</span></span>;</span><br><span class="line"><span class="function">thread <span class="title">cons</span><span class="params">(consumer)</span></span>;</span><br><span class="line"></span><br><span class="line">prod.<span class="built_in">join</span>();</span><br><span class="line">cons.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>atomic</h1><p>原子操作 比 加锁 效率高</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">atomic&lt;<span class="type">int</span>&gt; shared_data = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000000</span>; i++) &#123;</span><br><span class="line">shared_data++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">thread <span class="title">t1</span><span class="params">(func)</span></span>;</span><br><span class="line"><span class="function">thread <span class="title">t2</span><span class="params">(func)</span></span>;</span><br><span class="line">t1.<span class="built_in">join</span>();</span><br><span class="line">t2.<span class="built_in">join</span>();</span><br><span class="line"><span class="comment">//store load 操作 可以保证原子性</span></span><br><span class="line">shared_data.<span class="built_in">store</span>(<span class="number">1</span>);</span><br><span class="line">cout &lt;&lt; shared_data.<span class="built_in">load</span>() &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计网优秀博客收藏</title>
      <link href="/post/8d32812f.html"/>
      <url>/post/8d32812f.html</url>
      
        <content type="html"><![CDATA[<h1>学习建议</h1><p><a href="https://mp.weixin.qq.com/s?__biz=MzI0NDc3ODE5OQ==&amp;mid=2247488726&amp;idx=1&amp;sn=52b1e3c7932aa8a717661663acadc91d&amp;chksm=e959c16ede2e48784bdc118694c1b40dc20f907542d41ec305211e39efd4f3c411fc854777bb&amp;scene=178&amp;cur_album_id=1677418448106143748#rd">如何构建计算机网络知识体系</a></p><h1>基础知识点</h1><p><a href="https://mp.weixin.qq.com/s?__biz=MzI0NDc3ODE5OQ==&amp;mid=2247483833&amp;idx=1&amp;sn=b9e1af65bdd6d663060bb1cbc44ab3dd&amp;chksm=e959d401de2e5d17ed27203d439a20df99f9de0beb877073725a98f2eae2ac563741a34670fb&amp;scene=178&amp;cur_album_id=1677418448106143748#rd">两台计算机之间是如何通信的</a></p><p><a href="https://mp.weixin.qq.com/s?__biz=MzI0NDc3ODE5OQ==&amp;mid=2247484306&amp;idx=1&amp;sn=0498760c107b773d01a79c340c7f3fcd&amp;scene=21#wechat_redirect">IP协议精讲</a></p><p><a href="https://mp.weixin.qq.com/s?__biz=MzI0NDc3ODE5OQ==&amp;mid=2247484446&amp;idx=1&amp;sn=d5c82d41de69f507a2e59f3fb6074d7a&amp;chksm=e959d1a6de2e58b0600525cbc92e843f560a3ae8de4c09d2cd916f43ea2ff2eb767220f2fbef&amp;scene=178&amp;cur_album_id=1677418448106143748#rd">ARP协议精讲</a></p><p><a href="https://mp.weixin.qq.com/s?__biz=MzI0NDc3ODE5OQ==&amp;mid=2247484021&amp;idx=1&amp;sn=62ecef5d4b08b542056f2f614f5fb4b6&amp;scene=21#wechat_redirect">TCP 三次握手和四次挥手</a></p><p><a href="https://mp.weixin.qq.com/s?__biz=MzI0NDc3ODE5OQ==&amp;mid=2247484407&amp;idx=1&amp;sn=44688d37144e4b65d59bf37a90945f0a&amp;chksm=e959d64fde2e5f59ac0471a359c308d14c289600cb12341ae739c6677b6f1cb209b0a2d4c1c1&amp;scene=178&amp;cur_album_id=1677418448106143748#rd">DNS协议解析</a></p><p><a href="https://mp.weixin.qq.com/s?__biz=MzI0NDc3ODE5OQ==&amp;mid=2247484533&amp;idx=1&amp;sn=015674c8b75933e27111fad6a13b22d4&amp;chksm=e959d1cdde2e58dbfb219a22e14485bac3d70924d76b42a534cc6c667e3f7a5874c80b06407c&amp;scene=178&amp;cur_album_id=1677418448106143748#rd">HTTP协议</a></p><p><a href="https://mp.weixin.qq.com/s?__biz=MzI0NDc3ODE5OQ==&amp;mid=2247486703&amp;idx=1&amp;sn=6a7c5518b78e593e73b587a49dfb4695&amp;chksm=e959d957de2e5041ebed1b08a53cc8d0eba9ad5ff8630c65fc5c93fb446bbe4afd0a6fbb24cd&amp;scene=178&amp;cur_album_id=1677418448106143748#rd">ICMP协议</a></p><p><a href="https://mp.weixin.qq.com/s?__biz=MzI0NDc3ODE5OQ==&amp;mid=2247487338&amp;idx=1&amp;sn=e5bf451ad638e504edbf9c40aa596ae2&amp;chksm=e959dad2de2e53c460bcc3b9d7d3c0e8eb234f57398e867d10eb3f6eb43d75e6b1f142a0abc8&amp;scene=178&amp;cur_album_id=1677418448106143748#rd">DHCP协议</a></p><p><a href="https://mp.weixin.qq.com/s?__biz=MzI0NDc3ODE5OQ==&amp;mid=2247491297&amp;idx=1&amp;sn=24ca974567e890e4735af6033a59760e&amp;chksm=e959cb59de2e424f6d42a55556452f2f523f0fe6756392dde1fc6923c4decf35fd1bdff73298&amp;scene=178&amp;cur_album_id=1677418448106143748#rd">滑动窗口协议</a></p><h1>面试</h1><p><a href="https://cloud.tencent.com/developer/article/1793846">在浏览器中输入网址后回车发生了什么</a></p><p><a href="https://mp.weixin.qq.com/s?__biz=MzI0NDc3ODE5OQ==&amp;mid=2247486620&amp;idx=1&amp;sn=86e1ca0047c0759e14a24b9e059a81b8&amp;chksm=e959d924de2e5032acfa72023823aac41972e993abca93eac8152226a0617001343a08740b88&amp;scene=178&amp;cur_album_id=1677418448106143748#rd">为什么DNS协议使用UDP</a></p><p><a href="https://mp.weixin.qq.com/s?__biz=MzI0NDc3ODE5OQ==&amp;mid=2247492034&amp;idx=1&amp;sn=7621ba55a60a55fa10936771beb4b0e4&amp;chksm=e95a347ade2dbd6c172c93c89a9dbafc6d4e6563031032b7368d7e59a23bd334256502b964e6&amp;scene=178&amp;cur_album_id=1677418448106143748#rd">DDos攻击</a></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OSI七层参考模型</title>
      <link href="/post/fa35e9d3.html"/>
      <url>/post/fa35e9d3.html</url>
      
        <content type="html"><![CDATA[<p><strong>参考网址</strong>：</p><ul><li><a href="https://blog.csdn.net/xx16755498979/article/details/132489516">https://blog.csdn.net/xx16755498979/article/details/132489516</a></li></ul><h1>OSI七层参考模型</h1><h2 id="物理层">物理层</h2><ul><li>主要定义物理设备标准，如网线接口类型、传输介质的传输速率等。</li><li>作用：传输比特流（数模转换和模数转换）</li><li>数据：<strong>比特</strong></li></ul><h2 id="数据链路层">数据链路层</h2><ul><li>定义如何让格式化数据以<strong>帧</strong>为单位进行传输，以及如何控制对物理介质的访问，用MAC地址访问介质。</li><li>作用：建立逻辑连接、进行<strong>硬件地址寻址</strong>、差错校验</li><li>数据：<strong>帧</strong></li></ul><h2 id="网络层">网络层</h2><ul><li>进行逻辑地址寻址</li><li>作用：在位于不同地理位置的网络中的两个主机系统之间提供连接和路径选择。</li></ul><h2 id="传输层">传输层</h2><ul><li>定义了一些传输数据的协议和端口号(WWW端口80)，如TCP、UDP。</li><li>作用：将从下层接收的数据进行分段和传输，到达目的地址后再进行重组。</li><li>数据：<strong>段</strong></li></ul><h2 id="会话层">会话层</h2><ul><li>通过传输层(端口号：传输端口与接收端口)建立数据传输的通路。</li><li>作用:再系统之间发起会话或者接受会话请求</li></ul><h2 id="表示层">表示层</h2><ul><li>数据的表示、安全、压缩</li><li>作用: 进行对接收的数据进行解释、加密与解密、压缩与解压缩(把计算机能识别的东西转换为人能识别的东西，如图片、声音等)</li></ul><h2 id="应用层">应用层</h2><ul><li>网络服务与最终用户的一个接口</li><li>作用：为用户的应用程序提供网络服务</li></ul><h1>数据链路层</h1><ul><li>数据链路层是TCP/IP网络模型的第二层，基于物理层和网络层之间，数据链路层在物理层提供的服务的基础上向网络层提供服务</li><li>其最基本的服务是将源自物理层来的数据可靠地传输到<strong>相邻节点</strong>的目标机网络层。</li></ul><h2 id="ARP协议">ARP协议</h2><ul><li>ARP协议是数据进行网络传输过程中，通过IP地址向MAC地址的转换，解决网络层和物理层衔接问题</li></ul><h3 id="引入ARP协议的目的：">引入ARP协议的目的：</h3><p>由于 IP 地址和 MAC 地址定位方式不同，ARP 协议成为数据传输的必备协议。主机发送信息前，必须通过 ARP 协议获取目标 IP 地址对应的 MAC 地址，才能正确地发送数据包。</p><h3 id="ARP的工作流程：">ARP的工作流程：</h3><ul><li>主机A以广播的形式向该网段内的所有主机发送ARP请求，请求中包含了目的主机的IP地址</li><li>主机B接收到请求，通过请求中的目的IP地址发现自己是主机A要找的，返回响应，响应包括主机B的 MAC地址</li></ul><h3 id="ARP缓存：">ARP缓存：</h3><ul><li><p>在请求目标主机的 MAC 地址时，每次获取目标主机 MAC 地址都需要发送一次 ARP 请求，然后根据响应获取到 MAC 地址。</p></li><li><p>为了避免重复发送 ARP 请求，每台主机都有一个 ARP 高速缓存。当主机得到 ARP 响应后，将目标主机的 IP 地址和物理地址存入本机 ARP 缓存中，并保留一定时间。</p></li><li><p>只要在这个时间范围内，下次请求 MAC 地址时，直接查询 ARP 缓存，而无须再发送 ARP 请求，从而节约了网络资源。</p></li></ul><h1>网络层</h1><ul><li>网络层是基于数据链路层和传输层之间的第三层协议，它在数据链路层提供的两个相邻端点之间的数据帧的传送功能上，进一步管理网络中的数据通信，将数据设法从源端经过若干个中间节点传送到目的端，从而向传输层提供最基本的端到端的数据传送服务</li><li>网络层的目的是实现两个端系统之间的数据透明传送，具体功能包括寻址和路由选择、连接的建立、保持和终止等。它提供的服务使传输层不需要了解网络中的数据传输和交换技术。</li></ul><h2 id="IP协议">IP协议</h2><ul><li><p>IP协议是TCP/IP网络模型中的核心部分，他提供了一种分层的、无关硬件的寻址方式，可以在复杂的路由式网络中传递数据所需的服务</p></li><li><p>IP协议可以将多个交换网络连接起来，在源地址和目的地址之间传输数据包，同时它还能提供数据的组装功能，以适应不同网络对数据包大小的要求</p></li></ul><h3 id="预研知识">预研知识</h3><blockquote><p><strong>IP地址</strong>：<br>IP地址是互联网协议特有的一种地址，它是IP协议提供的一种统一的地址格式，IP地址为互联网的每个网络和每台主机分配了一个逻辑地址，以此来屏蔽物理地址的差异</p></blockquote><blockquote><p><strong>IP地址的格式</strong>：<br>IP地址为32位地址，被分为4个部分，<a href="http://xn--XXX-eo8e.XXX.XXX.XXX">如XXX.XXX.XXX.XXX</a>，IP地址又被划分为两个部分<br><strong>网络号</strong>：前三部分用于标识网段，保证相互连接的两个网段有不同标识<br><strong>主机号</strong>：由最后一部分组成，用于标识主机，保证处于同一网段的两台主机有不同的主机号<br>通过合理设置主机号和网络号, 就可以保证在相互连接的网络中, 每台主机的IP地址都不相同4</p></blockquote><blockquote><p><strong>MAC地址</strong>：<br>被称为物理地址，是用来标识网络中每个设备的，MAC地址是设备出厂之后就写死的</p></blockquote><h3 id="引入IP地址的目的：">引入IP地址的目的：</h3><ul><li>在<strong>单个局域网网段</strong>中，计算机与计算机之间可以使用数据链路层提供的MAC地址进行通信</li><li>如果在<strong>路由式网络</strong>中，计算机之间就不能用MAC地址实现通信，主要是因为在路由式网络中，数据只是经过一次简单的利用两个计算机之间的MAC地址建立通信，而是<strong>需要进行多次的通信</strong>，每次跳转都会体目的主机更近一步，经历都次跳转，最终找到目的主机实现通信，而这个过程中，<strong>要知道每次向哪跳转才能更接近目的主机，必须使用一种逻辑化、层次化的寻址方案对网络进行组织</strong>，这就是 IP 地址</li></ul><h3 id="IP协议的工作方式：">IP协议的工作方式：</h3><p>由于网络分为同网段和不同网段，所以会分成两种方式</p><h4 id="同网段：">同网段：</h4><p>如果源地址主机和目的地址主机处于同一网段，则目的IP地址被 ARP协议 解析为MAC地址后，源主机会根据目的MAC地址直接将数据包发送给目的主机</p><h4 id="不同网段-先上后下-：">不同网段(先上后下)：</h4><p>如果源地址主机和目的地址主机不处于同一网段，则数据包会经历多个过程最终发送给目的主机</p><ol><li><strong>网关</strong>(一般为路由器)的 IP地址 被 ARP协议 解析为 MAC地址，根据该 MAC地址 源主机会将数据包发送到网关</li><li>网关根据数据包中的网段ID找到目标网络，如果找到，将数据包发送给目标网路，如果没有则<strong>重复第一步发送到更高一级网关</strong></li><li>数据包经过网关发送到正确的网段后，目标IP被 ARP协议 解析为MAC地址，在根据该 MAC地址 将数据包发送给目标地址的主机</li></ol><h2 id="ICMP协议">ICMP协议</h2><ul><li>ICMP协议又叫控制报文协议，ICMP协议用于在IP 和 路由器之间传递控制消息，描述网络是否通畅、主机是否可达、路由器是否可用等网络状态，ICMP本身并不传输数据，但对于用户间数据的传递起着重要的作用</li><li>作用：<br>在数据包从源主机传输到目的主机的过程中，会经历一个或多个路由器，而数据包在经过这些路由器传输过程中，可能会遇到很多问题，最终导致数据包没有成功传递给目的主机。为了了解数据包在传输过程中在哪个环节出了问题，就需要用到ICMP协议，它可以跟踪数据包，并把消息返回给源主机</li></ul><h1>传输层协议</h1><h1></h1>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++-模板</title>
      <link href="/post/db164a07.html"/>
      <url>/post/db164a07.html</url>
      
        <content type="html"><![CDATA[<h1>模板概念</h1><p>C++ 模板（Templates）是 C++ 中一种强大的工具，用于实现泛型编程。模板允许编写与类型无关的代码，从而可以重用代码，并在编译时生成特定类型的代码。这种机制可以用于函数、类和别名模板等。</p><h3 id="1-什么是模板？">1. 什么是模板？</h3><p>模板是一种用于创建通用代码的机制，它允许我们编写一次代码，然后用不同的数据类型来使用它，而不需要重复编写相同的逻辑。例如，可以使用模板创建一个可以处理 <code>int</code>、<code>double</code>、<code>char</code> 等类型的函数或类。</p><h3 id="2-函数模板">2. 函数模板</h3><p>函数模板是用于生成可以接受不同类型参数的函数的模板。其语法如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">add</span><span class="params">(T a, T b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个示例中：</p><ul><li><code>template&lt;typename T&gt;</code> 声明了一个模板，<code>T</code> 是一个占位符类型。</li><li><code>add</code> 函数的参数类型和返回类型都是 <code>T</code>，这意味着它可以处理任何类型的数据，只要这些数据支持 <code>+</code> 操作符。</li></ul><h4 id="函数模板的使用">函数模板的使用</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">10</span>, y = <span class="number">20</span>;</span><br><span class="line">    <span class="type">double</span> a = <span class="number">1.5</span>, b = <span class="number">2.5</span>;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">add</span>(x, y) &lt;&lt; std::endl; <span class="comment">// 输出 30</span></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">add</span>(a, b) &lt;&lt; std::endl; <span class="comment">// 输出 4.0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在编译时，编译器会根据调用 <code>add</code> 函数时传递的参数类型来实例化模板，为 <code>int</code> 和 <code>double</code> 类型生成对应的函数。</p><h3 id="3-类模板">3. 类模板</h3><p>类模板允许我们创建能够处理不同类型数据的类。其语法如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    T value;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">MyClass</span>(T v) : <span class="built_in">value</span>(v) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">T <span class="title">getValue</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在这个示例中：</p><ul><li><code>template&lt;typename T&gt;</code> 声明了一个类模板。</li><li><code>MyClass</code> 是一个模板类，其中 <code>T</code> 是一个占位符类型，代表可以由用户指定的任何类型。</li><li><code>value</code> 成员变量和 <code>getValue</code> 函数的返回类型都依赖于 <code>T</code>。</li></ul><h4 id="类模板的使用">类模板的使用</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">MyClass&lt;<span class="type">int</span>&gt; <span class="title">obj1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="function">MyClass&lt;<span class="type">double</span>&gt; <span class="title">obj2</span><span class="params">(<span class="number">3.14</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; obj1.<span class="built_in">getValue</span>() &lt;&lt; std::endl; <span class="comment">// 输出 10</span></span><br><span class="line">    std::cout &lt;&lt; obj2.<span class="built_in">getValue</span>() &lt;&lt; std::endl; <span class="comment">// 输出 3.14</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当创建 <code>MyClass&lt;int&gt;</code> 时，<code>T</code> 被替换为 <code>int</code>；创建 <code>MyClass&lt;double&gt;</code> 时，<code>T</code> 被替换为 <code>double</code>。这意味着可以用相同的类模板处理不同类型的数据。</p><h3 id="4-模板的特化">4. 模板的特化</h3><p>模板特化允许我们为特定类型提供专门的实现。它分为<strong>完全特化</strong>和<strong>部分特化</strong>。</p><h4 id="4-1-完全特化">4.1 完全特化</h4><p>完全特化是为某个特定的类型提供模板的特定实现。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>&lt;<span class="type">char</span>&gt; &#123; <span class="comment">// 为 char 类型提供特化版本</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">char</span> value;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">char</span> v) : <span class="built_in">value</span>(v) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">char</span> <span class="title">getValue</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Char value: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="4-2-部分特化">4.2 部分特化</h4><p>部分特化是为某些类型提供特定的实现，而不是为所有类型。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>&lt;T*&gt; &#123; <span class="comment">// 为指针类型提供特化版本</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    T* value;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">MyClass</span>(T* v) : <span class="built_in">value</span>(v) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">T* <span class="title">getValue</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="5-模板的使用场景">5. 模板的使用场景</h3><ul><li><strong>通用算法</strong>：如排序、搜索等算法可以使用模板来处理不同类型的数据。</li><li><strong>容器类</strong>：如 <code>std::vector</code>、<code>std::list</code>、<code>std::map</code> 等 STL 容器类都是模板类，它们可以存储不同类型的数据。</li><li><strong>智能指针</strong>：如 <code>std::unique_ptr</code>、<code>std::shared_ptr</code>，它们是模板类，可以管理不同类型的资源。</li></ul><h3 id="6-模板的限制与注意事项">6. 模板的限制与注意事项</h3><ul><li><strong>编译时间增长</strong>：模板的实例化发生在编译时，因此可能导致编译时间增长。</li><li><strong>错误信息复杂</strong>：模板编程的错误信息有时非常复杂，难以理解和调试。</li><li><strong>代码膨胀</strong>：如果使用大量的模板实例化，可能导致编译出来的二进制文件变大。</li></ul><h3 id="7-进阶：模板编程中的一些重要概念">7. 进阶：模板编程中的一些重要概念</h3><h4 id="7-1-模板元编程（Template-Metaprogramming）">7.1 模板元编程（Template Metaprogramming）</h4><p>模板元编程是一种编写在编译时执行计算的代码的技术。例如，可以使用模板计算在编译时的常量，或进行条件编译。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="type">int</span> N&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Factorial</span> &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> value = N * Factorial&lt;N - <span class="number">1</span>&gt;::value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Factorial</span>&lt;<span class="number">0</span>&gt; &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> value = <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Factorial of 5: &quot;</span> &lt;&lt; Factorial&lt;<span class="number">5</span>&gt;::value &lt;&lt; std::endl; <span class="comment">// 输出120</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7-2-SFINAE（Substitution-Failure-Is-Not-An-Error）">7.2 SFINAE（Substitution Failure Is Not An Error）</h4><p>SFINAE 是模板编程中的一个重要概念，它指的是在模板参数替换过程中发生的错误不会导致编译失败，而是编译器会继续尝试其他重载版本或特化版本。</p><h3 id="总结">总结</h3><p>模板是 C++ 中的一项强大特性，能够实现泛型编程，允许编写与类型无关的代码。通过函数模板和类模板，可以编写更加通用和灵活的代码。模板特化提供了针对特定类型的优化实现，而模板元编程更是扩展了编译期计算的可能性。尽管模板编程复杂，但它在提高代码重用性和效率方面具有重要作用。</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单调栈</title>
      <link href="/post/16518a5d.html"/>
      <url>/post/16518a5d.html</url>
      
        <content type="html"><![CDATA[<h1>单调栈</h1><h2 id="单调栈分为单调递增栈和单调递减栈">单调栈分为单调递增栈和单调递减栈</h2><pre><code>- 单调递增栈即栈内元素保持单调递增的栈- 同理单调递减栈即栈内元素保持单调递减的栈</code></pre><h2 id="操作规则（下面都以单调递增栈为例）">操作规则（下面都以单调递增栈为例）</h2><ul><li><p>如果新的元素比栈顶元素大，就入栈</p></li><li><p>如果新的元素较小，那就一直把栈内元素弹出来，直到栈顶比新元素小</p></li><li><p>效果</p><ul><li>栈内的元素是递增的</li><li>当元素出栈时，说明这个<strong>新元素</strong>是出栈元素<strong>向后</strong>找第一个比其小的元素</li></ul><blockquote><p>举个例子，配合下图，现在索引在 6 ，栈里是 1 5 6 。<br>接下来新元素是 2 ，那么 6 需要出栈。<br>当 6 出栈时，右边 2 代表是 6 右边第一个比 6 小的元素。</p></blockquote><ul><li>当元素出栈后，说明<strong>新栈顶元素</strong>是<strong>出栈元素</strong>向前找第一个比其小的元素</li></ul><blockquote><p>当 6 出栈时，5 成为新的栈顶，那么 5 就是 6 左边第一个比 6 小的元素。</p></blockquote></li></ul><h1>模板</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">stack&lt;<span class="type">int</span>&gt; st;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(!st.<span class="built_in">empty</span>() &amp;&amp; st.<span class="built_in">top</span>() &gt; nums[i])</span><br><span class="line">&#123;</span><br><span class="line">st.<span class="built_in">pop</span>();</span><br><span class="line">&#125;</span><br><span class="line">st.<span class="built_in">push</span>(nums[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1>例题</h1><h2 id="84-柱状图中最大的矩形：">84 柱状图中最大的矩形：</h2><p><a href="https://leetcode.cn/problems/largest-rectangle-in-histogram/description/">https://leetcode.cn/problems/largest-rectangle-in-histogram/description/</a></p><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">largestRectangleArea</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; heights)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        heights.<span class="built_in">insert</span>(heights.<span class="built_in">begin</span>(), <span class="number">0</span>);</span><br><span class="line">        heights.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; st;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;heights.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(!st.<span class="built_in">empty</span>() &amp;&amp; heights[st.<span class="built_in">top</span>()] &gt; heights[i])&#123; </span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="85-最大矩形">85 最大矩形</h2><p><a href="https://leetcode.cn/problems/maximal-rectangle/description/">https://leetcode.cn/problems/maximal-rectangle/description/</a></p><p>代码:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maximalRectangle</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">heights</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;matrix.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;n; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(matrix[i][j] == <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">                    heights[j] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    heights[j]++;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, <span class="built_in">maxRectangle</span>(heights));</span><br><span class="line">            heights.<span class="built_in">pop_back</span>();</span><br><span class="line">            heights.<span class="built_in">erase</span>(heights.<span class="built_in">begin</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxRectangle</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; heights)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        heights.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">        heights.<span class="built_in">insert</span>(heights.<span class="built_in">begin</span>(), <span class="number">0</span>);</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; st;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;heights.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(!st.<span class="built_in">empty</span>() &amp;&amp; heights[st.<span class="built_in">top</span>()] &gt; heights[i])&#123;</span><br><span class="line">                <span class="type">int</span> height = heights[st.<span class="built_in">top</span>()];</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="type">int</span> left = st.<span class="built_in">top</span>() + <span class="number">1</span>;</span><br><span class="line">                <span class="type">int</span> right = i - <span class="number">1</span>;</span><br><span class="line">                ret = <span class="built_in">max</span>(ret, height * (right - left + <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            st.<span class="built_in">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编译原理-语法制导翻译与属性文法</title>
      <link href="/post/bb02e719.html"/>
      <url>/post/bb02e719.html</url>
      
        <content type="html"><![CDATA[<h1>语法制导翻译概述</h1><p>语法分析的基础上，根据源程序中各语法结构的语义进行翻译<br>编译器一般先将经过语法分析后的源程序翻译成某种形式的中间代码</p><h2 id="语义分析器的主要任务">语义分析器的主要任务</h2><p>检查各个语法结构的静态语义，即<strong>验证语法正确的程序结构是否真正有意义</strong>，也称为<strong>静态语义分析</strong>或<strong>静态检查</strong></p><ul><li><strong>类型检查</strong>：操作数和操作符的类型是否相容；</li><li><strong>控制流检查</strong>：控制流转向目标地址是否合法；</li><li><strong>唯一性检查</strong>：对象是否被重复定义；</li><li><strong>关联名检查</strong>：同一名字多次特定出现是否一致。</li></ul><p>将<strong>静态检查</strong>和<strong>中间代码生成</strong>结合到<strong>语法分析</strong>中进行的技术称为<strong>语法制导翻译</strong> (syntax-directed translation)</p><h2 id="语法制导翻译的基本思想">语法制导翻译的基本思想</h2><ul><li>在进行语法分析的同时，完成相应的<strong>语义处理</strong></li><li>一旦语法分析器识别出一个语法结构（例如E-&gt;E+T）就要立即对其进行<strong>翻译</strong>。</li><li>翻译是根据语言的语义进行的，并通过调用事先为该<strong>语法结构</strong>编写的<strong>语义子程序</strong>来实现。</li><li>对文法中的每个产生式附加一个/多个语义动作(或<strong>语义子程序</strong>)</li><li>在语法分析的过程中，每当需要使用一个产生式进行<strong>推导或归约</strong>时，语法分析程序除执行相应的<strong>语法分析动作</strong>外，还要执行相应的语义动作(或<strong>调用相应的语义子程序</strong>)</li></ul><h2 id="语义子程序的功能">语义子程序的功能</h2><ul><li>指明相应产生式中各个<strong>文法符号的具体含义</strong>，并规定了使用该产生式进行分析时所应采取的<strong>语义动作</strong>。</li><li>语义信息是通过文法符号来携带和传递的。</li></ul><h2 id="属性">属性</h2><ul><li>一个<strong>文法符号X</strong>所携带的<strong>语义信息</strong>称为X的<strong>语义属性</strong>，简称为<strong>属性</strong><ul><li>文法符号的<strong>属性的计算规则</strong>称为<strong>语义规则</strong></li><li>一个变量的属性有类型、值和存储地址等</li></ul></li></ul><h1>语法制导定义</h1><h1>属性计算</h1><h1>翻译模式</h1>]]></content>
      
      
      <categories>
          
          <category> 编译原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编译原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git指令集</title>
      <link href="/post/f38ad9ef.html"/>
      <url>/post/f38ad9ef.html</url>
      
        <content type="html"><![CDATA[<img src="..\img\git\远程仓库操作.png" width="100%" height="100%" align="middle"><h1>初始化设置</h1><p>配置<strong>用户名</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name <span class="string">&quot;Your Name&quot;</span></span><br></pre></td></tr></table></figure><p>配置邮箱</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.email <span class="string">&quot;mail@example.com&quot;</span></span><br></pre></td></tr></table></figure><p><strong>存储</strong>配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global credential.helper store</span><br></pre></td></tr></table></figure><h1>创建仓库</h1><p><strong>创建</strong>一个新的本地仓库 （ 省略 <code>project-name </code> 则在当前目录创建）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init &lt;project-name&gt;</span><br></pre></td></tr></table></figure><p><strong>克隆</strong>一个远程仓库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> &lt;url&gt;</span><br></pre></td></tr></table></figure><h1>四个区域</h1><h3 id="工作区-Working-Directory">工作区(Working Directory)</h3><p>就是你在电脑里能<strong>实际看到的目录</strong>。</p><h3 id="暂存区（Stage-Index）">暂存区（<strong>Stage/Index</strong>）</h3><p>暂存区也叫索引， 用来临时存放<strong>未提交</strong>的内容， 一般在 <code>.git</code> 目录下的 <code>index</code> 中。</p><h3 id="本地仓库（-Repository）">**本地仓库（**Repository）</h3><p>Git在<strong>本地的版本库</strong>， 仓库信息存储在  <code>.git</code> 这个隐藏目录中。</p><h3 id="远程仓库（-Remote-Repository）">**远程仓库（**Remote Repository）</h3><p>托管在<strong>远程服务器</strong>上的仓库。 常用的有GitHub、 GitLab、 Gitee。</p><h2 id="对于区域和分支的问题">对于区域和分支的问题</h2><ul><li><p>当对文件做出改动时，<strong>工作区和暂存区</strong>对所有分支都是可见的；</p></li><li><p>但当在某个分支提交后，则该改动<strong>只能在该提交的分支查看</strong>到，并且 <code>ls</code> 和 <code>ls-files</code> 都只能在<strong>当前分支</strong>中看到<strong>该改动</strong>，别的分支看不到</p></li></ul><p><strong>查看</strong>当前分支当前<strong>工作区</strong>的文件列表</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span></span><br></pre></td></tr></table></figure><p><strong>查看</strong>当前分支当前<strong>暂存区</strong>文件列表</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git ls-files</span><br></pre></td></tr></table></figure><h1>文件状态</h1><h3 id="已修改（Modified）">已修改（<strong>Modified</strong>）</h3><p><strong>修改了</strong>但是<strong>没有保存</strong>到暂存区的文件。</p><h3 id="已暂存（Staged）">已暂存（<strong>Staged</strong>）</h3><p><strong>修改后</strong>已经<strong>保存到暂存区</strong>的文件。</p><h3 id="已提交（Committed）">已提交（Committed）</h3><p>把暂存区的文件<strong>提交到本地仓库</strong>后的状态。</p><h1>基本概念</h1><ul><li><strong><code>main / master</code></strong> 默认主分支</li><li><strong><code>origin</code></strong>        默认远程仓库</li><li><strong><code>HEAD</code></strong>        指向<strong>当前分支</strong>的指针</li><li><strong><code>HEAD^</code></strong>      上一个版本</li><li><strong><code>HEAD~4</code></strong>            上4个版本</li></ul><h1>特殊文件</h1><ul><li><strong><code>.git</code></strong> Git仓库的<strong>元数据</strong>和对象数据库</li><li><strong><code>.gitignore</code></strong>    <strong>忽略文件</strong>，不需要提交到仓库的文件</li><li><strong><code>.gitattributes</code></strong>   指定文件的属性，比如换行符</li><li><strong><code>.gitkeep</code></strong>    使空目录被提交到仓库</li><li><strong><code>.gitmodules</code></strong>      记录子模块的信息</li><li><strong><code>.gitconfig</code></strong>    记录仓库的配置信息</li></ul><h1>添加和提交</h1><p><strong>添加</strong>一个文件到暂存区</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add &lt;file&gt;</span><br></pre></td></tr></table></figure><p>添加所有文件到暂存区</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br></pre></td></tr></table></figure><p><strong>提交</strong>所有暂存区的文件到仓库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m <span class="string">&quot;message&quot;</span></span><br></pre></td></tr></table></figure><p>提交所有已修改的文件到仓库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -am <span class="string">&quot;message&quot;</span></span><br></pre></td></tr></table></figure><h1>分支</h1><p>查看所有<strong>本地分支</strong>，当前分支钱前面会有一个 <code>*</code> , <code>-r</code> 查看远程分支， <code>-a</code> 查看所有分支</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch</span><br></pre></td></tr></table></figure><p><strong>创建</strong>一个新分支</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch &lt;branch-name&gt;</span><br></pre></td></tr></table></figure><p><strong>删除</strong>一个已经合并的分支</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -d &lt;branch-name&gt;</span><br></pre></td></tr></table></figure><p><strong>删除</strong>一个分支，不管是否合并</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -D &lt;branch-name&gt;</span><br></pre></td></tr></table></figure><p><strong>切换</strong>到指定分支，<strong>并更新</strong>工作区</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout &lt;branch-name&gt;</span><br></pre></td></tr></table></figure><p><strong>创建</strong>一个新分支，<strong>并切换</strong>到该分支</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b &lt;branch-name&gt;</span><br></pre></td></tr></table></figure><p>给当前的提交打上标签，通常用于版本发布</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag &lt;tag-name&gt;</span><br></pre></td></tr></table></figure><h1>合并分支</h1><p>合并分支a到分支b</p><p><code>-no-ff</code> 参数表示禁用 <code>Fast forward</code> 模式，合并后的历史有分支，能看出曾经做过合并</p><p><code>-ff</code> 参数表示使用 <code>Fast forward</code> 模式，合并后的历史会变成一条直线</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge --no-ff -m <span class="string">&quot;message&quot;</span> &lt;branch-name&gt;</span><br></pre></td></tr></table></figure><img src="..\img\git\合并分支1.png" width="100%" height="100%" align="middle"><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge --ff -m <span class="string">&quot;message&quot;</span> &lt;branch-name&gt;</span><br></pre></td></tr></table></figure><img src="..\img\git\合并分支2.png" width="100%" height="100%" align="middle"><p>合并&amp;<code>squash</code>所有提交到一个提交</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge --squash &lt;branch-name&gt;</span><br></pre></td></tr></table></figure><p><code>rebase</code> 不会产生新的提交，而是把当前分支的每一个提交都&quot;复制&quot;到目标分支上，然后再把当前分支指向目标分支</p><p><code>merge</code> 会产生一个新的提交，这个提交有两个分支的所有修改</p><p><strong>Rebase</strong></p><p><code>Rebase</code> 操作可以把本地未push的分支提交历史整理成直线，看起来更直观。但是，如果多人协作时，不要对已经推送到远程的分支执行 <code>Rebase</code> 操作</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout &lt;dev&gt;</span><br><span class="line">git rebase &lt;main&gt;</span><br></pre></td></tr></table></figure><img src="..\img\git\合并分支3.png" width="100%" height="100%" align="middle"><h1>撤销</h1><p>移动一个文件到新的位置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">mv</span> &lt;file&gt; &lt;new-file&gt;</span><br></pre></td></tr></table></figure><p>从工作区和暂存区中删除一个文件，然后暂存删除操作</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">rm</span> &lt;file&gt;</span><br></pre></td></tr></table></figure><p>只从暂存区中删除一个文件，工作区中的文件没有变化</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">rm</span> --cached &lt;file&gt;</span><br></pre></td></tr></table></figure><p>恢复一个文件到之前的版本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout &lt;file&gt; &lt;commit-id&gt;</span><br></pre></td></tr></table></figure><p>提交一个新的提交，用来撤销指定的提交，后者的所有变化都将被前者抵消，并且应用到当前分支</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git revert &lt;commit-id&gt;</span><br></pre></td></tr></table></figure><p>重置当前分支的 <code>HEAD</code> 为之前的某个提交，并且删除所有之后的提交。</p><ul><li><p><code>--hard</code> 参数表示重置工作区和暂存区</p></li><li><p><code>--soft</code> 参数表示重置暂存区</p></li><li><p><code>--mixed</code> 参数表示重置工作区</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --mixed &lt;commit-id&gt;</span><br></pre></td></tr></table></figure><p>撤销暂存区的文件，重新放回工作区 （<code>git add</code> 的反向操作）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git restore --staged &lt;file&gt;</span><br></pre></td></tr></table></figure><h1>查看</h1><p>列出还未提交的新的或修改的文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure><p>查看提交历史, <code>--oneline</code>可简略查看</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> --oneline</span><br></pre></td></tr></table></figure><p>查看未暂存的文件更新了哪些部分</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff</span><br></pre></td></tr></table></figure><p>查看两个提交之间的差异</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff &lt;commit-id&gt; &lt;commit-id&gt;</span><br></pre></td></tr></table></figure><h1>Stash</h1><p><code>Stash</code> 操作可以把当前工作现场&quot;储藏&quot;起来，等以后<strong>恢复现场</strong>后继续工作。</p><p><code>-u</code> 参数表示把当前所有 <strong>未跟踪</strong> 的文件也一并存储</p><p><code>-a</code> 参数表示把所有 <strong>未跟踪</strong> 的文件和 <strong>忽略</strong> 的文件也一并存储</p><p><code>save</code> 参数表示存储的信息，可以不写</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash save <span class="string">&quot;message&quot;</span></span><br></pre></td></tr></table></figure><p>查看所有 <code>stash</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash list</span><br></pre></td></tr></table></figure><p>恢复最近一次 <code>stash</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash pop</span><br></pre></td></tr></table></figure><p>恢复指定的 <code>stash</code>, <code>stash@&#123;2&#125;</code>  表示第三个 <code>stash</code> , <code>stash@&#123;0&#125;</code> 表示最近的 <code>stash</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash pop stash@&#123;2&#125;</span><br></pre></td></tr></table></figure><p>重新接受最近一次 <code>stash</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash apply</span><br></pre></td></tr></table></figure><p><code>pop</code> 和 <code>apply</code> 的区别时，<code>pop</code> 会把 <code>stash</code> 内容删除，而 <code>apply</code> 不会。</p><p>可以用 <code>git stash drop</code> 来删除 <code>stash</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash drop stash@&#123;2&#125;</span><br></pre></td></tr></table></figure><p>删除所有 <code>stash</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash clear</span><br></pre></td></tr></table></figure><h1>远程仓库</h1><p>添加远程仓库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add &lt;remote-name&gt; &lt;remote-url&gt;</span><br></pre></td></tr></table></figure><p>查看远程仓库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote -v</span><br></pre></td></tr></table></figure><p>删除远程仓库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote <span class="built_in">rm</span> &lt;remote-name&gt;</span><br></pre></td></tr></table></figure><p>重命名远程仓库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote rename &lt;old-name&gt; &lt;new-name&gt;</span><br></pre></td></tr></table></figure><p>查看远程分支</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -r</span><br></pre></td></tr></table></figure><h2 id="拉取">拉取</h2><ul><li><p><code>git fetch</code>是将远程主机的最新内容拉到本地，用户在检查了以后决定是否合并到工作本机分支中。</p></li><li><p><code>git pull</code> 则是将远程主机的最新内容拉下来后直接合并，即：<code>git pull = git fetch + git merge</code>，这样可能会产生冲突，需要手动解决。</p></li></ul><p>从远程仓库<strong>拉取</strong>代码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull &lt;remote-name&gt; &lt;branch-name&gt;</span><br></pre></td></tr></table></figure><p><code>fetch</code> 默认远程仓库 <code>(origin)</code> 当前分支的代码，然后合并到本地分支</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull</span><br></pre></td></tr></table></figure><p>将本地改动的代码 <code>rebase</code> 到远程仓库的最新代码上（ 为了有一个干净、 线性的提交历史）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull --rebase</span><br></pre></td></tr></table></figure><p>获取所有远程分支</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch &lt;remote-name&gt;</span><br></pre></td></tr></table></figure><p><code>fetch</code> 某一个特定的远程分支</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch &lt;remote-name&gt; &lt;branch-name&gt;</span><br></pre></td></tr></table></figure><h2 id="推送">推送</h2><p><strong>推送</strong>代码到远程仓库 (然后再发起 <code>pull request</code> )</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push &lt;remote-name&gt; &lt;branch-name&gt;</span><br></pre></td></tr></table></figure><h1>GitFlow</h1><p><strong>GitFlow</strong> 是一种流程模型，用于在Git上管理软件开发项目</p><h3 id="主分支-master-main">主分支 (master/main)</h3><p>代表了项目的稳定版本，每个提交到主分支的代码都应该是经过<strong>测试和审核</strong>的。</p><h3 id="开发分支-develop">开发分支 (develop)</h3><p>用于<strong>日常开发</strong>。所有的功能分支、发布分支和修补分支都应该从开发分支派生出来。</p><h3 id="功能分支-feature">功能分支 (feature)</h3><p>用于开发<strong>单独的功能或者特性</strong>。每个功能分支都应该从开发分支派生，并在开发完成后合并回开发分支。</p><h3 id="发布分支-release">发布分支 (release)</h3><p>用于<strong>准备项目发布</strong>。发布分支应从开发分支派生，并在准备好发布版本后合并回主分支和开发分支。</p><h3 id="热修复分支-hotfix">热修复分支 (hotfix)</h3><p>用于<strong>修复</strong>主分支上的紧急问题。热修复分支应该从主分支派生，并在修复完成后，合并回主分支和开发分支。</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编译原理-自顶向下的语法分析</title>
      <link href="/post/cf412c72.html"/>
      <url>/post/cf412c72.html</url>
      
        <content type="html"><![CDATA[<h1>语法分析概述</h1><p>语法分析的主要工作是根据<strong>源语言</strong>的文法，判别某个<strong>单词序列</strong>是否是源语言的一个<strong>句子</strong></p><ul><li><strong>语言</strong>是满足一定<strong>组成规则</strong>的<strong>句子集合</strong></li><li><strong>句子</strong>是满足一定<strong>组成规则</strong>的<strong>单词序列</strong></li><li><strong>单词</strong>则是满足一定<strong>组成规则</strong>的<strong>字符串</strong></li><li>这些<strong>组成规则</strong>就是文法中的<strong>产生式</strong></li></ul><h2 id="两种方式">两种方式</h2><ul><li><strong>产生句子</strong>的方式：从文法的开始符号开始，逐步<strong>推导</strong>出这个单词序列，也称为<strong>自顶向下</strong>的语法分析<ul><li>递归子程序法</li><li>预测分析法(LL(1))</li></ul></li><li><strong>识别句子</strong>的方式：逐步将构成程序的单词序列<strong>归约</strong>为文法的<strong>开始符号</strong>，也称为<strong>自底向上</strong>的语法分析<ul><li>算符优先分析法</li><li>LR(0)、SLR(1)、LR(1)、LALR(1)</li></ul></li></ul><p>无论是自顶向下还是自底向上，语法分析器都是<strong>自左到右</strong>地扫描输入<strong>单词序列</strong>，每次读入一个单词，针对输入单词序列<strong>建立一颗语法分析树</strong><br>不同的分析方法对应着<strong>不同的构建树的方式</strong></p><h2 id="语法分析时的恢复策略">语法分析时的恢复策略</h2><ul><li><strong>紧急方式恢复策略</strong>：丢弃输入记号，直到发现某个指定的同步记号为止。同步记号通常是定界符（分号或end标记），标志着一条新语句的开始。</li><li><strong>短语级恢复策略</strong>：对剩余输入做局部纠正</li></ul><h1>自顶向下的语法分析面临的问题</h1><ul><li><strong>基本思想</strong>:<ul><li>从文法的开始符号出发，寻求所给的输入符号串的一个<strong>最左推导</strong>。</li><li>即从树根S开始，构造所给输入符号串的<strong>语法树</strong></li></ul></li><li>自顶向下分析实际上是一种<strong>试探性</strong>的过程，可能导致分析效率极低甚至失败</li><li>面临三种问题</li></ul><h2 id="二义性问题">二义性问题</h2><p>解决方法1：改造文法，引入新的文法变量<br>解决办法2：根据优先级关系，保证<strong>高优先级运算符优先</strong>的原则</p><h2 id="左递归引起的无穷推导问题">左递归引起的无穷推导问题</h2><ul><li><strong>左递归</strong>: 如果存在推导 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><msup><mo>⇒</mo><mo>+</mo></msup><mi>α</mi><mi>A</mi><mi>β</mi></mrow><annotation encoding="application/x-tex">A \Rightarrow^+ \alpha A\beta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7713em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel"><span class="mrel">⇒</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7713em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">+</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span></span></span></span>，则称文法G是递归的，当 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi><mo>=</mo><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\alpha = \epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">ϵ</span></span></span></span> 时称之为左递归；</li><li><strong>间接左递归</strong>: 如果 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><msup><mo>⇒</mo><mo>+</mo></msup><mi>α</mi><mi>A</mi><mi>β</mi></mrow><annotation encoding="application/x-tex">A \Rightarrow^+ \alpha A\beta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7713em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel"><span class="mrel">⇒</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7713em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">+</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span></span></span></span>至少需要两步推导，则称文法G是间接递归的，当 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi><mo>=</mo><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\alpha = \epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">ϵ</span></span></span></span> 时称之为间接左递归；</li><li><strong>直接左递归</strong>: 如果文法G中存在形如 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>→</mo><mi>α</mi><mi>A</mi><mi>β</mi></mrow><annotation encoding="application/x-tex">A \rightarrow \alpha A\beta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span></span></span></span>的产生式，则称文法G是直接递归的，当 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi><mo>=</mo><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\alpha = \epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">ϵ</span></span></span></span> 时称之为直接左递归。</li></ul><h2 id="回溯问题">回溯问题</h2><ul><li>文法中每个语法变量A的产生式右部称为A的<strong>候选式</strong></li><li>如果A有多个候选式存在<strong>公共前缀</strong>，则自顶向下的语法分析程序将无法根据当前输入符号准确地选择用于推导的产生式，只能试探。</li><li>当试探不成功时就需要退回到上一步推导，看A是否还有其它的候选式，这就是<strong>回溯</strong>(backtracking)。</li></ul><p>我们将采用提取左因子的方法来改造文法，以便减少推导过程中回溯现象的发生<br>当然，单纯通过提取左因子无法彻底避免回溯现象的发生。</p><h1>对上下文无关文法的改造</h1><h2 id="消除二义性">消除二义性</h2><p>改造的方法就是通过<strong>引入新的语法变量</strong>等，使文法含有更多的信息。</p><h3 id="二义性举例：">二义性举例：</h3><img src="..\..\img\CompilerPrinciples\二义性文法举例.png" width="100%" height="100%" align="middle"><p><strong>分析：</strong><br>根据if语句中else与then配对情况将其分为<strong>配对的语句</strong>和<strong>不配对的语句</strong>两类。<br>上述if语句的文法没有对这两个不同的概念加以区分，只是简单地将它们都定义为&lt;stmt&gt;，从而导致该文法是二义性的<br><strong>解决：</strong><br><img src="..\..\img\CompilerPrinciples\二义性文法举例解决.png" width="100%" height="100%" align="middle"></p><h2 id="消除左递归">消除左递归</h2><h3 id="消除直接左递归">消除直接左递归</h3><ul><li>直接左递归的消除(转换为右递归)</li><li>引入新的变量<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>A</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">A&#x27;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7519em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span> ，将左递归产生式<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>→</mo><mi>A</mi><mi>α</mi><mi mathvariant="normal">∣</mi><mi>β</mi></mrow><annotation encoding="application/x-tex">A\rightarrow A\alpha | \beta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span></span></span></span> 替换为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>→</mo><mi>β</mi><msup><mi>A</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">A\rightarrow \beta A&#x27;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.9463em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>A</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo>→</mo><mi>α</mi><msup><mi>A</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mi mathvariant="normal">∣</mi><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">A&#x27; \rightarrow \alpha A&#x27; | \epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7519em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0019em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mord">∣</span><span class="mord mathnormal">ϵ</span></span></span></span><br><img src="..\..\img\CompilerPrinciples\消除左递归1.png" width="100%" height="100%" align="middle"></li></ul><h3 id="具体做法">具体做法</h3><img src="..\..\img\CompilerPrinciples\消除左递归2.png" width="100%" height="100%" align="middle"><ul><li>上述方法<strong>只能消除直接</strong>左递归，<strong>无法消除间接</strong>左递归</li><li>消除<strong>间接左递归</strong>的<strong>基本思想</strong>：为语法<strong>变量编号</strong>，再采用<strong>带入法</strong>将<strong>间接左递归变为直接左递归</strong>，然后采用上述方法来消除直接左递归</li></ul><h3 id="消除所有左递归">消除所有左递归</h3><img src="..\..\img\CompilerPrinciples\消除左递归算法.png" width="100%" height="100%" align="middle"><img src="..\..\img\CompilerPrinciples\消除左递归算法例子.png" width="100%" height="100%" align="middle"><h2 id="提取左因子（解决回溯问题）">提取左因子（解决回溯问题）</h2><p><strong>方法：</strong><br><img src="..\..\img\CompilerPrinciples\提取左因子.png" width="100%" height="100%" align="middle"><br>提取左因子并不能完全消除回溯</p><p><strong>例子：</strong><br><img src="..\..\img\CompilerPrinciples\提取左因子例子.png" width="100%" height="100%" align="middle"></p><h1>LL(1)文法</h1><ul><li><strong>不确定</strong>的自顶向下分析<ul><li>分析需要回溯，导致分析存在不确定性</li><li>代价高、效率低，实际中几乎不被采用</li></ul></li><li><strong>确定</strong>的自顶向下分析<ul><li>不能处理所有文法，这里讨论什么样的文法可以进行确定的自顶向下分析</li></ul></li><li>LL(1)文法就是可以<strong>彻底消除回溯</strong>实现<strong>确定的</strong>自顶向下分析的文法</li><li>文法要求：<ul><li>无二义性</li><li>无左递归</li><li>任意一个语法变量A的各个候选式所能推导出的<strong>第一个终结符</strong>必须各不相同</li></ul></li></ul><h2 id="符号串的首字符集FIRST-a">符号串的首字符集FIRST(a)</h2><h3 id="FIRST集的定义">FIRST集的定义</h3><img src="..\..\img\CompilerPrinciples\符号串的首字符集FIRST(a).png" width="100%" height="100%" align="middle"><h3 id="FIRST集的生成算法">FIRST集的生成算法</h3><ul><li><p><strong>单个符号</strong>的FIRST集的生成算法<br><img src="..\..\img\CompilerPrinciples\单个符号的FIRST集的生成算法.png" width="100%" height="100%" align="middle"></p></li><li><p><strong>符号串</strong>的FIRST集的生成算法<br><img src="..\..\img\CompilerPrinciples\符号串的FIRST集的生成算法.png" width="100%" height="100%" align="middle"></p></li></ul><h3 id="FIRST集举例">FIRST集举例</h3><img src="..\..\img\CompilerPrinciples\FIRST集举例.png" width="100%" height="100%" align="middle"><h2 id="非终结符的FOLLOW集">非终结符的FOLLOW集</h2><p>对于\epsion的考虑，以及提出FOLLOW集的原因<br><img src="..\..\img\CompilerPrinciples\符号串的首字符集FIRST2.png" width="100%" height="100%" align="middle"></p><h3 id="FOLLOW集的定义">FOLLOW集的定义</h3><img src="..\..\img\CompilerPrinciples\非终结符的FOLLOW集.png" width="100%" height="100%" align="middle"><h3 id="FOLLOW集的生成算法">FOLLOW集的生成算法</h3><img src="..\..\img\CompilerPrinciples\FOLLOW集的生成算法.png" width="100%" height="100%" align="middle"><h3 id="FOLLOW集举例">FOLLOW集举例</h3><img src="..\..\img\CompilerPrinciples\FOLLOW集举例.png" width="100%" height="100%" align="middle"><h2 id="LL-1-文法的定义">LL(1)文法的定义</h2><img src="..\..\img\CompilerPrinciples\LL(1)文法的定义.png" width="100%" height="100%" align="middle"><h3 id="LL-1-文法举例">LL(1)文法举例</h3><img src="..\..\img\CompilerPrinciples\LL(1)文法举例.png" width="100%" height="100%" align="middle"><h1>预测分析法</h1><ul><li>一种高效的自顶向下分析法</li><li>能够对LL(1)文法实现确定的自顶向下分析</li></ul><h2 id="方法综述">方法综述</h2><p>采用表驱动方式实现控制算法</p><ul><li><strong>分析表M[A,a]</strong>，即<strong>LL(1)分析表</strong>，存储执行LL(1)分析的信息，其中<strong>A是语法变量</strong>，<strong>a是输入符号</strong>。</li><li><strong>分析栈</strong>，存放文法符号序列，<strong>#为栈底符号</strong>，<strong>初始时栈顶是开始符号</strong></li><li><strong>输入缓冲区</strong>，包括待分析的<strong>串</strong>和<strong>结束符</strong><br>系统维持一个<strong>分析表</strong>和一个<strong>分析栈</strong>，根据当前<strong>输入缓冲区</strong>中扫描到的符号，选择当前语法变量（<strong>处于栈顶</strong>）的<strong>候选式</strong>进行推导——希望找到相应输入符号串的<strong>最左推导</strong>。</li></ul><img src="..\..\img\CompilerPrinciples\预测分析器的构成.png" width="100%" height="100%" align="middle"><h2 id="预测分析表的构造算法">预测分析表的构造算法</h2><img src="..\..\img\CompilerPrinciples\预测分析表的构造算法.png" width="100%" height="100%" align="middle"><h2 id="预测分析法过程">预测分析法过程</h2><h3 id="实现步骤">实现步骤</h3><ol><li><strong>构造文法</strong></li><li><strong>改造文法</strong>：消除二义性、消除左递归、提取左因子</li><li><strong>求</strong>每个候选式的<strong>FIRST集</strong>和变量的<strong>FOLLOW集</strong></li><li><strong>检查</strong>是不是LL(1)文法<br>若不是 LL(1),说明文法的复杂性超过自顶向下方法的分析能力，需要附加新的“信息”</li><li><strong>构造</strong>预测分析<strong>表</strong></li><li><strong>实现</strong>预测<strong>分析器</strong></li></ol><h3 id="预测分析控制过程">预测分析控制过程</h3><ul><li>在系统启动时，输入指针指向输入串的第一个字符，分析栈中存放着栈底符号#和文法的开始符号</li><li>根据栈顶符号A和读入的符号a，查看分析表M,以决定相应的动作。<ul><li>如果 <strong>A=a=#</strong>，分析成功并停机</li><li>如果 <strong>A=a≠#</strong>，弹出栈顶符号A，并将输入指针指向下一个符号</li><li>如果<strong>A是语法变量</strong>，程序访问分析表M的**M[A,a]**表项，该表项或者是一个A产生式，或者是出错信息。</li><li>如果<strong>M[A,a]={A→UVW}</strong>，则用WVU(栈顶)替换原栈顶符号A，<strong>输出该产生式</strong></li></ul></li></ul><h3 id="算法实现">算法实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">算法<span class="number">4.5</span> 预测分析程序的总控程序</span><br><span class="line">输入：输入串w和文法G=(V, T, P, S)的分析表M;</span><br><span class="line">输出：如果w属于<span class="built_in">L</span>(G)，则输出w的最左推导，否则报错;</span><br><span class="line">步骤：</span><br><span class="line">将栈底符号#和文法开始符号S压入栈中;</span><br><span class="line">repeat</span><br><span class="line">    X:=当前栈顶符号; a:=当前输入符号;</span><br><span class="line">    <span class="keyword">if</span> X∈T∪&#123;#&#125; then</span><br><span class="line">        <span class="keyword">if</span> X=a then</span><br><span class="line">            <span class="keyword">if</span> X≠<span class="meta"># then</span></span><br><span class="line">                将X弹出栈;</span><br><span class="line">                前移输入指针; </span><br><span class="line">        <span class="keyword">else</span> <span class="comment">//当前栈顶终结符和当前输入符号不一致</span></span><br><span class="line">            error</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">//也就是X属于一个语法变量</span></span><br><span class="line">        <span class="keyword">if</span> M[X, a] = Y1Y2…Yk then </span><br><span class="line">            将X弹出栈;</span><br><span class="line">            依次将 Yk，…，Y2，Y1 压入栈;</span><br><span class="line">            输出产生式 X → Y1Y2…Yk;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            error</span><br><span class="line">until X=#</span><br></pre></td></tr></table></figure><h3 id="预测分析法举例">预测分析法举例</h3><ul><li><p>文法、FIRST集和FOLLOW集<br><img src="..\..\img\CompilerPrinciples\预测分析法举例1.png" width="100%" height="100%" align="middle"></p></li><li><p>实现的预测分析表<br><img src="..\..\img\CompilerPrinciples\预测分析法举例2.png" width="100%" height="100%" align="middle"></p></li><li><p>对输入串 <strong>id+id*id</strong> 进行分析的过程<br><img src="..\..\img\CompilerPrinciples\预测分析法举例3.png" width="100%" height="100%" align="middle"></p></li></ul><p>输出的产生式序列形成了<strong>最左推导对应的分析树</strong></p><h2 id="预测分析中错误的处理">预测分析中错误的处理</h2><h3 id="错误类型">错误类型</h3><pre><code>- 栈顶终结符号和下一个输入符号不匹配- 栈顶是语法变量A，a是下一个输入符号，M[A, a]是空白表项</code></pre><h3 id="紧急方式错误恢复策略">紧急方式错误恢复策略</h3><p>发现错误时跳过一些输入符号，直到下一个语法成分包含的第一个符号为止 <strong>（同步记号）</strong></p><p><strong>同步记号的一般选择策略</strong>：对语法变量A，如果M[A,a]无定义，并且a属于FOLLOW(A)，则增加M[A,a]为 <strong>“同步点”</strong>(<strong>synch</strong>)。当程序到达这个同步点时，放弃对A的识别，而转入分析A后面的符号。</p><h3 id="错误的处理步骤：">错误的处理步骤：</h3><ul><li>对预测分析表添加<strong>同步点</strong></li><li>预测分析执行过程中加入以下判断<ul><li>如果表项M[A, a]为<strong>空</strong>，则<strong>跳过输入符号</strong>a；</li><li>如果表项M[A, a]是<strong>synch</strong>，则<strong>弹出栈顶</strong>的语法变量并试图恢复分析；</li><li>如果栈顶的记号与输入符号<strong>不匹配</strong>，则从<strong>栈顶弹出</strong>该记号。</li></ul></li></ul><h3 id="错误的处理举例">错误的处理举例</h3><p>对预测分析表添加<strong>同步点</strong><br><img src="..\..\img\CompilerPrinciples\错误的处理举例.png" width="100%" height="100%" align="middle"></p><p>处理过程<br><img src="..\..\img\CompilerPrinciples\错误的处理举例.png" width="100%" height="100%" align="middle"></p><h1>递归下降分析法</h1><p>所谓递归下降分析法，是指根据各个候选式的结构，为<strong>文法的每个 语法变量 编写一个处理程序</strong>，用来识别该语法变量所代表的语法成分</p>]]></content>
      
      
      <categories>
          
          <category> 编译原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编译原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件工程</title>
      <link href="/post/7821ac43.html"/>
      <url>/post/7821ac43.html</url>
      
        <content type="html"><![CDATA[<h1>软件生命周期</h1><p><strong>核心内容：软件生命周期的各过程</strong><br><img src="../img/Software/软件生命周期.png" width="100%" height="100%" align="middle"></p><h1>软件工程学概述</h1><h2 id="概念定义">概念定义</h2><ul><li>软件工程是指导计算机软件开发和维护的一门工程学科。</li><li>采用<strong>工程</strong>的概念、原理、技术和方法来开发与维护软件。把正确的<strong>管理技术</strong>和当前能够得到的最好的<strong>技术方法</strong>结合起来，以经济地开发出高质量的软件并<strong>有效地维护</strong>它，这就是软件工程。</li></ul><h2 id="本质特性">本质特性</h2><ul><li>软件工程关注于大型程序的构造</li><li>软件工程的中心课题是控制复杂性</li><li>软件经常变化</li><li>开发软件的效率非常重要</li><li>和谐地合作是开发软件的关键</li><li>必须有效地支持它的用户</li><li>两种背景的人创造产品这个特性与前两个特性紧密相关</li></ul><h2 id="基本原理">基本原理</h2><ul><li>用分阶段的生命周期计划严格管理</li><li>坚持进行阶段评审</li><li>实行严格的产品控制</li><li>采用现代程序设计技术</li><li>结果应能清楚地审查</li><li>开发小组的人员应该少而精</li><li>承认不断改进软件工程实践的必要性</li></ul><h2 id="三要素">三要素</h2><ul><li><strong>方法</strong>：完成软件开发的各项任务的技术方法，回答“怎样做”的问题</li><li><strong>工具</strong>：为运用方法而提供的自动的或半自动的软件工程支撑环境</li><li><strong>过程</strong>：为了获得高质量的软件所需要完成的一系列任务的框架，它规定了完成各项任务的工作步骤</li></ul><h2 id="方法学">方法学</h2><h3 id="传统方法学">传统方法学</h3><ul><li>也称为生命周期方法学或结构化范型。</li><li>软件生命周期的全过程依次划分为若干个阶段，然后顺序地完成每个阶段的任务。</li><li>每个阶段的开始和结束都有严格标准，对于任何两个相邻的阶段而言，前一阶段的结束标准就是后一阶段的开始标准。</li></ul><h3 id="面向对象方法">面向对象方法</h3><p>面向对象方法把数据和行为看成是同等重要的，它是一种以数据为主线，把数据和对数据的操作紧密地结合起来的方法</p><h4 id="四个要点">四个要点</h4><ul><li>把对象(object)作为融合了数据及在数据上的操作行为的统一的软件构件。</li><li>把所有对象都划分成类(class)。</li><li>按照父类与子类的关系，把若干个相关类组成一个层次结构的系统。</li><li>对象彼此间仅能通过发送消息互相联系</li></ul><h4 id="基本原则">基本原则</h4><ul><li>尽量模拟人类习惯的思维方式</li><li>从而使描述问题的<strong>问题空间</strong>(也称为问题域)与实现解法的<strong>解空间</strong>(也称为求解域)在<strong>结构上尽可能一致</strong>。</li></ul><h4 id="优点">优点</h4><ul><li><strong>降低</strong>了软件产品的<strong>复杂性</strong>，<strong>提高</strong>了软件的<strong>可理解性</strong>，<strong>简化</strong>了软件<strong>开发和维护工作</strong></li><li>面向对象方法特有的继承性和多态性，进一步提高了面向对象软件的<strong>可重用性</strong>。</li></ul><h2 id="软件过程">软件过程</h2><ul><li>软件过程是为了获得高质量软件所需要完成的一系列任务的框架，它规定了完成各项任务的<strong>工作步骤</strong>。</li><li>软件过程描述为了开发出客户需要的软件，什么人（who）、在什么时候（when）、做什么事（what）以及怎样（how）做这些事以实现某一个特定的具体目标。</li></ul><h3 id="瀑布模型">瀑布模型</h3><img src="../img/Software/瀑布模型.png" width="70%" height="70%" align="middle"><h4 id="特点">特点</h4><ul><li>阶段间具有顺序性和依赖性</li><li>推迟实现的观点</li><li>质量保证的观点</li></ul><h4 id="带反馈的瀑布模型">带反馈的瀑布模型</h4><img src="../img/Software/带反馈的瀑布模型.png" width="70%" height="70%" align="middle"><p><strong>实线箭头表示开发过程，虚线箭头表示维护过程</strong></p><ul><li>当在后面阶段发现前面阶段的错误时，需要沿图中左侧的<strong>反馈线返回</strong>前面的阶段，修正前面阶段的产品之后再回来继续完成后面阶段的任务。</li></ul><h3 id="快速原型模型">快速原型模型</h3><img src="../img/Software/快速原型模型.png" width="70%" height="70%" align="middle"><p>快速原型是快速建立起来的，可以在计算机上运行的程序，它所能完成的功能往往是最终产品能完成的功能的一个<strong>子集</strong>。</p><h4 id="相邻阶段无反馈的原因">相邻阶段无反馈的原因</h4><ul><li>原型系统<strong>已经通过与用户交互而得到验证</strong>，据此产生的<strong>规格说明文档</strong>正确地描述了用户需求，因此，在开发过程的后续阶段不会因为发现了规格说明文档的错误而进行较大的返工。</li></ul><h3 id="增量模型">增量模型</h3><img src="../img/Software/增量模型.png" width="70%" height="70%" align="middle"><ul><li>增量模型也称为渐增模型。核心思想是把软件产品作为一系列的<strong>增量构件</strong>来设计、编码、集成和测试。</li><li>第一个增量构件往往实现软件的基本需求，提供最核心的功能</li></ul><h4 id="优点-2">优点</h4><ul><li>能在较短时间内向用户提交可完成部分工作的产品</li><li>逐步增加产品功能可以使用户有较充裕的时间学习和适应新产品，从而减少一个全新的软件可能给客户组织带来的冲击。</li></ul><h3 id="螺旋模型">螺旋模型</h3><img src="../img/Software/螺旋模型.png" width="70%" height="70%" align="middle"><ul><li>在每个阶段之前都<strong>增加了风险分析过程</strong>的快速原型模型。</li></ul><h3 id="喷泉模型">喷泉模型</h3><img src="../img/Software/喷泉模型.png" width="70%" height="70%" align="middle"><ul><li>典型的<strong>面向对象</strong>的软件过程模型</li><li>图中在一个阶段内的向下箭头代表该<strong>阶段内的迭代</strong></li><li>图中较小的圆圈代表维护，圆圈较小象征着采用了面向对象范型之后维护时间缩短了。</li></ul><h3 id="Rational统一过程">Rational统一过程</h3><ul><li>Rational Unified Process 简称 <strong>RUP</strong></li><li>RUP总结了经过多年商业化验证的6条最有效的软件开发经验，这些经验被称为“最佳实践”<ul><li>迭代式开发</li><li>管理需求</li><li>使用基于构件的体系结构</li><li>可视化建模</li><li>验证软件质量</li><li>控制软件变更</li></ul></li></ul><h4 id="软件生命周期">软件生命周期</h4><ul><li><strong>初始阶段</strong>： 建立业务模型，定义最终产品视图，并且确定项目的范围。</li><li><strong>精化阶段</strong>： 设计并确定系统的体系结构，制定项目计划，确定资源需求。</li><li><strong>构建阶段</strong>： 开发出所有构件和应用程序，把它们集成为客户需要的产品，并且详尽地测试所有功能。</li><li><strong>移交阶段</strong>： 把开发出的产品提交给用户使用</li></ul><h4 id="RUP中的迭代">RUP中的迭代</h4><p>每次迭代都是一个小的瀑布模型</p><h3 id="敏捷过程-Agile">敏捷过程 Agile</h3><ul><li>最早是为了与传统的瀑布软件开发模式相比较，所以当时的方法叫做轻量级方法（Light weight methods）</li></ul><h4 id="敏捷过程核心思想">敏捷过程核心思想</h4><img src="../img/Software/敏捷过程核心思想.png" width="70%" height="70%" align="middle"><h4 id="四条价值观">四条价值观</h4><ul><li>人员交流重于过程与工具</li><li>软件产品重于长篇大论</li><li>客户协作重于合同谈判</li><li>随机应变重于循规蹈矩</li></ul><h4 id="敏捷更符合软件开发规律">敏捷更符合软件开发规律</h4><ul><li>软件更像一个活着的植物，软件开发是自底向上逐步有序的生长过程，类似于植物自然生长</li><li>敏捷开发遵循软件客观规律，不断的进行迭代增量开发，最终交付符合客户价值的产品</li></ul><h4 id="价值驱动-敏捷与传统瀑布型模式的最大区别">价值驱动 - 敏捷与传统瀑布型模式的最大区别</h4><ul><li><p>敏捷基于这种方式，可以实现研发过程的持续高可视性、高可适应性，更早且持续产出业务价值，更早发现和解决风险。</p></li><li><p>瀑布模型 基于 <strong>计划驱动</strong></p></li></ul><h3 id="敏捷常用的工程方法">敏捷常用的工程方法</h3><h4 id="极限编程">极限编程</h4><img src="../img/Software/极限编程.png" width="70%" height="70%" align="middle"><h4 id="整体开发过程">整体开发过程</h4><img src="../img/Software/整体开发过程.png" width="70%" height="70%" align="middle"><h4 id="Scrum模型">Scrum模型</h4><ul><li><p>三大特点</p><ul><li>“可能性的”艺术 – <strong>关注当下</strong></li><li>团队自组织，自管理 – <strong>放权</strong></li><li>面对面沟通 – <strong>提高沟通</strong></li></ul></li><li><p>三种角色</p><ul><li>产品负责人 PO<ul><li>负责管理**产品待办事项表（Product Backlog）**并保证其对于客户和团队保持透明度；</li></ul></li><li>团队负责人 SM<ul><li>不要管理团队。</li></ul></li><li>开发团队 5-9 人</li></ul></li><li><p>三种工件</p><ul><li>产品待办事项表(产品Backlog)</li><li>冲刺待办事项表(Sprint Backlog)<ul><li>包含产品待办事项列表中当前 Sprint 的子集</li></ul></li><li>产品增量</li></ul></li><li><p>步骤</p><ul><li>Step1 头脑风暴</li><li>Step2 PO决定实现的功能</li><li>Step3 时间估计: 用扑克牌游戏进行时间估计</li><li>Step4 冲刺</li><li>Step5 评估 PO</li></ul></li></ul><h4 id="微软开发过程">微软开发过程</h4><ul><li>每一个生命周期发布一个递进的软件版本，各个生命周期持续、快速地迭代循环</li></ul><h1>可行性分析</h1><p>描绘<strong>物理系统</strong> -&gt; <strong>系统流程图</strong><br>描绘<strong>逻辑模型</strong> -&gt; <strong>数据流图</strong> / <strong>数据字典</strong><br><strong>主要内容</strong><br><img src="../img/Software/可行性分析主要内容.png" width="100%" height="100%" align="middle"></p><h2 id="可行性研究的任务">可行性研究的任务</h2><h3 id="含义">含义</h3><ul><li>用最小的代价，在尽可能短的时间内（一般占总工作量的5％到10％）确定<strong>能否解决问题</strong>，以及<strong>是否值得解决</strong>的问题 。</li><li>因此，可行性研究的目的是“<strong>做还是不做</strong>”，而非“如何去做”。</li></ul><h3 id="内容">内容</h3><h4 id="从技术可行性">从技术可行性</h4><ul><li>开发风险</li><li>资源有效性</li><li>技术方案<br>表述为：<strong>做得了吗？做得好吗？做得快吗？</strong></li></ul><h4 id="经济可行性">经济可行性</h4><ul><li>度量系统解决方案的性能价格比</li></ul><h4 id="用户操作可行性">用户操作可行性</h4><ul><li>用户组织的结构、工作流程、管理模式及规范是否适合目标系统的运行，是否互不相容。</li><li>现有的人员素质能否胜任对目标系统的操作？</li><li>如果进行培训，时间是多少？成本如何？</li></ul><h4 id="社会环境可行性">社会环境可行性</h4><ul><li>市场</li><li>政策</li><li>法律</li></ul><h2 id="可行性研究过程">可行性研究过程</h2><ol><li>确定项目规模和目标；</li><li>研究当前正在运行的系统；</li><li>建立新系统的高层逻辑模型；</li><li>导出和评价各种方案；</li><li>推荐可行的方案；</li><li>草拟开发计划；</li><li>编写可行性研究报告，提交审查</li></ol><h2 id="系统流程图">系统流程图</h2><h3 id="基本符号">基本符号</h3><img src="../img/Software/系统流程图基本符号.png" width="100%" height="100%" align="middle"><h3 id="例子">例子</h3><h4 id="系统目标">系统目标</h4><ol><li>管理仓库各类零件数量的变化，并及时修改（更新库存清单文件）。</li><li>报告库存零件达到库存量临界值的订货报告，产生订货信息。</li><li>生成订货报表。</li></ol><h4 id="构成部件">构成部件</h4><ol><li>输入终端CRT</li><li>事务处理部件（库存清单程序）</li><li>磁盘（存放库存清单主文件）</li><li>磁带（存放订货信息）</li><li>报告生成部件（报告生成程序）</li><li>打印的文档（订货报告）</li></ol><h4 id="绘制方法">绘制方法</h4><img src="../img/Software/系统流程图示例.png" width="100%" height="100%" align="middle"><h2 id="数据流图">数据流图</h2><p>以图形方式来表达系统的逻辑功能、数据在系统内部的逻辑流向和逻辑变换过程</p><h3 id="基本符号-2">基本符号</h3><img src="../img/Software/数据流图基本符号.png" width="100%" height="100%" align="middle"><h3 id="附加符号">附加符号</h3><p>*****表示数据流之间“与”的关系（同时存在）<br><strong>+</strong> 表示数据流之间“或”的关系<br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⊕</mo></mrow><annotation encoding="application/x-tex">\oplus</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord">⊕</span></span></span></span> 表示数据流之间 “异或”的关系（不能同时存在）<br><img src="../img/Software/数据流图附加符号.png" width="100%" height="100%" align="middle"></p><h3 id="画数据流图的步骤">画数据流图的步骤</h3><ul><li>Step1：画顶层数据流图,包括数据源点、终点，整个软件系统作为一个数据处理，流入和流出系统的数据流。</li><li>Step2：一级细化，即画分层数据流图，逐层分解数据处理，得到功能级数据流图</li><li>Step3：二级细化，进一步分解功能级数据流图到涉及功能具体的实现为止</li></ul><h3 id="数据流图的示例">数据流图的示例</h3><h4 id="问题描述">问题描述</h4><ul><li>工厂采购部每天需要一张订货报表，报表按零件编号编排，表中列出所有需要再次订货的零件（包括零件编号，零件名称，定货数量，当前价格，目前主要供应者，次要供应者）。</li><li>零件入库或出库称为<strong>事务</strong>，通过放在仓库中的CRT终端把事务报告给定货系统。</li><li>当某种零件的库存量少于库存临界值时就应该再次订货。</li></ul><h4 id="问题分析">问题分析</h4><ul><li><strong>源点/终点</strong>：仓库管理员/采购员</li><li><strong>处理</strong>：处理事务、产生订货报表</li><li><strong>数据存储</strong>：订货信息、库存清单</li><li><strong>数据流</strong>：订货报表、事务</li></ul><h4 id="步骤">步骤</h4><ul><li><p>Step1：绘制基本系统模型<br><img src="../img/Software/数据流图的示例Step1.png" width="100%" height="100%" align="middle"></p></li><li><p>Step2：得到功能级数据流图<br><img src="../img/Software/数据流图的示例Step2.png" width="100%" height="100%" align="middle"></p></li><li><p>Step3：细化到功能实现级别<br><img src="../img/Software/数据流图的示例Step3.png" width="100%" height="100%" align="middle"></p></li></ul><h3 id="注意事项">注意事项</h3><ol><li><p>若一张数据流图中包含的数据处理多于7时，其含义将难以领会，此时数据流图应该分层绘制<br><img src="../img/Software/数据流图注意事项.png" width="100%" height="100%" align="middle"></p></li><li><p>数据流图分层细化时必须保持信息的连续性，即细化前后对应功能的输入输出数据必须相同。<br><img src="../img/Software/数据流图注意事项1.png" width="100%" height="100%" align="middle"></p></li><li><p>数据存储和数据流都是数据，仅所处的状态不同，数据存储是静止状态的数据，数据流是运动状态的数据。</p></li><li><p>所有的数据流都必须以一个数据处理开始，或以一个数据处理结束。即，<strong>每个数据处理都应该有输入输出</strong>。</p></li></ol><h3 id="各成分命名要求">各成分命名要求</h3><h4 id="数据流-或数据存储">数据流(或数据存储)</h4><ul><li>代表整个数据流(或数据存储)的内容</li><li>不要使用缺乏具体含义的名字；</li><li>除流入流出<strong>数据存储</strong>的数据流可以命名相同之外，其他的数据流命名需要唯一，即便是同样内容</li></ul><h4 id="数据处理-或数据加工">数据处理(或数据加工)</h4><ul><li>先为数据流命名，再为处理命名，通常1个动词+宾语的命名方式</li><li>如果必须用两个动词才能描述整个处理的功能，则把这个处理再分解成两个处理可能更恰当些。</li><li>若处理的命名比较困难可能是处理包含太多功能</li></ul><h3 id="注意事项及命名练习">注意事项及命名练习</h3><p>阅读下图所示的数据流图，找出其中错误之处<br><img src="../img/Software/注意事项及命名练习.png" width="100%" height="100%" align="middle"></p><img src="../img/Software/注意事项及命名练习答案.png" width="100%" height="100%" align="middle"><h2 id="数据字典">数据字典</h2><h3 id="数据字典的任务">数据字典的任务</h3><ul><li>对于数据流图中出现的所有被命名的图形元素在字典中作为一个词条加以定义，<strong>使得每一个图形元素的名字都有一个确切的解释</strong></li></ul><h3 id="数据字典的定义">数据字典的定义</h3><ul><li>定义：是关于数据的信息集合，即对数据流图中包含的所有元素定义的集合。</li><li>数据字典和数据流图共同构成系统的逻辑模型，有数据字典，数据流图就不严格；没有数据流图，数据字典难于发挥作用。</li></ul><h3 id="定义内容">定义内容</h3><ul><li><strong>数据流</strong>：来源、去向、组成、流通量</li><li><strong>数据元素</strong>：名称、别名、取值范围、含义、数据长度、小数位数、简单描述</li><li><strong>数据存储</strong>：数据结构及数据存放规则</li><li><strong>数据处理</strong>：数据处理的逻辑功能和主要算法</li></ul><h3 id="数据字典举例">数据字典举例</h3><h4 id="数据流定义">数据流定义</h4><p><strong>对数据流和数据存储来说，需要定义到数据元素为止</strong><br><img src="../img/Software/数据字典示例.png" width="100%" height="100%" align="middle"></p><h4 id="数据项定义">数据项定义</h4><p>由数据元素组成数据的方式</p><ul><li>顺序：以确定次序连接两个或多个分量</li><li>选择：从两个或多个可能元素中选取一个</li><li>重复：把指定的分量重复零次或多次。</li><li>可选：一个分量是可有可无的</li></ul><img src="../img/Software/数据字典中的符号表示.png" width="100%" height="100%" align="middle"><h4 id="数据项的定义练习">数据项的定义练习</h4><ul><li>某酒店所提供的电话服务系统的功能为：</li><li>客人可以通过拨分机号联络酒店内的其他房间，也可拨外线号码与酒店外联络。</li><li>分机号从8201至8299。</li><li>外线号码需先拨0，然后加拨市话号码或长途电话号码</li><li>长途电话号码由区号和市话号码组成，其中区号可以为010、021~029、0300~0999中的任意一个数字串</li><li>市话号码是任意7位或8位长度的数字串。<br><img src="../img/Software/数据项的定义练习答案.png" width="100%" height="100%" align="middle"></li></ul><h4 id="加工定义">加工定义</h4><p>数据处理的定义可以采用结构化语言、IPO图、伪代码PDL、判定树、判定表等方式描述</p><h2 id="成本-效益分析">成本/效益分析</h2><p>从经济角度分析新系统的开发是否能盈利，帮助使用部门正确做出是否投资的决定。</p><h3 id="常用的成本估算技术">常用的成本估算技术</h3><ul><li><p>代码行技术</p><ul><li><strong>成本＝总代码行数×每行的平均成本</strong></li><li>根据经验和历史数据，确定上面两个变量。此外，工资水平也是应考虑的一个重要因素。</li></ul></li><li><p>任务分解技术</p><ul><li>根据生命周期瀑布模型，对开发工作将进行任务分解，分别估算每个任务的成本，累加得到总成本</li><li><strong>成本＝所需的总人月数×每人月的成本</strong></li></ul></li><li><p>自动估计成本技术</p><ul><li>利用自动估计成本技术的软件工具进行计算</li></ul></li><li><p>经验统计估计模型</p><ul><li>Walston-Felix（IBM）模型</li><li>Putnam 估算模型（动态多变量参数模型）</li><li>COCOMO 模型</li></ul></li></ul><h3 id="常用的效益度量方法">常用的效益度量方法</h3><ol><li>货币的时间价值</li><li>投资回收期</li><li>纯收入</li><li>投资回收率</li></ol><h3 id="成本-效益分析步骤">成本/效益分析步骤</h3><ul><li>估计开发成本、运行费用和新系统带来的经济效益</li><li>比较新系统的开发成本和经济效益。</li></ul><h3 id="可行性研究报告">可行性研究报告</h3><ul><li>根据DFD+DD、成本/效益分析等方面，进行技术可行性、经济可行性、用户操作可行性、社会环境可行性等方面评价，完成可行性研究报告，并提交审查</li><li>在审查过程中出现问题需要更改，通过多次迭代完成最终可行性报告，从而实现“是否做”的判断</li></ul><h1>需求分析</h1><img src="../img/Software/需求分析逻辑关系.png" width="100%" height="100%" align="middle"><h2 id="需求分析概述">需求分析概述</h2><h3 id="需求的层次">需求的层次</h3><img src="../img/Software/需求的层次.png" width="100%" height="100%" align="middle"><h3 id="需求分析方法需遵守的法则">需求分析方法需遵守的法则</h3><ul><li>必须理解并<strong>描述问题的信息域</strong>，根据这条准则应该建立<strong>数据模型</strong>。</li><li>必须<strong>定义</strong>软件应完成的<strong>功能</strong>，这条准则要求建立<strong>功能模型</strong>。</li><li>必须描述作为外部事件结果的<strong>软件行为</strong>，这条准则要求建立<strong>行为模型</strong></li><li>必须对<strong>描述信息、功能和行为的模型</strong>进行分解，用<strong>层次</strong>的方式展示细节。</li></ul><h2 id="与用户沟获取需求的方法">与用户沟获取需求的方法</h2><h3 id="需求收集过程">需求收集过程</h3><ul><li>访谈<ul><li>**用户（user）**是一种泛称，它可细分为 <strong>客户（customer）</strong>、**最终用户（the end user）**和 <strong>间接用户（或称为关系人）</strong>。<br>掏钱买产品的用户称为客户，而真正操作产品的用户叫最终用户。客户与最终用户可能是同一个人也可能不是同一个人。</li></ul></li><li>面向数据流自顶向下求精</li><li>简易的应用规格说明技术</li><li>快速建立软件原型</li></ul><h2 id="分析建模与规格说明">分析建模与规格说明</h2><h3 id="需求分析应建立的模型">需求分析应建立的模型</h3><ul><li><strong>数据模型</strong>：E-R图(ERD)，描述数据对象，数据对象之间的关系；</li><li><strong>功能模型</strong>：数据流图(DFD)，描述数据在系统中流动，变换的逻辑过程；</li><li><strong>行为模型</strong>：状态转换图(STD)，描绘了系统的各种行为模式和在不同状态之间转换的方式；</li><li><strong>模型中心</strong>：数据字典 (DD)。</li></ul><h3 id="撰写软件需求规格说明书">撰写软件需求规格说明书</h3><h2 id="功能模型构建">功能模型构建</h2><h2 id="数据模型构建">数据模型构建</h2><h2 id="行为模型构建">行为模型构建</h2><h2 id="需求实现验证">需求实现验证</h2>]]></content>
      
      
      <categories>
          
          <category> 软件工程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件工程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编译原理-词法分析</title>
      <link href="/post/8254dc99.html"/>
      <url>/post/8254dc99.html</url>
      
        <content type="html"><![CDATA[<h1>词法分析器的功能</h1><ul><li>功能：输入源程序，输出单词符号。即：<strong>把构成源程序的字符串转换成“等价的”单词序列</strong><ul><li>根据词法规则识别及组合单词，进行词法检查</li><li>对数字常数完成数字字符串到二进制数值的转换</li><li>删去空格和注释等不影响程序语义的字符</li></ul></li></ul><h2 id="单词的分类与表示-词法分析器的输出">单词的分类与表示&amp;词法分析器的输出</h2><h3 id="单词的内部形式">单词的内部形式</h3><p>二元组 (种别, 属性值)</p><ul><li><strong>种别</strong>：表示种类(可以用整数编码或宏)</li><li><strong>属性值</strong>：不同的单词不同的值</li></ul><h4 id="按单词种类分类">按单词种类分类</h4><img src="..\..\img\CompilerPrinciples\单词的内部形式-按单词种类分类.png" width="100%" height="100%" align="middle"><h4 id="固定数量单词采用一符一类">固定数量单词采用一符一类</h4><img src="..\..\img\CompilerPrinciples\单词的内部形式-一符一类.png" width="100%" height="100%" align="middle"><h3 id="存储方式">存储方式</h3><p>问题：如何存储<strong>标识符和常量</strong>的属性值</p><ul><li>方法1：用标识符和常量<strong>本身的值</strong>表示</li><li>方法2：用<strong>指针</strong>表示</li></ul><h4 id="本身的值">本身的值</h4><ul><li>不同值存储空间长度不同</li><li>往往需要对长度加以限制，意味着要截断</li></ul><h4 id="用指针表示">用指针表示</h4><ul><li>指针长度固定-&gt;属性值的长度相同</li><li>间接访存-&gt;由于词法分析器要兼顾符号表的查填和维护，间接访存增加负担</li></ul><h3 id="例子">例子</h3><img src="..\..\img\CompilerPrinciples\单词的分类与表示-例子.png" width="100%" height="100%" align="middle"><h2 id="源程序的输入缓冲与预处理">源程序的输入缓冲与预处理</h2><p>源程序以<strong>字符流形式</strong>存储于外部介质<br>为正确识别单词，编译程序需要一系列相关处理</p><ul><li><strong>超前搜索和回退</strong><ul><li>标识符的识别，或双字符运算符（**, &lt;=, &lt;&gt;）</li><li>回退操作修正超前搜索</li></ul></li><li><strong>缓冲区</strong><ul><li>假定源程序存储在磁盘上，这样每读一个字符就需要访问一次磁盘，效率显然是很低的。</li><li>一次性从磁盘读取给定大小的部分源程序</li></ul></li><li><strong>空白字符的剔除</strong><ul><li>剔除源程序中的无用符号、空格、换行、注释等</li></ul></li></ul><h3 id="输入缓冲区">输入缓冲区</h3><img src="..\..\img\CompilerPrinciples\词法分析-输入缓冲区.png" width="100%" height="100%" align="middle"><ul><li>单缓冲区存在的问题<ul><li>缓冲区内容用完后，等待新的输入需要等待，应该避免类似的等待</li><li>缓冲区尾部可能只包含单词的一部分，载入下一部分程序时，当前缓冲区的内容被覆盖，最坏情况下可识别的单词长度只能为1，而且无法执行超前搜索</li></ul></li><li>采用<strong>双缓冲区</strong><br><img src="..\..\img\CompilerPrinciples\词法分析-双缓冲区.png" width="100%" height="100%" align="middle"></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">if forward在缓冲区第一部分末尾 then</span><br><span class="line">    重装缓冲区第二部分;</span><br><span class="line">    forward := forward +1</span><br><span class="line">if forward在缓冲区第二部分末尾 then</span><br><span class="line">    重装缓冲区第一部分;</span><br><span class="line">    将forward移到缓冲区第一部分开始</span><br><span class="line">其他情况且当前字符不是EOF </span><br><span class="line">    forward:= forward +1;</span><br></pre></td></tr></table></figure><ul><li>令缓冲区大小为2N，则双缓冲区的每一个大小是N，双缓冲技术将可识别单词的长度扩展到N</li><li>每次移动向前指针都需要做<strong>两次测试</strong>:<ul><li>是否到缓冲区末尾</li><li>当前字符是否是EOF</li></ul></li><li><strong>修正方法</strong>：采用带标记缓冲区，即两个缓冲区的末尾处各设置一个“EOF”标志<ul><li>如果当前字符是“EOF”，就再判断是否到达缓冲区末尾，将移动向前指针需要的两次测试减少到 <strong>(N+1)/N</strong></li></ul></li></ul><h2 id="词法分析阶段的错误处理">词法分析阶段的错误处理</h2><h3 id="非法字符检查">非法字符检查</h3><ul><li>维护一个合法字符集合，对于每一个输入字符，判断该字符是否属于该字符集合</li></ul><h3 id="单词拼写错误">单词拼写错误</h3><ul><li><strong>关键字拼写</strong>词法分析阶段<strong>无法检测</strong>，待语法分析阶段发现错误</li><li>标识符拼写错误，如3b78，处理方法有两种<ul><li>识别出整数3、标识符b78</li><li>错误的标识符</li></ul></li></ul><h3 id="注释或字符常量不封闭">注释或字符常量不封闭</h3><ul><li>会错误地将后续所有源程序看作是<strong>注释或者是字符串</strong>的一部分，影响正常程序分析</li><li>对注释或字符串长度加以限制，如注释长度不超过1行，字符串长度最大是256</li></ul><h3 id="变量重复说明">变量重复说明</h3><ul><li>当词法分析器<strong>兼顾符号表的查填工作时</strong>才能发现该错误</li><li>为了指出<strong>错误的位置</strong>，必须<strong>对源程序进行行列计数</strong></li><li>出错信息可以夹在源程序发生错误的地方（便于修改，但容易弄乱源程序）</li><li>出错信息也可以收集起来统一处理</li></ul><h3 id="错误恢复与续编译">错误恢复与续编译</h3><ul><li>词法分析阶段的错误使得编译无法继续进行，需要采取措施使得编译继续下去</li><li>方法<ul><li>错误校正：极其困难</li><li><strong>紧急方式恢复(panic-mode recovery)</strong>：反复删掉剩余输入最前面的字符，直到词法分析器能发现一个正确的单词为止。</li></ul></li></ul><h2 id="词法分析器的位置">词法分析器的位置</h2><ul><li>独立地完成对源程序的一遍扫描，将单词序列以中间文件形式存储，作为语法分析的输入<ul><li>简化编译器的设计</li><li>提高编译器的效率</li><li>增强编译器的可移植性</li></ul></li><li>作为语法分析器的一个子程序<ul><li>整个编译程序简单紧凑</li></ul></li></ul><h1>单词的描述</h1><ul><li>根据正则文法构造等价的正则表达式</li><li>将正则表达式转换成等价的正则文法</li><li>构造有穷状态自动机</li><li>正则表达式转换为状态转换图</li></ul><h1>单词的识别</h1><h2 id="有穷状态自动机与单词识别的关系">有穷状态自动机与单词识别的关系</h2><ul><li>识别不同进制数的状态图 P91</li><li>单词识别的状态转换图表示 P96</li><li>利用状态转换图识别单词 P98</li><li>由正则文法构造状态转换图 P101</li><li>状态转换图的实现 P107<ul><li>状态矩阵</li><li>邻接表</li><li><strong>四个数组组成的结构</strong>，既可以实现数据压缩存储，又可以实现元素的快速访问 P117</li></ul></li></ul><h1>词法分析程序的自动生成</h1>]]></content>
      
      
      <categories>
          
          <category> 编译原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编译原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编译原理-引论</title>
      <link href="/post/a7451f54.html"/>
      <url>/post/a7451f54.html</url>
      
        <content type="html"><![CDATA[<h1>程序设计语言</h1><ul><li><strong>机器语言</strong><ul><li>每一个具体的计算机系统都具有自己的指令系统</li><li>以<strong>0,1代码</strong>表示的机器指令所构成的语言</li></ul></li><li><strong>汇编语言</strong><ul><li>适当的助记符来表示指令中的操作和操作数</li><li>如含有：add、mov …</li></ul></li><li><strong>高级语言</strong><ul><li>其表示方法更接近于待解问题的表示方法</li><li>定义数据、描述运算、控制流程、传输数据</li><li>如：C、FORTRAN、PASCAL、C++、JAVA</li></ul></li></ul><h1>程序设计语言的翻译</h1><h2 id="翻译程序-Translator">翻译程序(Translator)</h2><ul><li>将某一种语言描述的程序(源程序——Source Program)翻译成<strong>等价</strong>的另一种语言描述的程序(目标程序——Object Program)的<strong>程序</strong>。<br><img src="..\..\img\CompilerPrinciples\翻译程序.png" width="100%" height="100%" align="middle"></li></ul><p><strong>翻译程序</strong> 包含 <strong>解释程序</strong> 和 <strong>编译程序</strong> 两种</p><h3 id="解释程序-Interpreter">解释程序(Interpreter)</h3><ul><li>边解释边执行：不断读取源程序的语句，解释语句，读取此语句需要的数据，根据执行结果读取下一条语句，继续解释执行，直到返回结果</li><li>类似于自然语言翻译的同声传译<br><img src="..\..\img\CompilerPrinciples\解释程序.png" width="100%" height="100%" align="middle"></li></ul><h3 id="编译程序-Compiler">编译程序(Compiler)</h3><ul><li>将源程序<strong>完整地</strong>转换成机器语言程序或汇编语言程序，然后再处理、执行的翻译程序</li><li><strong>高级语言程序</strong> → <strong>汇编/机器语言程序</strong></li><li>类似于自然语言翻译的通篇笔译</li></ul><h3 id="其他翻译程序">其他翻译程序</h3><ul><li><strong>汇编程序(Assembler)</strong><ul><li><strong>源</strong>程序是 <strong>汇编程序</strong>，<strong>目标</strong>程序是 <strong>机器程序</strong></li></ul></li><li><strong>交叉汇编程序(Cross Assembler)</strong><ul><li><strong>源</strong>程序是 <strong>汇编程序</strong>，<strong>目标</strong>程序是 <strong>另一台机器</strong>的 <strong>机器程序</strong></li></ul></li><li><strong>反汇编程序(Disassembler)</strong><ul><li><strong>源</strong>程序是 <strong>机器程序</strong>，<strong>目标</strong>程序是 <strong>汇编程序</strong></li></ul></li><li><strong>交叉编译程序(Cross Compiler)</strong></li></ul><h2 id="编译系统">编译系统</h2><p><strong>编译系统 = 编译程序 + 运行系统</strong><br><img src="..\..\img\CompilerPrinciples\编译系统.png" width="100%" height="100%" align="middle"></p><h1>编译程序的总体结构</h1><img src="..\..\img\CompilerPrinciples\编译程序的总体结构.png" width="100%" height="100%" align="middle"><ul><li><strong>模块分类</strong>：<ul><li><strong>分析</strong>：词法分析、语法分析、语义分析</li><li><strong>综合</strong>：中间代码生成、代码优化、目标代码生成</li><li><strong>辅助</strong>：符号表管理、出错处理</li></ul></li><li>8项功能对应8个模块</li></ul><h2 id="词法分析">词法分析</h2><h3 id="定义">定义</h3><ul><li><p>词法分析由<strong>词法分析器</strong>(Lexical Analyzer)完成，词法分析器又称为<strong>扫描器</strong>(Scanner)</p></li><li><p>词法分析器从左到右扫描组成源程序的<strong>字符串</strong>，并将其转换成单词串；<strong>同时要</strong>：<strong>查词法错误</strong>，<strong>进行标识符登记</strong>（符号表管理）。</p></li><li><p><strong>输入</strong>：<strong>字符串</strong></p></li><li><p><strong>输出</strong>：<strong>(种别码，属性值)——序对</strong></p><ul><li><strong>属性值</strong>——token的机内表示</li></ul></li></ul><h3 id="例子：">例子：</h3><p><strong>输入</strong>：sum=(10+20) * (num+square);<br><strong>输出</strong>: (标识符，sum)    (赋值号，=)    (左括号，()<br>(整常数，10)     (加号，+ )    (整常数，20)<br>(右括号，))      (乘号，* )    (左括号，()<br>(标识符，num)    (加号，+ )    (标识符，square)<br>(右括号，))      (分号，;)</p><h2 id="语法分析">语法分析</h2><ul><li><p>语法分析由<strong>语法分析器</strong>(Syntax Analyzer)完成，语法分析器又叫Parser。</p></li><li><p><strong>功能</strong>：</p><ul><li>Parser实现“<strong>组词成句</strong>”： 将词组成各类语法成分，例如因子、项、表达式、语句、子程序…</li><li>构造分析树</li><li>指出语法错误</li><li>指导翻译</li></ul></li><li><p><strong>输入</strong>：<strong>token序列</strong></p></li><li><p><strong>输出</strong>：<strong>语法成分</strong></p></li></ul><img src="..\..\img\CompilerPrinciples\语法分析.png" width="100%" height="100%" align="middle"><h2 id="语义分析">语义分析</h2><ul><li>语义分析(semantic analysis)一般<strong>和语法分析同时进行</strong>，称为<strong>语法制导翻译</strong></li><li><strong>功能</strong>：分析由<strong>语法分析器</strong>识别出来的 语法成分的<strong>语义</strong><ul><li>获取标识符的<strong>属性</strong>：类型、作用域等</li><li><strong>语义检查</strong>：运算的合法性、取值范围等</li><li><strong>子程序的静态绑定</strong>：代码的相对地址</li><li><strong>变量的静态绑定</strong>：数据的相对地址<br><img src="..\..\img\CompilerPrinciples\语义分析.png" width="100%" height="100%" align="middle"></li></ul></li></ul><h2 id="中间代码生成">中间代码生成</h2><ul><li>语义分析通常以中间代码形式表达操作</li><li>中间代码的<strong>特点</strong><ul><li>简单规范</li><li><strong>与机器无关</strong></li><li>易于优化与转换<br><img src="..\..\img\CompilerPrinciples\中间代码生成.png" width="100%" height="100%" align="middle"></li></ul></li></ul><h2 id="代码优化-optimization">代码优化(optimization)</h2><ul><li>对中间代码进行优化处理，使程序运行能够 尽量<strong>节省存储空间</strong>，更<strong>有效地利用机器资源</strong>，使得程序的<strong>运行速度更快</strong>，<strong>效率更高</strong></li><li>这种优化<strong>变换必须是等价的</strong>。</li><li>分为（<strong>与机器无关的优化</strong>）和（<strong>与机器有关的优化</strong>）两种</li></ul><h3 id="与机器无关的优化">与机器无关的优化</h3><p>可以理解为 <strong>算法</strong></p><h4 id="局部优化">局部优化</h4><ul><li><strong>常量合并</strong>：常数运算在编译期间完成，如 8+9*4</li><li><strong>公共子表达式的提取</strong></li></ul><h4 id="全局优化">全局优化</h4><ul><li>主要是指<strong>循环优化</strong></li><li><strong>强度削减</strong>：用较快的操作代替较慢的操作</li><li><strong>代码外提</strong>：将循环中不变的计算移出循环</li></ul><h3 id="与机器有关的优化">与机器有关的优化</h3><p>可以理解为 <strong>组成原理</strong> 和 <strong>体系结构</strong></p><ul><li><strong>寄存器的利用</strong><ul><li>将常用量放入寄存器，以减少访问内存的次数</li></ul></li><li><strong>体系结构</strong><ul><li>SIMD 、MIMD、SPMD、向量机、流水机</li></ul></li><li><strong>任务划分</strong><ul><li>按运行的算法及体系结构，划分子任务(MPMD)</li></ul></li><li><strong>存储策略</strong><ul><li>根据算法访存的要求安排：Cache、并行存储体系——减少访问冲突</li></ul></li></ul><h4 id="存储层次">存储层次</h4><ul><li>CPU寄存器<ul><li>保存着最常用的数据，0 个周期访问数据</li></ul></li><li>高速缓冲存储器<ul><li>靠近CPU的小的、快速的存储器，1-30个周期访问数据</li></ul></li><li>主存储器<ul><li>存储系统和进程运行所需的数据和指令，50-200个周期访问数据</li></ul></li><li>磁盘<ul><li>最主要存储设备，10,000,000个周期访问数据</li></ul></li></ul><h2 id="目标代码生成">目标代码生成</h2><ul><li>编译程序的<strong>最后一个阶段</strong></li><li>为中间代码中出现的运算对象<strong>分配存储单元、寄存器</strong>等</li><li>将<strong>中间代码转换成目标机上的机器指令代码或汇编代码</strong><ul><li>对于确定源语言的各种语法成分，确定目标代码结构（机器指令组/汇编语句组）</li><li>制定从中间代码到目标代码的翻译策略或算法</li></ul></li></ul><h2 id="错误处理">错误处理</h2><ul><li>进行各种错误的<strong>检查、报告、纠正</strong>，以及相应的续编译处理(如：错误的定位与局部化)<ul><li><strong>词法分析阶段</strong>：拼写方面的错误，出现非法字符等</li><li><strong>语法分析阶段</strong>：表达式、句子或程序结构等错误</li><li><strong>语义分析阶段</strong>：类型匹配错误、参数匹配错误、非法转移问题等</li></ul></li></ul><h2 id="表格管理">表格管理</h2><ul><li><strong>管理各种符号表</strong>(常数、标号、变量、过程、结构……)，查、填源程序中出现的符号和编译程序生成的符号，<strong>为编译的各个阶段提供信息</strong>。</li><li>Hash表、链表等各种表的查、填技术</li><li>“数据结构与算法” 课程的应用</li></ul><h1>编译程序的组织</h1><ul><li>根据系统资源的状况、运行目标的要求等，可以将一个编译程序设计成多**遍（Pass）**扫描的形式，在每一遍扫描中，完成不同任务。<ul><li>如：首遍构造语法树，二遍处理中间表示，增加信息等</li></ul></li><li><strong>遍可以和阶段相对应，也可以和阶段无关</strong></li><li>遍<strong>数量</strong>的优化<ul><li>根据语言、系统追求的目标、计算机的资源状况等决定</li></ul></li></ul><h2 id="多遍扫描">多遍扫描</h2><ul><li>本遍扫描的结果作为下一遍扫描的输入，本遍扫描中得到的信息在下一遍扫描中也有效，容易获得更优化的程序<ul><li>可以将词法分析、语法分析、语义分析和中间代码生成做成一遍；</li><li>将代码优化做成一遍；</li><li>将目标代码生成做成一遍</li></ul></li><li>增加内存访问次数，可能增加外部存储的访问次数</li></ul><h2 id="单遍扫描">单遍扫描</h2><ul><li>分析所需的信息可能目前尚未掌握，导致产生的目标程序难以达到最优</li></ul><h2 id="编译程序的设计目标">编译程序的设计目标</h2><ul><li>规模小、速度快、诊断能力强、可靠性高、<strong>可移植性好</strong>、可扩充性好</li><li>目标程序也要规模小、执行速度快</li><li>为了提高可移植性，将<strong>编译程序划分为前端和后端</strong></li></ul><h2 id="前端">前端</h2><ul><li>与源语言有关、与目标机无关的部分</li><li>词法分析、语法分析、语义分析与中间代码生成、与机器无关的代码优化</li><li>对于<strong>某一种高级语言在不同机器上的编译系统</strong>，前端的处理基本是一样的，<strong>前端部分可被复用</strong>，只需要针对不同的机器构建后端就可以</li></ul><h2 id="后端">后端</h2><ul><li>与目标机有关的部分</li><li>与机器有关的代码优化、目标代码生成</li><li>在<strong>某一种机器上实现多种高级语言的编译系统</strong>，<strong>后端部分可以被复用</strong>，只需要针对不同高级语言构建前端就可以</li></ul><h1>编译程序的生成</h1><ul><li>编译程序也是运行在计算机上的<strong>程序</strong></li></ul><h2 id="T形图">T形图</h2><p>表示语言翻译的T形图<br><img src="..\..\img\CompilerPrinciples\T形图.png" width="100%" height="100%" align="middle"></p><p>一个用A语言描述的编译程序，它将S语言源程序翻译成了T语言目标程序</p><h2 id="自展">自展</h2><ul><li><strong>问题一：如何直接在一个机器上实现C语言编译器？</strong></li><li>解决：<ol><li>用汇编语言实现一个C子集的编译程序<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">P_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></li><li>用汇编程序处理该程序<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">P_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>,得到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">P_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>（可直接运行）</li><li>用C子集编制C语言的编译程序<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mn>3</mn></msub></mrow><annotation encoding="application/x-tex">P_3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></li><li>用<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">P_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>编译<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mn>3</mn></msub></mrow><annotation encoding="application/x-tex">P_3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，得到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mn>4</mn></msub></mrow><annotation encoding="application/x-tex">P_4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></li></ol></li></ul><h2 id="移植">移植</h2><ul><li><strong>问题二</strong>：A机上有一个C语言编译器，是否可利用此编译器实现B机上的C语言编译器？<ul><li>条件：A机有C 语言的编译程序</li><li>目的：实现B机的C语言的编译</li></ul></li><li>解决：<ol><li>用Ｃ语言编制B机的Ｃ编译程序<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">P_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></li><li>(Ａ机C编译器<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">P_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>)编译<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">P_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，得到在A机上可运行的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">P_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></li><li>(Ａ机的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">P_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>)编译<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">P_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，得到B机上可运行的编译器<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mn>3</mn></msub></mrow><annotation encoding="application/x-tex">P_3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></li></ol></li></ul><h2 id="本机编译器的利用">本机编译器的利用</h2><ul><li><strong>问题三</strong>： A机上有一个C语言编译器，现要实现一个新语言NEW的编译器？</li><li>解决：<ul><li>用C编写NEW的编译器，并用C编译器编译它</li></ul></li></ul><h2 id="编译程序的自动生成">编译程序的自动生成</h2><h3 id="词法分析器的自动生成程序">词法分析器的自动生成程序</h3><img src="..\..\img\CompilerPrinciples\词法分析器的自动生成程序.png" width="100%" height="100%" align="middle"><h3 id="语法分析器的自动生成程序">语法分析器的自动生成程序</h3><img src="..\..\img\CompilerPrinciples\语法分析器的自动生成程序.png" width="100%" height="100%" align="middle">]]></content>
      
      
      <categories>
          
          <category> 编译原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编译原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络-概述</title>
      <link href="/post/be54bfd5.html"/>
      <url>/post/be54bfd5.html</url>
      
        <content type="html"><![CDATA[<h2 id="因特网">因特网</h2><ul><li><p>基于ISP的三层结构的因特网<br><img src="../../img/Network/基于ISP的三层结构的因特网.png" width="100%" height="100%"></p></li><li><p>因特网的组成<br><img src="../../img/Network/因特网的组成.png" width="100%" height="100%"></p></li></ul><h2 id="三种交换方式">三种交换方式</h2><h3 id="电路交换">电路交换</h3><ul><li>电话交换机 接通电话线的方式称为 电路交换</li><li>三个步骤：<ul><li>建立连接 （分配通信资源）</li><li>通话 （<strong>一直占用</strong>通信资源）</li><li>释放连接 （归还通信资源）</li></ul></li><li>传输计算机数据时效率很低 （因为计算机数据传输是 <strong>突发式</strong>的）</li></ul><h3 id="分组交换">分组交换</h3><ul><li>通过路由器 传送 分组</li><li>三方：<ul><li>发送方： 构造分组、发送分组</li><li>路由器： 缓存分组、转发分组 （<strong>存储转发</strong>）</li><li>接收方： 接收分组、还原报文</li></ul></li></ul><h3 id="报文交换">报文交换</h3><ul><li>没有限制报文大小的交换， 需要各个节点交换机有较大的缓存空间<br><img src="../../img/Network/三种交换方式.png" width="100%" height="100%"></li></ul><h3 id="优缺点">优缺点</h3><h4 id="电路交换-2">电路交换</h4><ul><li>优点：<ul><li>通信时延小</li><li>有序传输</li><li>没有冲突</li><li>适用范围广</li><li>实时性强</li><li>控制简单</li></ul></li><li>缺点：<ul><li>建立连接时间长</li><li>线路独占、使用效率低</li><li>灵活性差</li><li>难以规格化</li></ul></li></ul><h4 id="报文交换-2">报文交换</h4><ul><li>优点：<ul><li>无需建立连接</li><li>动态分配线路</li><li>提高线路可靠性</li><li>提高线路利用率</li><li>提供多目标服务</li></ul></li><li>缺点：<ul><li>引起了转发时延</li><li>需要较大存储缓存空间</li><li>需要传输额外的信息量</li></ul></li></ul><h4 id="分组交换-2">分组交换</h4><ul><li>优点：<ul><li>无需建立连接</li><li>提高线路利用率</li><li><strong>简化了存储管理</strong> （分组大小固定）</li><li><strong>加速传输</strong>（在转发分组时可以同时存储下一个分组）</li><li><strong>减少出错概率和重发数据量</strong>（分组小，从而出错概率小，重发量小）</li></ul></li><li>缺点：<ul><li>引起了转发时延</li><li>需要传输额外的信息量</li><li><strong>对于数据报服务，存在失序、丢失或重复分组的问题</strong></li><li>对于虚电路服务，存在呼叫建立、数据传输和虚电路释放三个过程</li></ul></li></ul><h2 id="计算机网络的分类">计算机网络的分类</h2><img src="../../img/Network/计算机网络分类.png" width="100%" height="100%"><h2 id="计算机网络的性能指标">计算机网络的性能指标</h2><h3 id="速率">速率</h3><ul><li>传送比特的速率，也称 <strong>比特率</strong></li><li>单位：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi><mi>i</mi><mi>t</mi><mi mathvariant="normal">/</mi><mi>s</mi><mo stretchy="false">(</mo><mi>b</mi><mi>p</mi><mi>s</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">bit/s   (bps)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">bi</span><span class="mord mathnormal">t</span><span class="mord">/</span><span class="mord mathnormal">s</span><span class="mopen">(</span><span class="mord mathnormal">b</span><span class="mord mathnormal">p</span><span class="mord mathnormal">s</span><span class="mclose">)</span></span></span></span><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mi>b</mi><mi mathvariant="normal">/</mi><mi>s</mi><mo>=</mo><mn>1</mn><msup><mn>0</mn><mn>3</mn></msup><mi>b</mi><mi>i</mi><mi>t</mi><mi mathvariant="normal">/</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">kb/s = 10^3 bit/s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">kb</span><span class="mord">/</span><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mord mathnormal">bi</span><span class="mord mathnormal">t</span><span class="mord">/</span><span class="mord mathnormal">s</span></span></span></span></li></ul></li><li>速率单位中 是以 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>3</mn></msup></mrow><annotation encoding="application/x-tex">10^3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span></span></span></span> 进制的</li><li>数据量单位中 是以 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>1</mn></msup><mn>0</mn></mrow><annotation encoding="application/x-tex">2^10</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span></span></span></span></span><span class="mord">0</span></span></span></span> 进制的<br><img src="../../img/Network/速率计算例题.png" width="100%" height="100%"></li></ul><h3 id="带宽">带宽</h3><h4 id="在模拟信号系统的意义">在模拟信号系统的意义</h4><ul><li><strong>信号</strong>所包含的各种不同频率成分所占据的 <strong>频率范围</strong></li><li>单位：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>H</mi><mi>z</mi><mo stretchy="false">(</mo><mi>k</mi><mi>H</mi><mi>z</mi><mo separator="true">,</mo><mi>M</mi><mi>H</mi><mi>z</mi><mo separator="true">,</mo><mi>G</mi><mi>H</mi><mi>z</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Hz (kHz, MHz, GHz)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.04398em;">Hz</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mord mathnormal" style="margin-right:0.04398em;">Hz</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mord mathnormal" style="margin-right:0.04398em;">Hz</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">G</span><span class="mord mathnormal" style="margin-right:0.04398em;">Hz</span><span class="mclose">)</span></span></span></span></li></ul><h4 id="计网中的意义">计网中的意义</h4><ul><li>表示网络的<strong>通信线路</strong>所能传送数据的能力，因此网络带宽表示 <strong>在单位时间内</strong>从网络中的某一点到另一点所能通过的“<strong>最高数据率</strong>”</li><li>单位：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi><mi>i</mi><mi>t</mi><mi mathvariant="normal">/</mi><mi>s</mi><mo stretchy="false">(</mo><mi>b</mi><mi>p</mi><mi>s</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">bit/s (bps)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">bi</span><span class="mord mathnormal">t</span><span class="mord">/</span><span class="mord mathnormal">s</span><span class="mopen">(</span><span class="mord mathnormal">b</span><span class="mord mathnormal">p</span><span class="mord mathnormal">s</span><span class="mclose">)</span></span></span></span> <strong>与速率单位相同</strong></li></ul><h3 id="吞吐量">吞吐量</h3><ul><li>单位时间内通过某个网络的数据量</li><li>受网络的带宽或额定速率的限制</li></ul><h3 id="时延">时延</h3><ul><li>由 发送时延、传播时延、处理时延构成</li><li>发送时延 = 分组长度(b) / 发送速率(b/s)</li><li>传播时延 = 信道长度(m) / 电磁波传播速率(m/s)</li><li>处理时延 不方便计算</li></ul><h3 id="时延带宽积">时延带宽积</h3><ul><li>时延带宽积 = 传播时延 * 带宽<br><img src="../../img/Network/时延带宽积.png" width="100%" height="100%"></li></ul><h3 id="往返时间-RTT">往返时间 RTT</h3><p>Round-Trip Time 双向交互一次的时间 <strong>RTT</strong></p><h3 id="利用率">利用率</h3><ul><li><p>信道利用率： 用来表示某信道有百分之几的时间是被利用的(有数据通过)</p></li><li><p>网络利用率： 全网络的信道利用率的加权平均</p></li><li><p>当某信道的利用率增大时，该信道引起的时延也会迅速增加</p></li><li><p>如令 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>D</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">D_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 表示网络空闲时的时延，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi></mrow><annotation encoding="application/x-tex">D</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span></span></span></span> 表示网络当前时延，可以用下面简化的公式表示时延与利用率 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>U</mi></mrow><annotation encoding="application/x-tex">U</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span></span></span></span>的关系：</p></li></ul><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>D</mi><mo>=</mo><mfrac><msub><mi>D</mi><mn>0</mn></msub><mrow><mn>1</mn><mo>−</mo><mi>U</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">D = \dfrac{D_0}{1-U}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.1297em;vertical-align:-0.7693em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3603em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.7693em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><ul><li>因此一些有较大主干网的ISP通常会控制它们的 信道利用率不超过 50%。</li></ul><h3 id="丢包率">丢包率</h3><ul><li>即分组丢失率，在一定时间内，传输过程中<strong>丢失的分组数</strong>与<strong>总分组数</strong>的比率</li><li>分组丢失主要两种情况：<ul><li>分组在传输过程中出现<strong>误码</strong>, 被结点丢弃；</li><li>分组到达一台队列已满的交换机时被丢弃，在通信量较大时造成<strong>网络拥塞</strong></li></ul></li><li>丢包率反应了网络的拥塞情况<ul><li>无拥塞时 丢包率为0</li><li>轻度拥塞时 为 1% - 4%</li><li>严重拥塞时 为 5% - 15%</li></ul></li></ul><h2 id="计算机网络体系结构">计算机网络体系结构</h2><h3 id="体系结构层次">体系结构层次</h3><img src="../../img/Network/体系结构层次.png" width="100%" height="100%"><h3 id="术语">术语</h3><ul><li><p><strong>实体</strong>： 任何可发送或接受信息的<strong>硬件</strong>或<strong>软件进程</strong></p></li><li><p><strong>对等实体</strong>： 收发双方<strong>相同层次中的实体</strong></p></li><li><p><strong>协议</strong>：控制两个对等实体进行逻辑通信的规则的集合</p></li><li><p>协议的<strong>三要素</strong>： 语法  语义  同步</p><ul><li><strong>语法</strong> 定义所交换信息的格式</li><li><strong>语义</strong> 定义收发双方所要完成的操作</li><li><strong>同步</strong> 定义收发双方的时序关系</li></ul></li><li><p>在协议的控制下，两个对等实体间的逻辑通信使得本层能向上一层提供<strong>服务</strong></p></li><li><p>协议时 <strong>“水平的”</strong>， 服务是 <strong>“垂直的”</strong></p></li><li><p><strong>服务访问点</strong>： 在同一系统中 <strong>相邻两层的实体交换信息的逻辑接口</strong></p><ul><li>数据链路层 的 服务访问点为 帧的“类型”字段</li><li>网络层 的 服务访问点为 IP数据报首部中的“协议字段”</li><li>运输层 的 服务访问点为 “端口号”</li></ul></li><li><p><strong>服务原语</strong>： 上层使用下层所提供的服务必须通过与下层<strong>交换一些命令</strong>，这些命令称为服务原语</p></li><li><p><strong>协议数据单元PDU</strong>: <strong>对等层次之间传送的数据包</strong> 称为该层的协议数据单元</p></li><li><p><strong>服务数据单元SDU</strong>: <strong>同一系统内，层与层之间交换的数据包</strong> 称为服务数据单元</p></li></ul><img src="../../img/Network/术语.png" width="100%" height="100%">]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DFS和BFS</title>
      <link href="/post/f5273844.html"/>
      <url>/post/f5273844.html</url>
      
        <content type="html"><![CDATA[<h1>DFS</h1><p>回溯算法，其实就是dfs的过程，这里给出dfs的代码框架：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(参数)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (终止条件) &#123;</span><br><span class="line">        存放结果;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (选择：本节点所连接的其他节点) &#123;</span><br><span class="line">        处理节点;</span><br><span class="line">        <span class="built_in">dfs</span>(图，选择的节点); <span class="comment">// 递归</span></span><br><span class="line">        回溯，撤销处理结果</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>深搜代码模板，该模板针对的是四方格的地图：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> dir[<span class="number">4</span>][<span class="number">2</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;; <span class="comment">// 四个方向</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; grid, vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt;&amp; visited, <span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        <span class="type">int</span> nextx = x + dir[i][<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> nexty = y + dir[i][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (nextx &lt; <span class="number">0</span> || nextx &gt;= grid.<span class="built_in">size</span>() || nexty &lt; <span class="number">0</span> || nexty &gt;= grid[<span class="number">0</span>].<span class="built_in">size</span>()) <span class="keyword">continue</span>;  <span class="comment">// 越界了，直接跳过</span></span><br><span class="line">        <span class="keyword">if</span> (!visited[nextx][nexty]) &#123; <span class="comment">// 没有访问过的</span></span><br><span class="line">            visited[nextx][nexty] = <span class="literal">true</span>; </span><br><span class="line">            <span class="built_in">dfs</span>(grid, visited, nextx, nexty);</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>BFS</h1><p>广搜代码模板，该模板针对的是四方格的地图：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> dir[<span class="number">4</span>][<span class="number">2</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;; <span class="comment">// 表示四个方向</span></span><br><span class="line"><span class="comment">// grid 是地图，也就是一个二维数组</span></span><br><span class="line"><span class="comment">// visited标记访问过的节点，不要重复访问</span></span><br><span class="line"><span class="comment">// x,y 表示开始搜索节点的下标</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; grid, vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt;&amp; visited, <span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; que; <span class="comment">// 定义队列</span></span><br><span class="line">    que.<span class="built_in">push</span>(&#123;x, y&#125;); <span class="comment">// 起始节点加入队列</span></span><br><span class="line">    visited[x][y] = <span class="literal">true</span>; <span class="comment">// 只要加入队列，立刻标记为访问过的节点</span></span><br><span class="line">    <span class="keyword">while</span>(!que.<span class="built_in">empty</span>()) &#123; <span class="comment">// 开始遍历队列里的元素</span></span><br><span class="line">        pair&lt;<span class="type">int</span> ,<span class="type">int</span>&gt; cur = que.<span class="built_in">front</span>(); </span><br><span class="line">        que.<span class="built_in">pop</span>(); <span class="comment">// 从队列取元素</span></span><br><span class="line">        <span class="type">int</span> curx = cur.first;</span><br><span class="line">        <span class="type">int</span> cury = cur.second; <span class="comment">// 当前节点坐标</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123; <span class="comment">// 开始想当前节点的四个方向左右上下去遍历</span></span><br><span class="line">            <span class="type">int</span> nextx = curx + dir[i][<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> nexty = cury + dir[i][<span class="number">1</span>]; <span class="comment">// 获取周边四个方向的坐标</span></span><br><span class="line">            <span class="keyword">if</span> (nextx &lt; <span class="number">0</span> || nextx &gt;= grid.<span class="built_in">size</span>() || nexty &lt; <span class="number">0</span> || nexty &gt;= grid[<span class="number">0</span>].<span class="built_in">size</span>())</span><br><span class="line">                <span class="keyword">continue</span>;<span class="comment">// 坐标越界了，直接跳过</span></span><br><span class="line">            <span class="keyword">if</span> (!visited[nextx][nexty]) &#123; <span class="comment">// 如果节点没被访问过</span></span><br><span class="line">                que.<span class="built_in">push</span>(&#123;nextx, nexty&#125;);  <span class="comment">// 队列添加该节点为下一轮要遍历的节点</span></span><br><span class="line">                visited[nextx][nexty] = <span class="literal">true</span>; <span class="comment">// 只要加入队列立刻标记，避免重复访问</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++-仿函数与函数指针</title>
      <link href="/post/7b13e28b.html"/>
      <url>/post/7b13e28b.html</url>
      
        <content type="html"><![CDATA[<h1>函数指针</h1><h2 id="指向函数存储内存地址的指针">指向函数存储内存地址的指针</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个 无参返回值为int 的函数指针</span></span><br><span class="line"><span class="built_in">int</span> (*funcPtr)();</span><br></pre></td></tr></table></figure><h2 id="把函数赋值给函数指针">把函数赋值给函数指针</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">func1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">int</span> (*funcPtr)() = func1; </span><br><span class="line">    <span class="comment">// C++会隐式得把func1 转换成 &amp;func1, 无需加入&amp;</span></span><br><span class="line">    funcPtr = func2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="通过函数指针调用函数">通过函数指针调用函数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">func3</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">int</span> (*funcPtr1)(<span class="type">int</span>) = func3;</span><br><span class="line">(*funcPtr1)(<span class="number">5</span>);</span><br><span class="line"><span class="built_in">funcPtr1</span>(<span class="number">5</span>);   <span class="comment">//也可以这么使用，在一些古老的编译器上可能不行</span></span><br></pre></td></tr></table></figure><h2 id="把函数作为参数传入另一个函数">把函数作为参数传入另一个函数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sub</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a-b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> e, <span class="type">int</span> d, <span class="type">int</span>(*func)(<span class="type">int</span> a, <span class="type">int</span> b))</span></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">func</span>(e,d)&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">func</span>(<span class="number">2</span>,<span class="number">3</span>,add);</span><br><span class="line">    <span class="built_in">func</span>(<span class="number">2</span>,<span class="number">3</span>,sub);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>仿函数</h1><h2 id="仿函数由来">仿函数由来</h2><ul><li>是代替 <strong>函数指针</strong> 的手段</li><li>定义一个类，类里面重载函数运算符()，将该类的对象作为函数的入参，那么在函数中同样能调用重载符()里面的方法</li><li>所以说，仿函数就是仿造的函数，它并不是一个真正意义上的函数。它是一个类中的运算符()重载，但它具有函数的功能。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Compare</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_Number;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Compare</span>(<span class="type">int</span> num) : <span class="built_in">m_Number</span>(num)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> other)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_Number &gt; other;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//定义对象调用</span></span><br><span class="line">    <span class="function">Compare <span class="title">cmp</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    cout&lt;&lt; <span class="built_in">cmp</span>(<span class="number">11</span>);</span><br><span class="line">    <span class="comment">//通过临时对象调用</span></span><br><span class="line">    cout&lt;&lt; <span class="built_in">Compare</span>(<span class="number">10</span>)();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="作用">作用</h2><ul><li>在STL库中十分常见</li></ul><h3 id="sort-与-priority-queue-中的用法">sort() 与 priority_queue 中的用法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> pair&lt;string, <span class="type">int</span>&gt; PAIR;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmpfunc</span><span class="params">(<span class="type">const</span> PAIR&amp; lhs, <span class="type">const</span> PAIR&amp; rhs)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> lhs.second &lt; rhs.second;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Compare</span> &#123;  </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> PAIR&amp; lhs, <span class="type">const</span> PAIR&amp; rhs)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> lhs.second &lt; rhs.second;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 仿函数 并且是临时对象</span></span><br><span class="line">    <span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), <span class="built_in">Compare</span>());  </span><br><span class="line">    <span class="comment">// 直接传入函数指针 隐式将cmpfunc 转为 &amp;cmpfunc</span></span><br><span class="line">    <span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), cmpfunc);</span><br><span class="line">    <span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), <span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">    <span class="comment">// 对priority_queue 只能传 结构体或类的 名称，不是对象！！！</span></span><br><span class="line">    <span class="comment">// 因为是定义 而不是像sort一样直接使用 仿函数 greater&lt;int&gt;()</span></span><br><span class="line">    priority_queue&lt;PAIR, vector&lt;PAIR&gt;, Compare &gt; que;</span><br><span class="line">    priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt; &gt; que;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="greater-int-源码">greater<int> 源码</h3><p>是一个仿函数<br><img src="../../img/C++/greater源码.png" width="100%" height="100%"></p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排序算法</title>
      <link href="/post/735e5788.html"/>
      <url>/post/735e5788.html</url>
      
        <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/alzzw/article/details/98100378">参考博客</a></p><img src="../../img/Algorithm/排序算法分类.png" width="100%" height="100%"><h1>复杂度</h1><img src="../../img/Algorithm/排序算法复杂度对比.png" width="100%" height="100%"><ul><li>稳定性：<ul><li>指待排序的序列中有两元素相等,排序之后它们的先后顺序不变.</li><li>也可以理解为一切皆在掌握中,元素的位置处在你在控制中.而不稳定算法有时就有点碰运气,随机的成分.</li></ul></li></ul><h1>BubbleSort</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">BubbleSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; vec, <span class="type">int</span> l, <span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &lt; r)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;r; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(vec[i] &gt; vec[i+<span class="number">1</span>])</span><br><span class="line">                <span class="built_in">swap</span>(vec[i], vec[i+<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">BubbleSort</span>(vec, l, r<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>SelectionSort</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SelectionSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; vec, <span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(n &gt; <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="type">int</span> max = vec[<span class="number">0</span>], pos = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(max &lt; vec[i])&#123;</span><br><span class="line">                max = vec[i];</span><br><span class="line">                pos = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">swap</span>(vec[pos], vec[n<span class="number">-1</span>];)</span><br><span class="line">        n--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>InsertionSort</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">InsertionSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; vec, <span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;n; i++)&#123;</span><br><span class="line">        <span class="type">int</span> key = vec[i], j = i;</span><br><span class="line">        <span class="keyword">while</span>(vec[j<span class="number">-1</span>] &gt; key)&#123;</span><br><span class="line">            vec[j] = vec[j<span class="number">-1</span>];</span><br><span class="line">            j--;</span><br><span class="line">            <span class="keyword">if</span>(j==<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        vec[j] = key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>ShellSort</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ShellSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> gap = n / <span class="number">2</span>; gap &gt;= <span class="number">1</span> ; gap /= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = gap; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="type">int</span> j, key = nums[i];</span><br><span class="line">            <span class="keyword">for</span> (j = i - gap; j &gt;= <span class="number">0</span> &amp;&amp; key &lt; nums[j]; j -= gap) &#123;</span><br><span class="line">                <span class="comment">// 依次后移</span></span><br><span class="line">                nums[j + gap] = nums[j];</span><br><span class="line">            &#125;</span><br><span class="line">            nums[j + gap] = key;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>MergeSort</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Merge</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; vec, <span class="type">int</span> l, <span class="type">int</span> mid, <span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">helper</span><span class="params">(vec)</span></span>;</span><br><span class="line">    <span class="type">int</span> lp = l, rp = mid+<span class="number">1</span>, cp = l;</span><br><span class="line">    <span class="keyword">while</span>(lp&lt;=mid &amp;&amp; rp&lt;=r)&#123;</span><br><span class="line">        <span class="keyword">if</span>(helper[lp] &gt;= helper[rp])&#123;</span><br><span class="line">            vec[cp++] = helper[rp++];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            vec[cp++] = helper[lp++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(lp &lt;= mid)&#123;</span><br><span class="line">        vec[cp++] = helper[lp++];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MergeSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; vec, <span class="type">int</span> l, <span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &lt; r)&#123;</span><br><span class="line">        <span class="type">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">MergeSort</span>(vec, l, mid);</span><br><span class="line">        <span class="built_in">MergeSort</span>(vec, mid+<span class="number">1</span>, r);</span><br><span class="line">        <span class="built_in">Merge</span>(vec, l, mid, r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>QuickSort</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">QuickSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp;nums, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;    </span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) </span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> x = <span class="built_in">rand</span>() % (r - l + <span class="number">1</span>) + l;</span><br><span class="line">    <span class="built_in">swap</span>(nums[l], nums[x]);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> pivot = nums[l], lp = l, rp = r;</span><br><span class="line">    <span class="keyword">while</span> (lp &lt; rp) &#123;</span><br><span class="line">        <span class="keyword">while</span> (nums[rp] &gt;= pivot &amp;&amp; lp &lt; rp) </span><br><span class="line">            rp--;</span><br><span class="line">        <span class="keyword">if</span> (lp &lt; rp)</span><br><span class="line">            nums[lp] = nums[rp];</span><br><span class="line">        <span class="keyword">while</span> (nums[lp] &lt;= pivot &amp;&amp; lp &lt; rp) </span><br><span class="line">            lp++;</span><br><span class="line">        <span class="keyword">if</span> (lp &lt; rp)</span><br><span class="line">            nums[rp] = nums[lp];</span><br><span class="line">    &#125;</span><br><span class="line">    nums[lp] = pivot;</span><br><span class="line">    <span class="built_in">QuickSort</span>(nums, l, lp - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">QuickSort</span>(nums, lp + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>HeapSort</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">heapify</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; vec, <span class="type">int</span> i, <span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> lp = <span class="number">2</span>*i+<span class="number">1</span>, rp = <span class="number">2</span>*i+<span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> largestId = i;</span><br><span class="line">    <span class="keyword">if</span>(lp &lt; n &amp;&amp; vec[largestId] &lt; vec[lp]) </span><br><span class="line">        largestId = lp;</span><br><span class="line">    <span class="keyword">if</span>(rp &lt; n &amp;&amp; vec[largestId] &lt; vec[rp])</span><br><span class="line">        largestId = rp;</span><br><span class="line">    <span class="keyword">if</span>(largestId != i)&#123;</span><br><span class="line">        <span class="built_in">swap</span>(vec[largestId], vec[i]);</span><br><span class="line">        <span class="built_in">heapify</span>(vec, largestId, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HeapSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; vec)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n = vec.<span class="built_in">size</span>();</span><br><span class="line">    <span class="comment">// 建堆</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n/<span class="number">2</span><span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">        <span class="built_in">heapify</span>(vec, i, n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//排序</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n<span class="number">-1</span>; i&gt;<span class="number">0</span>; i--)&#123;</span><br><span class="line">        <span class="built_in">swap</span>(vec[i], vec[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">heapify</span>(vec, <span class="number">0</span>, i); </span><br><span class="line">        <span class="comment">// 这里的i是堆去掉排序好的元素后的长度</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>BucketSort</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置10个桶</span></span><br><span class="line"><span class="type">int</span> N = <span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BucketSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;vec)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n = vec.<span class="built_in">size</span>();</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">bucket</span>(N);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    bucket[vec[i] / <span class="number">10</span>].<span class="built_in">push_back</span>(vec[i]);</span><br><span class="line">    <span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++)&#123;</span><br><span class="line">    <span class="comment">//对每个桶进行排序</span></span><br><span class="line">    <span class="built_in">sort</span>(bucket[i].<span class="built_in">begin</span>(), bucket[i].<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;bucket[i].<span class="built_in">size</span>(); j++)</span><br><span class="line">        vec[k++] = bucket[i][j];<span class="comment">//放入原数组</span></span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;().<span class="built_in">swap</span>(bucket); <span class="comment">//释放空间</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>RadixSort</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_max</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; vec, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> max = vec[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">        <span class="keyword">if</span> (vec[i] &gt; max)</span><br><span class="line">            max = vec[i];</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对数组按照&quot;某个位数&quot;进行排序(桶排序)</span></span><br><span class="line"><span class="comment">// exp -- 指数 0, 10, 100, ...</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">count_sort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; vec, <span class="type">int</span> n, <span class="type">int</span> exp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">output</span><span class="params">(n)</span></span>;             <span class="comment">// 存储&quot;被排序数据&quot;的临时数组</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">buckets</span><span class="params">(<span class="number">10</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="comment">// 将数据出现的次数存储在buckets中</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        buckets[(vec[i]/exp)%<span class="number">10</span>]++;</span><br><span class="line">    <span class="comment">// 更改buckets[i]。目的是让更改后的buckets[i]的值，是该数据在output[]中的位置。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">        buckets[i] += buckets[i - <span class="number">1</span>];</span><br><span class="line">    <span class="comment">// 将数据存储到临时数组output中</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        output[buckets[(vec[i]/exp)%<span class="number">10</span>] - <span class="number">1</span>] = vec[i];</span><br><span class="line">        buckets[(vec[i]/exp)%<span class="number">10</span>]--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将排序好的数据赋值给vec</span></span><br><span class="line">    vec.<span class="built_in">swap</span>(output);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RadixSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; vec, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> max = <span class="built_in">get_max</span>(vec, n);    </span><br><span class="line">    <span class="comment">// 从个位开始，对数组a按&quot;指数&quot;进行排序</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> exp = <span class="number">1</span>; max/exp &gt; <span class="number">0</span>; exp *= <span class="number">10</span>)</span><br><span class="line">        <span class="built_in">count_sort</span>(vec, n, exp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>libevent</title>
      <link href="/post/44f83040.html"/>
      <url>/post/44f83040.html</url>
      
        <content type="html"><![CDATA[<p><code>libevent</code> 是一个轻量级、跨平台的事件通知库，专门用于高效管理大量并发 I/O 操作。它为基于事件驱动的应用程序提供了抽象层，使得程序可以统一使用不同平台上的 I/O 多路复用机制（如 <code>epoll</code>、<code>kqueue</code>、<code>select</code> 等），从而简化了开发工作，提升了可移植性。<code>libevent</code> 特别适合开发高性能的网络服务器、事件驱动的应用程序和实时系统。</p><h3 id="libevent-的特点："><code>libevent</code> 的特点：</h3><ol><li><strong>跨平台</strong>：支持 Linux、Windows、macOS 以及其他 Unix 系统。根据系统的特性，<code>libevent</code> 会自动选择最佳的 I/O 多路复用机制，如 <code>epoll</code>（Linux）、<code>kqueue</code>（BSD、macOS）、<code>select</code>（通用）等。</li><li><strong>事件驱动</strong>：提供基于事件的异步处理方式，支持 I/O、信号、定时器等多种事件源。</li><li><strong>高效的 I/O 多路复用</strong>：对于大量并发的 I/O 处理，<code>libevent</code> 能够利用高效的 I/O 多路复用机制，实现高效的事件分发。</li><li><strong>支持定时器和信号事件</strong>：除了 I/O 事件，<code>libevent</code> 还支持定时器事件和信号处理，使得它适用于更多类型的事件驱动应用。</li></ol><h3 id="libevent-的事件类型："><code>libevent</code> 的事件类型：</h3><p><code>libevent</code> 支持以下几种常见的事件类型：</p><ol><li><strong>I/O 事件</strong>：监听文件描述符上的读、写、异常事件（如套接字的连接、数据传输）。</li><li><strong>定时器事件</strong>：基于时间的事件处理，允许设置某个事件在一定时间后触发。</li><li><strong>信号事件</strong>：捕捉和处理系统信号（如 <code>SIGINT</code>、<code>SIGTERM</code>）。</li><li><strong>持久事件</strong>：事件触发后不会被自动移除，能够持续监听。</li></ol><h3 id="libevent-的基本使用步骤："><code>libevent</code> 的基本使用步骤：</h3><ol><li><p><strong>初始化事件基础结构</strong>：<br>在 <code>libevent</code> 中，首先要创建一个 <code>event_base</code>，它是管理和调度事件的核心结构体。</p></li><li><p><strong>创建事件</strong>：<br>通过 <code>event_new</code> 函数创建一个新的事件。事件可以是 I/O 事件、定时器事件或信号事件。</p></li><li><p><strong>添加事件到事件循环</strong>：<br>使用 <code>event_add</code> 将事件添加到事件循环中。</p></li><li><p><strong>启动事件循环</strong>：<br>调用 <code>event_base_dispatch</code> 或 <code>event_base_loop</code> 启动事件循环，程序会进入一个阻塞状态，等待事件触发。</p></li><li><p><strong>事件处理</strong>：<br>当事件触发时，<code>libevent</code> 调用关联的回调函数处理事件。</p></li><li><p><strong>清理</strong>：<br>在程序结束或不再需要事件时，可以使用 <code>event_free</code> 释放事件，并销毁 <code>event_base</code>。</p></li></ol><h3 id="libevent-的-API-介绍："><code>libevent</code> 的 API 介绍：</h3><h4 id="1-初始化事件基础结构">1. 初始化事件基础结构</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">event_base</span> *<span class="title">base</span> =</span> event_base_new();</span><br></pre></td></tr></table></figure><p><code>event_base_new()</code> 用来创建一个新的事件循环基础结构。<code>event_base</code> 是 <code>libevent</code> 的核心结构，用来管理所有的事件。</p><h4 id="2-创建事件">2. 创建事件</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">event</span> *<span class="title">ev</span> =</span> event_new(base, fd, EV_READ|EV_PERSIST, callback_fn, arg);</span><br></pre></td></tr></table></figure><p><code>event_new</code> 用于创建一个事件，指定要监听的文件描述符 <code>fd</code>、事件类型 <code>EV_READ</code>（可读事件）、回调函数 <code>callback_fn</code> 以及传递给回调的参数 <code>arg</code>。<code>EV_PERSIST</code> 表示事件是持久的，不会在触发后自动删除。</p><ul><li><strong>文件描述符</strong>：可以是套接字、文件或其他可以进行 I/O 操作的对象。</li><li><strong>事件类型</strong>：<ul><li><code>EV_READ</code>：监听文件描述符的读事件。</li><li><code>EV_WRITE</code>：监听写事件。</li><li><code>EV_PERSIST</code>：事件触发后不会移除，继续监听。</li></ul></li></ul><h4 id="3-添加事件到事件循环">3. 添加事件到事件循环</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">event_add(ev, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure><p><code>event_add</code> 将事件注册到事件循环中。第二个参数为超时时间，<code>NULL</code> 表示没有超时。</p><h4 id="4-启动事件循环">4. 启动事件循环</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">event_base_dispatch(base);</span><br></pre></td></tr></table></figure><p><code>event_base_dispatch</code> 开始事件循环，程序将阻塞在这里，直到有事件发生。</p><h4 id="5-事件处理">5. 事件处理</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">callback_fn</span><span class="params">(<span class="type">evutil_socket_t</span> fd, <span class="type">short</span> event, <span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">    <span class="comment">// 处理事件的逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>事件发生时，会调用 <code>callback_fn</code> 回调函数。参数 <code>fd</code> 是触发事件的文件描述符，<code>event</code> 是触发的事件类型（读、写等），<code>arg</code> 是传递的用户数据。</p><h4 id="6-清理资源">6. 清理资源</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">event_free(ev);</span><br><span class="line">event_base_free(base);</span><br></pre></td></tr></table></figure><p>当不再需要某个事件或事件循环时，可以通过 <code>event_free</code> 和 <code>event_base_free</code> 来释放资源。</p><h3 id="libevent-示例代码："><code>libevent</code> 示例代码：</h3><p>以下是一个使用 <code>libevent</code> 创建简单的 TCP 服务器的例子，能够处理客户端连接并回显客户端发送的数据。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;event2/event.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;event2/bufferevent.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;event2/buffer.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;event2/listener.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PORT 8080</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 回调函数：处理客户端发送的数据</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">echo_read_cb</span><span class="params">(<span class="keyword">struct</span> bufferevent *bev, <span class="type">void</span> *ctx)</span> &#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">    <span class="type">size_t</span> len = bufferevent_read(bev, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">    buf[len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Received message: %s\n&quot;</span>, buf);</span><br><span class="line">    <span class="comment">// 回显消息给客户端</span></span><br><span class="line">    bufferevent_write(bev, buf, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 回调函数：处理客户端连接关闭</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">echo_event_cb</span><span class="params">(<span class="keyword">struct</span> bufferevent *bev, <span class="type">short</span> events, <span class="type">void</span> *ctx)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (events &amp; BEV_EVENT_EOF) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Client disconnected.\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (events &amp; BEV_EVENT_ERROR) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Error on connection.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    bufferevent_free(bev);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 回调函数：处理新客户端连接</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">accept_conn_cb</span><span class="params">(<span class="keyword">struct</span> evconnlistener *listener, <span class="type">evutil_socket_t</span> fd, <span class="keyword">struct</span> sockaddr *addr, <span class="type">int</span> len, <span class="type">void</span> *ctx)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">event_base</span> *<span class="title">base</span> =</span> evconnlistener_get_base(listener);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bufferevent</span> *<span class="title">bev</span> =</span> bufferevent_socket_new(base, fd, BEV_OPT_CLOSE_ON_FREE);</span><br><span class="line">    bufferevent_setcb(bev, echo_read_cb, <span class="literal">NULL</span>, echo_event_cb, <span class="literal">NULL</span>);</span><br><span class="line">    bufferevent_enable(bev, EV_READ | EV_WRITE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">event_base</span> *<span class="title">base</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">evconnlistener</span> *<span class="title">listener</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">sin</span>;</span></span><br><span class="line"></span><br><span class="line">    base = event_base_new();  <span class="comment">// 创建事件基础结构</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;<span class="built_in">sin</span>, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="built_in">sin</span>));</span><br><span class="line">    <span class="built_in">sin</span>.sin_family = AF_INET;</span><br><span class="line">    <span class="built_in">sin</span>.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    <span class="built_in">sin</span>.sin_port = htons(PORT);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建监听器，监听客户端连接</span></span><br><span class="line">    listener = evconnlistener_new_bind(base, accept_conn_cb, <span class="literal">NULL</span>,</span><br><span class="line">                                       LEV_OPT_REUSEABLE | LEV_OPT_CLOSE_ON_FREE, <span class="number">-1</span>,</span><br><span class="line">                                       (<span class="keyword">struct</span> sockaddr*)&amp;<span class="built_in">sin</span>, <span class="keyword">sizeof</span>(<span class="built_in">sin</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!listener) &#123;</span><br><span class="line">        perror(<span class="string">&quot;Could not create listener&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 运行事件循环</span></span><br><span class="line">    event_base_dispatch(base);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放资源</span></span><br><span class="line">    evconnlistener_free(listener);</span><br><span class="line">    event_base_free(base);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="主要函数解析：">主要函数解析：</h3><ul><li><strong><code>event_base_new()</code></strong>：创建事件循环的基础结构。</li><li><strong><code>evconnlistener_new_bind()</code></strong>：创建一个监听器，用于接受客户端连接。</li><li><strong><code>bufferevent_socket_new()</code></strong>：为每个连接创建一个缓冲区事件（<code>bufferevent</code>），用于处理 I/O。</li><li><strong><code>bufferevent_setcb()</code></strong>：设置 I/O 事件的回调函数。</li><li><strong><code>event_base_dispatch()</code></strong>：启动事件循环，处理所有的 I/O 事件。</li></ul><h3 id="libevent-的优势："><code>libevent</code> 的优势：</h3><ol><li><strong>跨平台支持</strong>：自动根据操作系统选择最佳的 I/O 多路复用机制。</li><li><strong>简化并发处理</strong>：通过事件驱动模型处理多个客户端连接，无需手动创建线程或进程。</li><li><strong>支持多种事件类型</strong>：不仅支持 I/O 事件，还支持定时器和信号事件，适合各种事件驱动的应用。</li><li><strong>高性能</strong>：尤其适用于高并发场景，如网络服务器和实时系统。</li></ol><h3 id="应用场景：">应用场景：</h3><ul><li><strong>高并发网络服务器</strong>：如 Web 服务器、代理服务器。</li><li><strong>实时系统</strong>：需要同时处理大量 I/O 和定时器事件。</li><li><strong>分布式系统</strong>：处理多个节点的网络通信。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> c </tag>
            
            <tag> 网络编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>select和epoll</title>
      <link href="/post/e112f59a.html"/>
      <url>/post/e112f59a.html</url>
      
        <content type="html"><![CDATA[<h1>select</h1><p><code>select()</code> 是用于实现多路复用（I/O 多路复用）的系统调用，广泛应用于网络编程中。它允许服务器同时监听多个文件描述符（如套接字、文件或管道），并在这些文件描述符之一变为可读、可写或有错误时作出响应。这样可以避免为每个连接创建一个线程或进程，提升服务器并发性能。</p><h3 id="函数定义">函数定义</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">select</span><span class="params">(<span class="type">int</span> nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, <span class="keyword">struct</span> timeval *timeout)</span>;</span><br></pre></td></tr></table></figure><h3 id="参数解析：">参数解析：</h3><ol><li><p><strong><code>nfds</code></strong>：</p><ul><li>需要监听的文件描述符数量，即所有文件描述符中最大的值加 1。这个参数用于告诉内核需要监听的文件描述符范围。</li></ul></li><li><p><strong><code>readfds</code></strong>：</p><ul><li>一个指向 <code>fd_set</code> 结构的指针，代表要检查是否有<strong>可读</strong>事件的文件描述符集合。如果没有需要检查的描述符，传递 <code>NULL</code>。</li></ul></li><li><p><strong><code>writefds</code></strong>：</p><ul><li>一个指向 <code>fd_set</code> 结构的指针，代表要检查是否有<strong>可写</strong>事件的文件描述符集合。如果没有需要检查的描述符，传递 <code>NULL</code>。</li></ul></li><li><p><strong><code>exceptfds</code></strong>：</p><ul><li>一个指向 <code>fd_set</code> 结构的指针，代表要检查是否有<strong>异常</strong>事件的文件描述符集合，如带外数据。如果没有需要检查的描述符，传递 <code>NULL</code>。</li></ul></li><li><p><strong><code>timeout</code></strong>：</p><ul><li>用于设定 <code>select()</code> 的超时时间。可以是以下三种情况：<ul><li><code>NULL</code>：永远阻塞，直到某个文件描述符上有事件发生。</li><li>设定 <code>struct timeval</code> 值：设定阻塞的时间限制，超时后 <code>select()</code> 返回。</li><li><code>timeval</code> 结构中的值为 0：表示立即返回，非阻塞模式。</li></ul></li></ul></li></ol><h3 id="返回值：">返回值：</h3><ul><li><strong>成功</strong>：返回就绪的文件描述符的数量。</li><li><strong>失败</strong>：返回 <code>-1</code>，并设置 <code>errno</code>。</li><li><strong>超时</strong>：返回 <code>0</code>，表示在指定的时间内没有任何文件描述符变为可读、可写或发生异常。</li></ul><h3 id="核心数据结构-fd-set：">核心数据结构 <code>fd_set</code>：</h3><p><code>fd_set</code> 是一个位集合（bitmap），用于表示文件描述符的集合。</p><p>相关操作函数：</p><ul><li><strong><code>FD_ZERO(fd_set *set)</code></strong>：清空集合。</li><li><strong><code>FD_SET(int fd, fd_set *set)</code></strong>：将文件描述符 <code>fd</code> 添加到集合中。</li><li><strong><code>FD_CLR(int fd, fd_set *set)</code></strong>：从集合中移除文件描述符 <code>fd</code>。</li><li><strong><code>FD_ISSET(int fd, fd_set *set)</code></strong>：检查 <code>fd</code> 是否在集合中。</li></ul><h3 id="使用步骤：">使用步骤：</h3><ol><li>创建并初始化 <code>fd_set</code> 集合。</li><li>使用 <code>FD_SET()</code> 将需要监控的文件描述符加入集合。</li><li>调用 <code>select()</code> 进行事件监听。</li><li>检查 <code>select()</code> 返回的集合，确定哪些文件描述符已准备好进行 I/O 操作。</li></ol><h3 id="使用示例：">使用示例：</h3><p>以下是一个简单的服务器使用 <code>select()</code> 同时监听多个客户端连接的例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PORT 8080</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_CLIENTS 30</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> server_sock, client_sock, max_sd, sd, activity;</span><br><span class="line">    <span class="type">int</span> client_sockets[MAX_CLIENTS] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server_addr</span>, <span class="title">client_addr</span>;</span></span><br><span class="line">    fd_set readfds;</span><br><span class="line">    <span class="type">socklen_t</span> addrlen = <span class="keyword">sizeof</span>(client_addr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建套接字</span></span><br><span class="line">    server_sock = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (server_sock == <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;Socket creation failed&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    server_addr.sin_family = AF_INET;</span><br><span class="line">    server_addr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line">    server_addr.sin_port = htons(PORT);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定地址和端口</span></span><br><span class="line">    <span class="keyword">if</span> (bind(server_sock, (<span class="keyword">struct</span> sockaddr *)&amp;server_addr, <span class="keyword">sizeof</span>(server_addr)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;Bind failed&quot;</span>);</span><br><span class="line">        close(server_sock);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听连接</span></span><br><span class="line">    <span class="keyword">if</span> (listen(server_sock, <span class="number">3</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;Listen failed&quot;</span>);</span><br><span class="line">        close(server_sock);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Server is listening on port %d\n&quot;</span>, PORT);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 清空读描述符集合</span></span><br><span class="line">        FD_ZERO(&amp;readfds);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将服务器套接字加入集合</span></span><br><span class="line">        FD_SET(server_sock, &amp;readfds);</span><br><span class="line">        max_sd = server_sock;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将所有客户端套接字加入集合</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAX_CLIENTS; i++) &#123;</span><br><span class="line">            sd = client_sockets[i];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 有效的套接字则加入集合</span></span><br><span class="line">            <span class="keyword">if</span> (sd &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                FD_SET(sd, &amp;readfds);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 找到最大的文件描述符</span></span><br><span class="line">            <span class="keyword">if</span> (sd &gt; max_sd) &#123;</span><br><span class="line">                max_sd = sd;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 等待文件描述符上有活动</span></span><br><span class="line">        activity = select(max_sd + <span class="number">1</span>, &amp;readfds, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (activity &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;Select error&quot;</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查是否有新的客户端连接</span></span><br><span class="line">        <span class="keyword">if</span> (FD_ISSET(server_sock, &amp;readfds)) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((client_sock = accept(server_sock, (<span class="keyword">struct</span> sockaddr *)&amp;client_addr, &amp;addrlen)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                perror(<span class="string">&quot;Accept failed&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;New connection: socket fd is %d, IP is %s, port is %d\n&quot;</span>, client_sock,</span><br><span class="line">                   inet_ntoa(client_addr.sin_addr), ntohs(client_addr.sin_port));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将新连接加入客户端套接字数组</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAX_CLIENTS; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (client_sockets[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                    client_sockets[i] = client_sock;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;Adding client socket to list at index %d\n&quot;</span>, i);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查哪个客户端发送了数据</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAX_CLIENTS; i++) &#123;</span><br><span class="line">            sd = client_sockets[i];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (FD_ISSET(sd, &amp;readfds)) &#123;</span><br><span class="line">                <span class="type">char</span> buffer[<span class="number">1024</span>];</span><br><span class="line">                <span class="type">int</span> valread = read(sd, buffer, <span class="keyword">sizeof</span>(buffer));</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (valread == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 客户端关闭连接</span></span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;Client disconnected: socket fd %d\n&quot;</span>, sd);</span><br><span class="line">                    close(sd);</span><br><span class="line">                    client_sockets[i] = <span class="number">0</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 回显接收到的数据</span></span><br><span class="line">                    buffer[valread] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;Received from client: %s\n&quot;</span>, buffer);</span><br><span class="line">                    send(sd, buffer, <span class="built_in">strlen</span>(buffer), <span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="代码解读：">代码解读：</h3><ol><li><p><strong>创建和绑定服务器套接字</strong>：创建套接字后，绑定到指定的端口并开始监听客户端连接。</p></li><li><p><strong><code>fd_set</code> 处理</strong>：使用 <code>FD_SET</code> 将服务器套接字和客户端套接字添加到 <code>readfds</code> 集合中，表示我们关心这些套接字上的可读事件。</p></li><li><p><strong><code>select()</code> 调用</strong>：<code>select()</code> 会阻塞直到某个文件描述符有事件发生（即有可读、可写或异常事件），在这里我们只关心可读事件。</p></li><li><p><strong>处理新连接</strong>：如果服务器套接字上有事件发生，表示有新的客户端连接到来，我们通过 <code>accept()</code> 接收新的连接并将其加入客户端套接字数组中。</p></li><li><p><strong>处理客户端通信</strong>：遍历所有客户端套接字，使用 <code>FD_ISSET</code> 判断是否有客户端发送数据，如果有，则读取数据并回显给客户端。</p></li></ol><h3 id="优点：">优点：</h3><ul><li><strong>低开销</strong>：相比为每个客户端创建一个线程，<code>select()</code> 仅使用一个线程处理多个连接，减少了上下文切换的开销。</li><li><strong>跨平台性</strong>：<code>select()</code> 函数在几乎所有平台上都可用。</li></ul><h3 id="缺点：">缺点：</h3><ul><li><strong>文件描述符限制</strong>：<code>select()</code> 的文件描述符数量有限（通常是 1024），无法处理非常大量的连接。</li><li><strong>性能</strong>：对于大规模并发连接，<code>select()</code> 每次都需要遍历整个文件描述符集，性能不佳。</li></ul><p>在现代高并发场景中，<code>select()</code> 通常会被 <code>epoll</code> 或 <code>kqueue</code> 这些更高效的 I/O 多路复用机制替代，但 <code>select()</code> 仍然是一种经典且常用的技术。</p><h1>I/O多路复用</h1><p>I/O 多路复用（I/O Multiplexing）是一种允许程序同时监视多个 I/O 操作（如读写文件、网络套接字、管道等）的技术。当其中某个 I/O 操作准备好时，操作系统会通知程序执行相应的操作。这种机制使得一个线程或进程能够管理多个 I/O 通道，而不用为每个 I/O 操作创建单独的线程或进程。</p><h3 id="I-O-多路复用的背景：">I/O 多路复用的背景：</h3><p>通常情况下，I/O 操作（如读写网络、文件）是阻塞的，即如果一个程序尝试从某个套接字或文件中读取数据，而数据尚未到达，它将进入阻塞状态，直到数据到达为止。这种情况在服务器中尤为常见，服务器要处理多个客户端的连接，如果为每个客户端的 I/O 操作都创建一个线程，系统资源消耗巨大且效率低下。</p><p>I/O 多路复用可以解决这一问题，它允许程序在一个线程内管理多个 I/O 通道，并在某个通道有事件（如数据可读、可写等）时进行处理。</p><h3 id="I-O-多路复用的工作方式：">I/O 多路复用的工作方式：</h3><ol><li><strong>多个 I/O 通道</strong>：程序可以监听多个套接字、文件或其他类型的 I/O 通道。</li><li><strong>阻塞与非阻塞</strong>：通过 I/O 多路复用，程序可以避免阻塞在某个 I/O 操作上，而是监听所有通道，只有当某个通道有事件时才会处理，其他通道仍然可以继续监听。</li><li><strong>事件通知</strong>：I/O 多路复用会等待多个文件描述符上的事件（如读、写、异常），当其中之一就绪时，内核会通知程序，从而进行相应的读写操作。</li></ol><h3 id="常见的-I-O-多路复用机制：">常见的 I/O 多路复用机制：</h3><ol><li><p><strong><code>select</code></strong>：</p><ul><li>最早的多路复用机制，支持几乎所有操作系统。</li><li>每次调用 <code>select()</code> 时都需要重新初始化文件描述符集，效率相对较低。</li><li>文件描述符数量有限（通常是 1024），无法处理大量并发连接。</li></ul></li><li><p><strong><code>poll</code></strong>：</p><ul><li>和 <code>select()</code> 类似，但没有文件描述符数量的限制。</li><li>需要重新遍历整个文件描述符集，性能在大量连接情况下不佳。</li></ul></li><li><p><strong><code>epoll</code></strong>（Linux 特有）：</p><ul><li>专为高并发场景设计，效率远高于 <code>select</code> 和 <code>poll</code>。</li><li>采用事件驱动机制，事件就绪时才触发通知，避免了不必要的遍历。</li><li>适合处理大量并发连接，是现代 Linux 服务器常用的 I/O 多路复用方式。</li></ul></li><li><p><strong><code>kqueue</code></strong>（BSD 系统，包括 macOS）：</p><ul><li>类似于 <code>epoll</code>，支持高效的事件通知机制。</li><li>提供更多类型的事件监控（如文件系统事件、进程事件等）。</li></ul></li></ol><h3 id="I-O-多路复用的工作流程：">I/O 多路复用的工作流程：</h3><ol><li><p><strong>创建监听的文件描述符</strong>：</p><ul><li>通过 <code>socket()</code> 或其他方法创建多个文件描述符，如监听客户端连接的套接字。</li></ul></li><li><p><strong>注册 I/O 事件</strong>：</p><ul><li>使用多路复用机制（如 <code>select()</code>、<code>epoll</code> 或 <code>poll</code>）注册需要监听的文件描述符及其关注的事件（如可读、可写）。</li></ul></li><li><p><strong>等待事件发生</strong>：</p><ul><li>多路复用调用将阻塞，直到有事件发生或超时。</li></ul></li><li><p><strong>处理就绪的文件描述符</strong>：</p><ul><li>当某个文件描述符准备好（如某个套接字有数据可读），多路复用调用返回，程序可以处理该事件。</li></ul></li><li><p><strong>重复步骤 2-4</strong>，持续监听文件描述符并处理事件。</p></li></ol><h3 id="使用场景：">使用场景：</h3><p>I/O 多路复用特别适合用于需要处理大量并发 I/O 请求的场景。典型应用包括：</p><ul><li><strong>网络服务器</strong>：如 Web 服务器或数据库服务器，它们需要同时处理成百上千个客户端的连接请求，I/O 多路复用可以避免为每个连接创建一个线程或进程，节省系统资源。</li><li><strong>聊天服务器</strong>：聊天服务器需要同时处理多个客户端的消息发送和接收。</li><li><strong>高效日志系统</strong>：需要同时监视多个文件或设备的变化。</li></ul><h3 id="优点：-2">优点：</h3><ol><li><strong>高效</strong>：可以让一个线程同时监控多个 I/O 通道，避免了多线程或多进程带来的上下文切换开销。</li><li><strong>灵活性</strong>：可以同时监视多个不同类型的 I/O 设备（如网络、文件、管道）。</li></ol><h3 id="缺点：-2">缺点：</h3><ol><li><strong>复杂性</strong>：代码相对复杂，尤其是在处理高并发场景时，需要额外的逻辑来管理文件描述符。</li><li><strong>性能瓶颈</strong>：对于大量并发连接，<code>select</code> 和 <code>poll</code> 的效率会随着文件描述符数量的增加而下降，<code>epoll</code> 和 <code>kqueue</code> 能在高并发场景中表现更好。</li></ol><h3 id="总结：">总结：</h3><p>I/O 多路复用是一种关键技术，能够在单个线程或进程中同时处理多个 I/O 操作。通过 <code>select</code>、<code>poll</code> 或更高效的 <code>epoll</code> 和 <code>kqueue</code>，服务器可以高效处理多个客户端连接，尤其适用于高并发的网络服务。</p><h1>epoll</h1><p><code>epoll</code> 是 Linux 系统中用于 I/O 多路复用的高效机制，专门为大规模并发连接设计。与传统的 <code>select</code> 和 <code>poll</code> 相比，<code>epoll</code> 具有更好的性能和扩展性，特别是在处理大量文件描述符（如网络套接字）时。它采用事件驱动的模型，不需要像 <code>select</code> 和 <code>poll</code> 那样反复遍历整个文件描述符集，从而大幅提升了效率。</p><h3 id="epoll-的优点："><code>epoll</code> 的优点：</h3><ol><li><strong>高效的事件通知</strong>：<code>epoll</code> 使用事件驱动模式，当有事件发生时才通知应用程序，避免不必要的文件描述符遍历。</li><li><strong>支持大量文件描述符</strong>：相比于 <code>select</code> 的 1024 文件描述符限制，<code>epoll</code> 可以处理几乎无限数量的文件描述符，适用于大规模并发场景。</li><li><strong>边缘触发（Edge-triggered）与水平触发（Level-triggered）</strong>：<code>epoll</code> 提供两种事件通知模式，边缘触发适合高效、非阻塞的 I/O 操作，而水平触发则更加传统。</li></ol><h3 id="epoll-的工作原理："><code>epoll</code> 的工作原理：</h3><p><code>epoll</code> 是基于内核的事件通知机制，包含三个核心操作：</p><ol><li><strong><code>epoll_create</code></strong>：创建一个 <code>epoll</code> 实例，用于管理文件描述符。</li><li><strong><code>epoll_ctl</code></strong>：向 <code>epoll</code> 实例中添加、修改或删除文件描述符，指定关注的事件类型（如可读、可写、异常）。</li><li><strong><code>epoll_wait</code></strong>：等待事件的发生，当某个文件描述符有事件（如数据到达）时，内核会通知应用程序，返回该文件描述符列表。</li></ol><h3 id="epoll-函数原型："><code>epoll</code> 函数原型：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">epoll_create1</span><span class="params">(<span class="type">int</span> flags)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">epoll_ctl</span><span class="params">(<span class="type">int</span> epfd, <span class="type">int</span> op, <span class="type">int</span> fd, <span class="keyword">struct</span> epoll_event *event)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">epoll_wait</span><span class="params">(<span class="type">int</span> epfd, <span class="keyword">struct</span> epoll_event *events, <span class="type">int</span> maxevents, <span class="type">int</span> timeout)</span>;</span><br></pre></td></tr></table></figure><ol><li><p><strong><code>epoll_create1(int flags)</code></strong>：创建一个 <code>epoll</code> 实例，返回一个文件描述符。</p><ul><li><code>flags</code>：可以为 <code>0</code> 或者 <code>EPOLL_CLOEXEC</code>（在 <code>fork()</code> 后关闭文件描述符）。</li><li>返回值：如果成功，返回 <code>epoll</code> 实例的文件描述符；失败返回 <code>-1</code>。</li></ul></li><li><p><strong><code>epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)</code></strong>：对 <code>epoll</code> 实例进行控制操作，添加、修改或删除监听的文件描述符。</p><ul><li><code>epfd</code>：<code>epoll</code> 实例的文件描述符。</li><li><code>op</code>：控制操作类型，可以是以下三种：<ul><li><code>EPOLL_CTL_ADD</code>：向 <code>epoll</code> 实例中添加文件描述符。</li><li><code>EPOLL_CTL_MOD</code>：修改已经在 <code>epoll</code> 实例中的文件描述符的事件类型。</li><li><code>EPOLL_CTL_DEL</code>：从 <code>epoll</code> 实例中删除文件描述符。</li></ul></li><li><code>fd</code>：要监听的文件描述符。</li><li><code>event</code>：指定监听的事件类型。</li></ul></li><li><p><strong><code>epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout)</code></strong>：等待 <code>epoll</code> 实例中注册的事件发生。</p><ul><li><code>epfd</code>：<code>epoll</code> 实例的文件描述符。</li><li><code>events</code>：用于存储返回的事件列表。</li><li><code>maxevents</code>：一次可以返回的最大事件数。</li><li><code>timeout</code>：等待的超时时间，单位为毫秒；<code>-1</code> 表示阻塞等待，<code>0</code> 表示立即返回。</li></ul></li></ol><h3 id="epoll-event-结构体："><code>epoll_event</code> 结构体：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> &#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> events;    <span class="comment">// 事件类型，例如 EPOLLIN, EPOLLOUT</span></span><br><span class="line">    <span class="type">epoll_data_t</span> data;  <span class="comment">// 用户数据，可以用来存储文件描述符</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong><code>events</code></strong>：指定文件描述符上监听的事件，如 <code>EPOLLIN</code>（可读）、<code>EPOLLOUT</code>（可写）、<code>EPOLLERR</code>（错误）、<code>EPOLLET</code>（边缘触发）。</li><li><strong><code>data</code></strong>：用于存储用户数据，通常存储文件描述符。</li></ul><h3 id="epoll-触发模式："><code>epoll</code> 触发模式：</h3><ol><li><p><strong>水平触发（Level-triggered, LT）</strong>：</p><ul><li>这是 <code>epoll</code> 的默认模式，类似于 <code>select</code> 和 <code>poll</code>，当文件描述符准备好后，每次调用 <code>epoll_wait</code> 都会返回该事件，直到事件被处理完。</li><li>使用简单，适合大部分场景。</li></ul></li><li><p><strong>边缘触发（Edge-triggered, ET）</strong>：</p><ul><li>边缘触发模式只在状态从不可用到可用时触发事件。换句话说，如果数据已经可读，再次调用 <code>epoll_wait</code> 时不会通知，除非有新的数据到达。</li><li>边缘触发更高效，减少了重复通知的次数，但编程更复杂，要求必须使用非阻塞 I/O。</li></ul></li></ol><h3 id="epoll-使用步骤："><code>epoll</code> 使用步骤：</h3><ol><li><p><strong>创建 <code>epoll</code> 实例</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> epfd = epoll_create1(<span class="number">0</span>);</span><br></pre></td></tr></table></figure></li><li><p><strong>注册文件描述符</strong>：<br>使用 <code>epoll_ctl</code> 将需要监听的文件描述符注册到 <code>epoll</code> 实例中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">ev</span>;</span></span><br><span class="line">ev.events = EPOLLIN;  <span class="comment">// 监听可读事件</span></span><br><span class="line">ev.data.fd = listen_fd;  <span class="comment">// 文件描述符</span></span><br><span class="line">epoll_ctl(epfd, EPOLL_CTL_ADD, listen_fd, &amp;ev);</span><br></pre></td></tr></table></figure></li><li><p><strong>等待事件</strong>：<br>调用 <code>epoll_wait</code> 等待文件描述符上发生的事件。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">events</span>[10];</span></span><br><span class="line"><span class="type">int</span> nfds = epoll_wait(epfd, events, <span class="number">10</span>, <span class="number">-1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nfds; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (events[i].events &amp; EPOLLIN) &#123;</span><br><span class="line">        <span class="comment">// 处理可读事件</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="epoll-示例代码："><code>epoll</code> 示例代码：</h3><p>下面是一个使用 <code>epoll</code> 的简单服务器程序，它可以监听多个客户端连接，并处理客户端发送的数据。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PORT 8080</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_EVENTS 10</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> listen_fd, conn_fd, epfd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server_addr</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">ev</span>, <span class="title">events</span>[<span class="title">MAX_EVENTS</span>];</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建监听套接字</span></span><br><span class="line">    listen_fd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    server_addr.sin_family = AF_INET;</span><br><span class="line">    server_addr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line">    server_addr.sin_port = htons(PORT);</span><br><span class="line"></span><br><span class="line">    bind(listen_fd, (<span class="keyword">struct</span> sockaddr *)&amp;server_addr, <span class="keyword">sizeof</span>(server_addr));</span><br><span class="line">    listen(listen_fd, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建 epoll 实例</span></span><br><span class="line">    epfd = epoll_create1(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (epfd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;epoll_create1&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加监听套接字到 epoll</span></span><br><span class="line">    ev.events = EPOLLIN;</span><br><span class="line">    ev.data.fd = listen_fd;</span><br><span class="line">    <span class="keyword">if</span> (epoll_ctl(epfd, EPOLL_CTL_ADD, listen_fd, &amp;ev) == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;epoll_ctl: listen_fd&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">int</span> nfds = epoll_wait(epfd, events, MAX_EVENTS, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nfds; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (events[i].data.fd == listen_fd) &#123;</span><br><span class="line">                <span class="comment">// 新客户端连接</span></span><br><span class="line">                conn_fd = accept(listen_fd, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">                ev.events = EPOLLIN;</span><br><span class="line">                ev.data.fd = conn_fd;</span><br><span class="line">                epoll_ctl(epfd, EPOLL_CTL_ADD, conn_fd, &amp;ev);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;New connection accepted\n&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 处理客户端发送的数据</span></span><br><span class="line">                <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">                <span class="type">int</span> len = read(events[i].data.fd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">                <span class="keyword">if</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    buf[len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;Received: %s\n&quot;</span>, buf);</span><br><span class="line">                    write(events[i].data.fd, buf, len);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    close(events[i].data.fd);</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;Client disconnected\n&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(listen_fd);</span><br><span class="line">    close(epfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="epoll-与-select-的对比："><code>epoll</code> 与 <code>select</code> 的对比：</h3><table><thead><tr><th>特性</th><th><code>select</code></th><th><code>epoll</code></th></tr></thead><tbody><tr><td>文件描述符限制</td><td>最大 1024 个（可调整）</td><td>文件描述符几乎无限制</td></tr><tr><td>事件处理模式</td><td>每次调用都要遍历整个集合</td><td>只处理有事件的文件</td></tr></tbody></table>]]></content>
      
      
      
        <tags>
            
            <tag> c </tag>
            
            <tag> 网络编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity-NGUI之基础及组合控件</title>
      <link href="/post/f24ad560.html"/>
      <url>/post/f24ad560.html</url>
      
        <content type="html"><![CDATA[<img src="../../../img/Unity/NGUI_Root_缩放模式设置.bmp" width="70%" height="50%"><h1>基础控件</h1><h2 id="Sprite">Sprite</h2><h3 id="Sprite作用">Sprite作用</h3><p>NGUI中所有中小尺寸图片显示都用Sprite显示<br>使用它来显示图集中的单个图片资源</p><h3 id="创建Sprite">创建Sprite</h3><ul><li>Scene窗口红框内右键</li><li>上方工具栏<strong>NGUI</strong>中创建</li></ul><h3 id="Sprite参数">Sprite参数</h3><p>略</p><h3 id="代码设置图片">代码设置图片</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.改变为当前图集中选择的图片</span></span><br><span class="line">sprite.spriteName = <span class="string">&quot;bk&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.改变为其它图集中的图片</span></span><br><span class="line"><span class="comment">//先加载图集</span></span><br><span class="line">NGUIAtlas atlas = Resources.Load&lt;NGUIAtlas&gt;(<span class="string">&quot;Atlas/login&quot;</span>);</span><br><span class="line">sprite.atlas = atlas;</span><br><span class="line"><span class="comment">//再设置图片</span></span><br><span class="line">sprite.spriteName = <span class="string">&quot;ui_DL_anniuxiao_01&quot;</span>;</span><br></pre></td></tr></table></figure><h2 id="Label">Label</h2><ul><li>文本(支持富文本)</li></ul><h2 id="Texture">Texture</h2><ul><li>一般图片，不能放到atlas 中的图片</li></ul><h1>组合控件</h1><h2 id=""></h2>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OS-存储器管理</title>
      <link href="/post/3d04630d.html"/>
      <url>/post/3d04630d.html</url>
      
        <content type="html"><![CDATA[<p>存储管理是指存储器资源（主要指内存并涉及外存）的管理。</p><ul><li><strong>存储器资源的组织</strong>（如内存的组织方式）</li><li><strong>地址变换</strong>（逻辑地址与物理地址的对应关系维护）</li><li><strong>虚拟存储的调度算法</strong></li></ul><h1>存储管理的功能</h1><ol><li><strong>主存分配和回收</strong><br>分配和回收算法及相应的数据结构。</li><li><strong>地址变换</strong><ul><li>可执行文件生成中的链接技术</li><li>程序加载(装入)时的重定位技术</li><li>进程运行时硬件和软件的地址变换技术和机构</li></ul></li><li><strong>存储共享和保护</strong><ul><li>代码和数据共享</li><li>地址空间访问权限（读、写、执行）</li></ul></li><li><strong>主存容量扩充</strong>(存储器的逻辑组织和物理组织)<ul><li>由应用程序控制：覆盖；</li><li>由OS控制：交换（整个进程空间），虚拟存储的请求调入和预调入（部分进程空间）</li><li>提高主存利用率</li></ul></li></ol><h1>程序的装入和链接</h1><h2 id="程序的装入-重定位-地址映射">程序的装入(重定位)(地址映射)</h2><h3 id="重定位">重定位</h3><ul><li><strong>重定位</strong>: 程序运行装入主存时，要将程序中的虚拟地址转换为主存中的物理地址，这个转化过程就是重定位。</li><li>程序成为进程前的准备工作:<ul><li><strong>编辑</strong>：形成源文件(符号地址)</li><li><strong>编译</strong>：形成目标模块(模块内符号地址解析)</li><li><strong>链接</strong>：由多个目标模块或程序库生成可执行文件(模块间符号地址解析)</li><li><strong>装入</strong>：构造PCB，形成进程(使用物理地址)</li></ul></li></ul><h3 id="重定位方法">重定位方法</h3><h4 id="可重定位装入-静态重定位">可重定位装入(静态重定位)</h4><ul><li>内容<ul><li>编写程序时可以采用相对地址</li><li>作业（用户程序）在装入内存时才确定它的物理地址，并且将相对地址转换为物理地址</li><li>作业一旦装入就不能移动、改变空间或者被换出主存。</li><li>在程序运行之前，由<strong>链接</strong>装入程序进行的一次重定位。</li><li>在程序运行之前已经<strong>完成了逻辑地址到物理地址的转换</strong>(只要完成链接装入)</li></ul></li><li>优点：<strong>不需硬件变换机构</strong>支持，可以装入有限多道程序</li><li>缺点：一个程序通常需要占用连续的内存空间，程序装入内存后<strong>在运行期间不能移动</strong>，不易实现共享。</li></ul><h4 id="动态运行时装入-动态重定位">动态运行时装入(动态重定位)</h4><ul><li>内容<ul><li>动态重定位是在程序<strong>执行的过程</strong>中，每当访问指令或数据时，才将要访问的<strong>指令或数据</strong>的<strong>逻辑地址转换成物理地址</strong>。</li><li>在程序<strong>装入时不对地址做任何操作</strong>，也就是保留逻辑地址不变。</li><li><strong>运行时重定位</strong>：可以使程序载入后还可以移动</li><li>每个进程有各自的<strong>基地址,放在PCB</strong></li></ul></li></ul><h1>连续分配方式</h1><h2 id="分配方式">分配方式</h2><ul><li><p><strong>固定分区</strong>: 把内存划分为若干个固定大小的连续分区。</p><ul><li>分区大小可以相等也可以不同</li><li><strong>固定分区可能存在内碎片</strong></li><li>系统通过<strong>分区说明表</strong>对内存进行管理和控制。</li></ul></li><li><p><strong>动态分区</strong>：在装入程序时按其初始要求分配，或在其执行过程中通过系统调用进行分配或改变分区大小。</p><ul><li>没有内碎片；有外碎片，如果大小不是任意的，也可能出现内碎片。</li><li><strong>内存紧缩</strong>：将空闲分区合并，需要移动多个段(复制内容)：</li></ul></li></ul><h2 id="分区分配数据结构">分区分配数据结构</h2><h3 id="空闲分区表">空闲分区表</h3><ul><li>用于为内存中每个<strong>尚未分配</strong>的分区设置一个表项，每个分区的表项包含<strong>分区序号</strong>、<strong>分区始址</strong>及<strong>分区大小</strong>；</li></ul><h3 id="空闲分区链">空闲分区链</h3><ul><li>通过前、后向指针将所有的分区链接成一个双向链</li></ul><h2 id="分区分配算法">分区分配算法</h2><h3 id="首次适应算法FF">首次适应算法FF</h3><ol><li>内容<br>内存分配时，从<strong>链首开始顺序查找</strong>，直至找到一个能满足其大小要求的空闲分区为止。然后按作业大小划出一块内存空间分配给请求者，余下的空闲分区仍留在空闲链中。</li><li>优点<ul><li>优先利用内存中<strong>低址</strong>部分的空闲分区，在<strong>高址</strong>部分的空闲分区很少被利用，从而保留了高址部分的大空闲区，为后到的大作业分配大的内存空间创造了条件。</li></ul></li><li>缺点<ul><li><strong>低址部分不断被划分</strong>，形成碎片；</li><li>每次查找都从低址部分开始，这<strong>增加了查找可用空闲分区的开销</strong>。</li></ul></li></ol><h3 id="循环首次适应算法">循环首次适应算法</h3><ol><li>内容<ul><li>内存分配时，从<strong>上次找到的空闲分区的下一个空闲分区</strong>开始查找，直至找到第一个能满足要求的空闲分区，并从中划出一块与请求的大小相等的内存空间分配给作业</li><li>设置一起始查寻指针，并采用<strong>循环查找</strong>方式。</li></ul></li><li>优点<ul><li>使内存中的空闲分区分布得更均匀</li><li>减少查找空闲分区的开销</li></ul></li><li>缺点<ul><li>缺乏大的空闲分区</li></ul></li></ol><h3 id="最佳适应算法">最佳适应算法</h3><ol><li>内容<ul><li>“最佳”是指每次为作业分配内存时，总把<strong>既能满足要求</strong>、<strong>又是最小</strong>的空闲分区分配给作业，避免了“大材小用”。</li><li>为了加速寻找，该算法要求将所有的空闲区，<strong>按其大小以递增</strong>的顺序形成<strong>空闲区链</strong>。</li></ul></li></ol><h2 id="分区分配和回收操作">分区分配和回收操作</h2><h3 id="动态分区分配内存">动态分区分配内存</h3><blockquote><ul><li>首先系统要利用某种分配算法，从空闲分区链(表)中找到所需的分区;</li><li>设<strong>请求的分区大小为u.size</strong>，表中每个空闲分区的大小可表示为m.size;</li><li>if(<strong>m.size-u.size&lt;=size</strong>)<br>- // size是事先规定的不再切割的剩余分区的大小<br>- 说明多余部分太小,可不再切割，<strong>将整个分区分配给请求者</strong>;</li><li>else<br>- 从该分区中划分出与请求的大小相等的内存空间分配出去，余下的部分仍留在空闲分区链或空闲分区表中。最后，将分配区的首址返回给调用者;</li></ul></blockquote><h3 id="回收内存">回收内存</h3><h4 id="内存紧缩">内存紧缩</h4><ul><li>内容：将各个占用分区向内存一端移动。使各个空闲分区聚集在另一端，然后将各个空闲分区合并成为一个空闲分区。</li><li>这过程涉及到了<strong>动态重定位</strong></li><li>紧缩时机：每个分区释放后，或内存分配找不到满足条件的空闲分区时</li></ul><h3 id="可重定位分区分配-增加了内存紧凑">可重定位分区分配(增加了内存紧凑)</h3><img src="..\..\img\OS\动态重定位分区分配算法.png" width="50%" height="70%" align="middle"><h2 id="对换">对换</h2><h3 id="对换的定义">对换的定义</h3><ul><li>指把内存中<strong>暂时不能运行的进程</strong>或者<strong>暂时不用的程序和数据</strong>，调出到<strong>外存</strong>上，以便腾出足够的内存空间，再把已具备运行条件的进程或进程所需要的程序和数据，调入内存</li><li>对换是提高内存利用率的有效措施</li><li>整体对换(进程对换): 对换是以整个进程为单位</li><li>部分对换(页面对换/分段对换): 对换是以“<strong>页</strong>”或“<strong>段</strong>”为单位进行</li><li>为了实现进程对换，系统必须能实现三方面的功能：<ul><li>对换空间的管理</li><li>进程的换出</li><li>进程的换入</li></ul></li></ul><h3 id="对换空间的管理">对换空间的管理</h3><ul><li>数据结构: 空闲分区表或空闲分区链</li><li><strong>空闲分区表</strong>中的每个表目中应<strong>包含两项</strong>， 即<strong>对换区</strong>的<strong>首址</strong>及其<strong>大小</strong>，它们的单位是<strong>盘块号</strong>和<strong>盘块数</strong>。</li></ul><blockquote><p><strong>外存空间分类</strong><br><strong>文件区</strong>：用于<strong>存放文件</strong>，由于通常的文件都是较长久地驻留在外存上，故对文件区管理的主要目标是<strong>提高文件存储空间的利用率</strong>，为此系统采取<strong>离散分配</strong>方式。<br><strong>对换区</strong>：用于<strong>存放从内存换出的进程</strong>，由于这些进程在对换区中驻留的时间是短暂的，而对换操作又较频繁，故对对换空间管理的主要目标是<strong>提高进程的换入、换出速度</strong>，为此所应采取的管理策略是<strong>用连续分配方式</strong>，较少考虑外存中的碎片问题。</p></blockquote><h3 id="进程的换出与换入">进程的换出与换入</h3><h4 id="进程的换出">进程的换出</h4><ul><li>每一进程由于创建子进程而需要更多的内存空间，但又无足够的内存空间等情况发生时，系统应将某进程换出</li><li>换出过程:<ul><li>系统首先选择处于<strong>阻塞状态</strong>且<strong>优先级最低</strong>的进程作为换出进程;</li><li>启动盘块，将该进程的程序和数据传送到磁盘的对换区上;</li><li>若传送过程未出现错误，便可<strong>回收该进程所占用的内存空间</strong>，并对该进程的PCB做相应的修改。</li></ul></li></ul><h4 id="进程的换入">进程的换入</h4><ul><li>系统应<strong>定时地查看</strong>所有进程的状态;</li><li>从中找出“<strong>就绪</strong>”状态但已换出的进程，将其中<strong>换出时间(换出到磁盘上)最久的进程</strong>作为换入进程，将之换入;</li><li>直至已无可换入的进程或无可换出的进程为止。</li></ul><h1>离散分配方式</h1><ul><li>思想：将<strong>一个进程</strong>直接<strong>分散地分配到许多不相邻接的分区中</strong>，就不必再进行“紧凑”。</li><li>离散分配种类：<ul><li>分页存储管理</li><li>分段存储管理</li><li>段页式存储管理</li></ul></li></ul><h1>基本分页存储管理方式</h1><h2 id="页面和物理块">页面和物理块</h2><ul><li><strong>页面</strong>:<ul><li>将一个进程的<strong>逻辑地址空间</strong>分成若干个<strong>大小相等</strong>的片，称为<strong>页面</strong>或<strong>页</strong>，并为各页加以编号，从0开始，如第0页、第1页等。</li></ul></li><li><strong>物理块(页框)</strong>:<ul><li>把<strong>内存空间</strong>分成与<strong>页面相同大小</strong>的若干个存储块</li></ul></li><li>分配时<strong>主存块可以不连续</strong>; 而<strong>页内逻辑地址是连续的</strong></li><li><strong>分页存储器的逻辑地址</strong>: 页号和页内地址(位移量)<ul><li>假设地址总长度为15位，其中页号占5位，页内地址占10位;那么逻辑地址可有32页，编号为0－31;页内地址占10位，则块的大小为1024个字节。编号为0－1023。</li><li>若给定一个逻辑地址空间中的地址为A，页面的大小为L，则页号P和页内地址d可按下式求得:</li></ul><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>P</mi><mo>=</mo><mi>I</mi><mi>N</mi><mi>T</mi><mo stretchy="false">[</mo><mi>A</mi><mi mathvariant="normal">/</mi><mi>L</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">P=INT[A/L]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mord mathnormal" style="margin-right:0.13889em;">NT</span><span class="mopen">[</span><span class="mord mathnormal">A</span><span class="mord">/</span><span class="mord mathnormal">L</span><span class="mclose">]</span></span></span></span></span></p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>d</mi><mo>=</mo><mi>A</mi><mi>m</mi><mi>o</mi><mi>d</mi><mo stretchy="false">(</mo><mi>L</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">d=A mod(L)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">d</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">A</span><span class="mord mathnormal">m</span><span class="mord mathnormal">o</span><span class="mord mathnormal">d</span><span class="mopen">(</span><span class="mord mathnormal">L</span><span class="mclose">)</span></span></span></span></span></p></li></ul><h2 id="页表-地址变换机构">页表(地址变换机构)</h2><ul><li><p>作用：实现<strong>逻辑地址</strong>到<strong>物理地址</strong>的转换(将<strong>逻辑地址中的页号</strong>转换为<strong>内存中的物理块号</strong>)</p></li><li><p>地址转换的公式为：<strong>绝对地址＝块号*块长+页内地址</strong><br><img src="..\..\img\OS\页表变换地址.png" width="50%" height="70%" align="middle"></p></li><li><p>页表控制寄存器–系统中只有一个</p></li></ul><h2 id="引入快表-TLB-的地址变换机构">引入快表(TLB)的地址变换机构</h2><ul><li>引入原因：由于页表是存放在内存中的，这使CPU每次要存取一个数据时，都要两次访问内存。<ul><li>第一次是访问内存中的<strong>页表</strong>，从中找到该页的物理块号，将此块号与页内偏移量w拼接以形成物理地址</li><li>第二次访问内存时，才是从第一步所得地址中<strong>获得所需数据</strong>(或向此地址中写入数据)</li></ul></li><li>TLB是一组相联快速存储，是寄存器，类似<strong>Cache</strong></li><li><em><em>有效访问时间 = HitR</em>(TLB+MA) + (1-HitR)*(TLB+2MA)</em>*</li><li>原理：<ul><li>程序的地址访问存在局部性</li><li>空间局部性(程序多体现为循环、顺序结构)<br><img src="..\..\img\OS\具有块表的页表地址变换.png" width="50%" height="70%" align="middle"></li></ul></li></ul><h2 id="两级和多级页表">两级和多级页表</h2><ul><li>引入原因: 现代的大多数计算机系统，都支持非常大的逻辑地址空间。在这样的环境下，页表就变得非常大，要占用相当大的内存空间。并且为连续的。</li><li>解决方法：<ul><li>采用<strong>离散分配方式</strong>来解决难以找到一块连续的大内存空间的问题；</li><li>将<strong>当前需要的部分页表项调入内存</strong>，其余的<strong>页表项驻留在磁盘上</strong>，需要时再调入</li></ul></li></ul><h3 id="两级页表">两级页表</h3><ul><li>将页表也进行分页的办法，使每个页面的大小与内存物理块的大小相同，并为它们进行编号，即依次为0页，1页，…，n页。可以离散地将各个页面分别放在不同的物理块中</li><li>外层页表：为离散分配的页表再建立一张页表，称为外层页表(Outer Page Table)，在每个页表项中记录了页表页面的物理块号。</li></ul><h1>基本分段存储管理方式</h1><ul><li>引入：为了满足用户和程序员的下述一系列需要：<ul><li><strong>方便编程</strong>：通常采用分段，汇编。。。</li><li><strong>信息共享</strong>：通常，在实现程序和数据的共享时，都是以信息的逻辑单位为基础的；<ul><li>比如，共享某个例程和函数。而在分页系统中的每一页都只是存放信息的物理单位，其本身并无完整的意义，因而不便于实现信息共享；然而段却是信息的逻辑单位。</li></ul></li><li><strong>信息保护</strong></li><li><strong>动态增长</strong></li><li><strong>动态链接</strong></li></ul></li></ul><h2 id="分段">分段</h2><ul><li>内容：<ul><li>作业的地址空间被划分为若干个段，每个段定义了一组逻辑信息。</li><li>将程序的地址空间划分为若干个段(segment)，程序加载时，分配其所需的所有段（内存分区），这些段不必连续；物理内存的管理采用动态分区。需要CPU的硬件支持。</li></ul></li><li>优点：<ul><li>没有内碎片，外碎片可以通过内存紧缩来消除</li><li>便于改变进程占用空间的大小</li></ul></li></ul><h2 id="段表">段表</h2><p>段表实现从逻辑段到物理内存区的映射。<br><img src="..\..\img\OS\段表变换地址.png" width="50%" height="70%" align="middle"></p><h2 id="分页和分段的主要区别">分页和分段的主要区别</h2><h3 id="相同点">相同点</h3><ul><li>都采用离散分配方式；</li><li>都要通过地址映射机构来实现地址变换</li></ul><h3 id="不同点">不同点</h3><ul><li><strong>分页是出于系统管理</strong>的需要，<strong>分段是出于用户应用</strong>的需要<ul><li>一条指令或一个操作数可能会跨越两个页的分界处，而不会跨越两个段的分界处。</li></ul></li><li>页大小是系统固定的，而段大小则通常不固定</li><li><strong>逻辑地址表示</strong>：<ul><li>分页是一维的，各个模块在链接时必须组织成同一个地址空间；</li><li>分段是二维的，各个模块在链接时可以每个段组织成一个地址空间</li></ul></li><li>通常<strong>段比页大</strong>，因而段表比页表短，可以缩短查找时间，提高访问速度。</li><li>分页系统能有效地<strong>提高内存利用率</strong>，而分段系统则能很好地<strong>满足用户需要</strong>。</li></ul><h1>段页式存储管理方式</h1><h2 id="优点：">优点：</h2><ul><li>段页式既具有分段系统<strong>便于实现、分段可共享、易于保护、可动态链接</strong>等一系列优点；</li><li>也具有分页系统那样很好地<strong>解决内存的外部碎片问题</strong>，以及为各个分段<strong>可离散地</strong>分配内存等问题</li></ul><h2 id="基本原理">基本原理</h2><p>把用户程序分成若干段，再把每个段分成若干页<br><img src="..\..\img\OS\段页式地址变换.png" width="50%" height="70%" align="middle"></p><ul><li>在段页式系统中，为了获取一条指令或数据，须3次访问内存。<ul><li>第一次：访问内存中的段表，从中取得页表地址；</li><li>第二次：访问内存中的页表，从中取出该页所在的物    理块号，同时和页内地址相加求出物理地址；</li><li>第三次：从地址中取出指令或数据；</li></ul></li></ul><h1>虚拟存储器的基本概念</h1><ul><li>引入原因：<ul><li>作业很大：<br>其所要求的内存空间超过了内存总容量，作业不能全部被装入内存，致使该作业无法运行；</li><li>大量作业要求运行：<br>但由于内存容量不足以容纳所有这些作业，只能将少数作业装入内存让它们先运行，而将其它大量的作业留在外存上等待。</li></ul></li><li>解决方法：<ul><li>从<strong>物理上</strong>增加内存容量。</li><li>从<strong>逻辑上</strong>扩充内存容量。这正是<strong>虚拟存储技术</strong>所要解决的主要问题。</li></ul></li></ul><h2 id="定义">定义</h2><ul><li>所谓<strong>虚拟存储器</strong>，是指具有<strong>请求调入功能</strong>和<strong>置换功能</strong>，能从<strong>逻辑上</strong>对<strong>内存容量加以扩充</strong>的一种存储器系统。</li><li>其<strong>逻辑容量</strong>受限于计算机的<strong>地址结构</strong>和<strong>可用磁盘容量</strong>，其运行速度<strong>接近于内存速度</strong>。</li></ul><h2 id="基本原理-2">基本原理</h2><ul><li>在程序装入时，不必将其全部读入到内存，而只需<strong>将当前需要执行的部分页或段读入到内存</strong>，就可让程序开始执行。</li><li>在程序执行过程中，如果需执行的指令或访问的数据尚未在内存（称为<strong>缺页或缺段</strong>），则由处理器通知操作系统将相应的页或段<strong>调入到内存</strong>，然后继续执行程序。</li><li>另一方面，操作系统将内存中<strong>暂时不使用的页或段调出保存在外存</strong>上，从而腾出空间存放将要装入的程序以及将要调入的页或段。只需程序的一部分在内存就可执行。</li></ul><h2 id="优点">优点</h2><ul><li><strong>大程序</strong>：可在较小的可用内存中执行较大的用户程序；</li><li><strong>大的用户空间</strong>：提供给用户可用的虚拟内存空间通常大于物理内存(real memory)</li><li><strong>并发</strong>：可在内存中容纳更多程序并发执行；</li><li><strong>易于开发</strong>：与覆盖技术比较，不必影响编程时的程序结构</li></ul><h2 id="实现方式">实现方式</h2><ul><li>虚拟存储器的实现，是建立在<strong>离散分配</strong>的存储管理方式基础上</li><li>常见方法有：<ul><li>分页请求系统</li><li>分段请求系统</li></ul></li></ul><h1>请求分页存储管理方式</h1><h1>页面置换算法</h1><h1>请求分段存储管理方式</h1>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OS-进程管理</title>
      <link href="/post/18614213.html"/>
      <url>/post/18614213.html</url>
      
        <content type="html"><![CDATA[<h1>进程的描述与控制</h1><h2 id="程序的顺序执行及其特征">程序的顺序执行及其特征</h2><p>程序顺序执行时的特征:</p><ul><li><strong>顺序性</strong>: 按照程序结构所指定的次序</li><li><strong>封闭性</strong>: 运行时候独占处理机资源，运行结果不受外界影响</li><li><strong>可再现性</strong>: 初始条件相同，结果相同</li></ul><h2 id="程序的并发执行及其特征">程序的并发执行及其特征</h2><p><strong>定义</strong>：程序的并发执行是指一组在逻辑上互相独立的程序或程序段在执行时间上客观上互相重叠，即一个程序或程序段的执行尚未结束，另一个程序（段）的执行已经开始的执行方式<br>程序并发执行时的特征:</p><ul><li><strong>间断性(相互制约性)</strong>:－ “走走停停”，一个程序可能走到中途停下来，失去原有的时序关系；</li><li><strong>失去封闭性</strong>：多个程序共享系统中的各种资源，因而这些资源的状态将由多个程序来改变, 致使程序的运行已失去了封闭性。</li><li><strong>不可再现性</strong>：程序在并发执行时，由于失去了封闭性，也将导致失去其可再现性</li></ul><h2 id="进程">进程</h2><h3 id="进程的定义">进程的定义</h3><ul><li>简：进程是程序的一次执行；</li><li>详：一个具有一定独立功能的<strong>程序</strong>在一个<strong>数据集合</strong>上的一次<strong>动态执行</strong>过程</li><li>进程是系统进行<strong>资源分配和调度</strong>的一个<strong>独立单位</strong></li></ul><h3 id="进程的特征">进程的特征</h3><ul><li><strong>动态性</strong>:<ul><li>进程是程序产生的：创建-&gt;运行-&gt;消亡</li><li>进程在生命周期中在三种基本状态之间转换</li></ul></li><li><strong>独立性</strong>:<br>各进程的<strong>地址相互独立</strong>，除非采用进程间通信手段</li><li><strong>并发性</strong>:<br>多个进程实体同时存于内存中，能在一段时间内并发进行</li><li><strong>异步性</strong>:<br>每个进程都以其相对独立的不可预知的速度向前推进</li><li><strong>结构化</strong>:<br>进程 = 代码块 + 数据块 + <strong>PCB</strong></li></ul><h3 id="进程的组成">进程的组成</h3><p><strong>进程 = 程序 + 数据 + 进程控制块PCB</strong></p><ul><li><strong>程序</strong>是进程的不可缺少的组成部分；如果一个程序段允许被共享，则它应该是可重入的，或纯代码段</li><li><strong>数据</strong>是进程处理的对象</li><li><strong>进程控制块</strong>是进程的<strong>控制结构</strong>，包含了进程的<strong>描述信息</strong>、<strong>控制信息</strong>和<strong>资源信息</strong>以及<strong>现场保护区</strong>，是进程的<font color=red><strong>唯一标识</strong></font>，系统通过PCB管理和控制进程。</li></ul><h3 id="进程控制块PCB">进程控制块PCB</h3><ul><li>进程控制块是由OS维护的用来记录进程相关信息和管理进程而设置的一个专门的<strong>数据结构</strong></li><li>PCB结构的全部或部分<strong>常驻内存</strong>；</li><li>PCB随进程的创建而填写，随进程的撤消而释放,有生命周期；</li><li>系统利用PCB来控制和管理进程，所以PCB是系统感知进程存在的唯一标志</li><li>进程与PCB是一一对应的</li><li><strong>OS是根据PCB来对并发执行的进程进行控制和管理的。</strong></li><li><strong>所谓创建进程是指创建进程实体中的PCB，撤销亦如此。</strong></li></ul><h4 id="PCB的内容">PCB的内容</h4><ul><li><strong>进程标识符</strong>:<ul><li>内部进程标识符(process ID)，唯一，通常是一个整数</li><li>进程名(外部标识符)，通常基于可执行文件名（不唯一）</li><li>用户标识符(user ID)；进程组关系(process group)</li></ul></li><li><strong>进程调度信息</strong>：<br>进程状态、进程优先级、资源信息等</li><li><strong>处理机状态</strong>：<br>寄存器值（通用、程序计数器PC、状态PSW，地址包括栈指针）</li><li><strong>进程控制信息</strong>:<ul><li>当前状态；</li><li>优先级(priority)；</li><li>代码执行入口地址；</li><li>程序的外存地址；</li><li>运行统计信息（执行时间、页面调度）；</li><li>进程间同步和通信；阻塞原因</li></ul></li></ul><h4 id="PCB的组织方式">PCB的组织方式</h4><ul><li><strong>链表</strong>：同一状态的进程其PCB成一链表，多个状态对应多个不同的链表<ul><li>各状态的进程形成不同的链表：就绪链表、阻塞链表</li></ul></li><li><strong>索引表</strong>：同一状态的进程归入一个index表（由index指向PCB），多个状态对应多个不同的index表<ul><li>各状态的进行形成不同的索引表：就绪索引表、阻塞索引表</li></ul></li></ul><h3 id="进程与程序的区别">进程与程序的区别</h3><ul><li>进程是动态的，程序是静态的：炒菜菜谱</li><li>进程是暂时的，程序的永久的：进程是一个状态变化的过程，程序可长久保存。</li><li>进程与程序的组成不同：进程的组成包括程序、数据和进程控制块（即进程状态信息）。</li><li>进程与程序的对应关系：通过多次执行，一个程序可对应多个进程；通过调用关系，一个进程可包括多个程序。</li><li>进程具有并行特征，程序没有。</li><li>进程是竞争计算机资源的基本单位。</li></ul><h2 id="进程的状态及其转换">进程的状态及其转换</h2><h3 id="进程的三种基本状态">进程的三种基本状态</h3><ul><li><strong>就绪状态(Ready)</strong>：已分配到<strong>除CPU以外</strong>的所有必要的资源，只要能再获得处理机，便可立即执行的状态。多个排成一队称为就绪队列。</li><li><strong>执行状态(Running)</strong>：指进程已获得处理机，其程序正在执行;<ul><li>在单处理机系统中，只能有一个进程处于执行状态;</li><li>在多处理机系统中，则可能多个进程处于执行状态。 </li></ul></li><li><strong>阻塞状态(Blocked)</strong>：进程因<strong>发生某事件</strong>(如请求I／O、申请缓冲空间等)而暂停执行时的状态，亦即进程的执行受到阻塞，故称这种暂停状态为阻塞状态，有时也称为“等待”状态或“睡眠”状态。<ul><li>通常将处于阻塞状态的进程排成一个队列，称为阻塞队列。在有的系统中，按阻塞原因的不同而将处于阻塞状态的进程排成多个队列。</li></ul></li></ul><h3 id="进程的三种基本状态转换">进程的三种基本状态转换</h3><img src="..\..\img\OS\进程三状态.png" width="50%" height="70%" align="middle"><ul><li><strong>就绪-&gt;运行</strong>：调度程序选择一个新的进程运行</li><li><strong>运行-&gt;就绪</strong>：<ul><li>运行进程用完了时间片</li><li>运行进程被中断，因为一高优先级进程处于就绪状态</li></ul></li><li><strong>运行-&gt;等待</strong>：当一进程等待某一事件的发生时，如<ul><li>请求系统服务</li><li>无新工作可做</li></ul></li><li><strong>等待-&gt;就绪</strong>：当所等待的事件发生时</li></ul><h3 id="进程的五状态进程转换">进程的五状态进程转换</h3><img src="..\..\img\OS\进程五状态.png" width="50%" height="70%" align="middle"><ul><li><strong>创建状态(New)</strong>：创建新状态<ul><li>OS 已完成为创建一进程所必要的工作<ul><li>已构造了进程标识符</li><li>已创建了管理进程所需的表格</li></ul></li></ul></li><li><strong>终止状态(Exit)</strong><ul><li>终止后进程移入该状态</li><li>它不再有执行资格</li><li>表格和其它信息暂时保留</li><li>实用程序为了分析性能和利用率，可能要提取程序的历史信息</li></ul></li></ul><h3 id="带挂起的进程转换模型">带挂起的进程转换模型</h3><h4 id="新增状态">新增状态</h4><ul><li><strong>就绪挂起状态(Ready,suspend)</strong>：进程在外存，但只要进入内存，即可运行；</li><li><strong>阻塞挂起状态(Blocked,suspend)</strong>：进程在外存并等待某事件的出现；</li></ul><h4 id="新增事件">新增事件</h4><ul><li><strong>挂起(Suspend)</strong>：把一个进程从内存转到外存；可能有以下几种情况：<ul><li><strong>阻塞到阻塞挂起</strong>：没有进程处于就绪状态或就绪进程要求更多内存资源时，会进行这种转换，以纳入新进程或运行就绪进程；</li><li><strong>就绪到就绪挂起</strong>：当有高优先级阻塞（系统认为会很快就绪的）进程和低优先级就绪进程时，系统会选择挂起低优先级就绪进程；</li><li><strong>运行到就绪挂起</strong>：对抢先式分时系统，当有高优先级阻塞挂起进程因事件出现而进入就绪挂起时，系统可能会把运行进程转到就绪挂起状态；</li></ul></li><li><strong>激活(Activate)</strong>：把一个进程从外存转到内存；可能有以下几种情况：<ul><li><strong>就绪挂起到就绪</strong>：没有就绪进程或挂起就绪进程优先级高于就绪进程时，会进行这种转换；</li><li><strong>阻塞挂起到阻塞</strong>：当一个进程释放足够内存时，系统会把一个高优先级阻塞挂起（系统认为会很快出现所等待的事件）进程转为阻塞状态；较少出现。</li></ul></li><li><strong>事件出现(Event Occurs)</strong>：进程等待的事件出现；如：操作完成、申请成功等；可能的情况有：<ul><li><strong>阻塞到就绪</strong>：针对内存进程的事件出现；</li><li><strong>阻塞挂起到就绪挂起</strong>：针对外存进程的事件出现；</li></ul></li><li><strong>收容(Admit)</strong>：收容一个新进程，进入就绪状态或就绪挂起状态。</li><li><strong>各种状态-&gt;退出</strong>：被父进程终止或父进程本身终止。</li></ul><h4 id="挂起进程目的是">挂起进程目的是:</h4><ul><li><strong>提高处理机效率</strong>：就绪进程表为空时，OS将阻塞进程从内存中“挂起”到磁盘的“挂起队列”，再从该队列选另一进程进入内存，或接受一个新进程的请求。</li><li><strong>为运行进程提供足够内存</strong>：资源紧张时，暂停某些进程，如：CPU繁忙（或实时任务执行）,内存紧张</li><li><strong>用于调试</strong>：在调试时，挂起被调试进程（从而对其地址空间进行读写）</li></ul><h4 id="单挂起进程模型">单挂起进程模型</h4><img src="..\..\img\OS\单挂起进程模型.png" width="50%" height="70%" align="middle"><h4 id="双挂起进程模型">双挂起进程模型</h4><img src="..\..\img\OS\双挂起进程模型.png" width="50%" height="70%" align="middle"><h2 id="进程控制的功能">进程控制的功能</h2><h3 id="原语-primitive">原语(primitive)</h3><ul><li>由若干条指令构成的“原子操作(atomic operation)”过程，作为一个整体而不可分割－－要么全都完成，要么全都不做。许多系统调用就是原语。</li></ul><h3 id="进程创建原语">进程创建原语</h3><p>子进程的创建的3种形式</p><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">产生新进程</th><th style="text-align:center">不产生新进程</th></tr></thead><tbody><tr><td style="text-align:center">复制现有进程的上下文</td><td style="text-align:center"><strong>fork</strong>(新进程的系统上下文会有不同)</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">加载程序</td><td style="text-align:center"><strong>spawn</strong>(创建新进程并加载新程序)</td><td style="text-align:center"><strong>exec</strong>(加载新程序并覆盖自身)</td></tr></tbody></table><h3 id="进程撤销原语">进程撤销原语</h3><p><strong>Destroy</strong></p><ul><li>释放资源：<ul><li>释放内外存空间</li><li>关闭所有打开文件</li><li>释放共享内存段和各种锁定lock</li></ul></li></ul><h3 id="进程阻塞原语">进程阻塞原语</h3><p><strong>Block</strong></p><ul><li>阻塞原因：当进程期待的某事件尚未出现时，该进程调用阻塞原语把自己阻塞起来</li><li>进程的阻塞是进程自身的一种主动行为</li></ul><h3 id="进程唤醒原语">进程唤醒原语</h3><p><strong>Wakeup</strong></p><ul><li>唤醒原因：<ul><li>进程等待的事件发生，等待队列中的进程唤醒。</li></ul></li><li>唤醒进程的两种方法：<ul><li><strong>由系统进程唤醒</strong>: 系统进程统一控制事件的发生，并将“事件发生”这一消息通知等待进程。等待的是公共资源。</li><li><strong>由事件发生进程唤醒</strong>: 事件发生进程与被唤醒的进程是合作关系，等待私有资源。</li></ul></li></ul><h3 id="进程挂起原语">进程挂起原语</h3><p><strong>Suspend</strong></p><ul><li>引起进程挂起的事件:<ul><li>用户进程请求将自己挂起;</li><li>或父进程请求将自己的某个子进程挂起，</li><li>系统将利用挂起原语suspend( )将指定进程或处于阻塞状态的进程挂起。</li></ul></li></ul><h3 id="进程激活原语">进程激活原语</h3><p><strong>Active</strong></p><ul><li>进程的激活过程<ul><li>系统将利用激活原语active( )将指定进程激活。 激活原语先将进程从外存调入内存，检查该进程的现行状态，若是就绪挂起，便将之改为活动就绪；若为阻塞挂起便将之改为活动阻塞。</li></ul></li></ul><h1>进程同步</h1><h2 id="1-一组并发进程执行时存在两种相互制约关系：">1.一组并发进程执行时存在两种相互制约关系：</h2><ul><li><strong>进程互斥</strong> (打印机)<ul><li><strong>资源共享关系</strong>（间接相互制约关系）</li><li>进程本身之间<strong>不存在直接联系</strong>。</li><li>例如:在仅有一台打印机的系统中，有两个进程A和B，如果在A进程提出打印请求时，系统已将打印机分配给进程B，则系统让A进程等待，直至B将打印机用完并释放后，系统才将打印机分配给进程A。</li></ul></li><li><strong>进程同步</strong> (接力棒)<ul><li><strong>相互合作关系</strong>（直接相互制约关系）</li><li>进程本身之间<strong>存在着相互制约的关系</strong>。</li><li>例如：有一输入进程A通过单缓冲向进程B提供数据。当该缓冲空时，计算进程B因不能获得所需数据而等待。当进程A把数据送入缓冲时，便应向进程B发送一信号，将它唤醒</li></ul></li></ul><h2 id="2-临界资源">2.临界资源</h2><ul><li>临界资源: 在一段时间内只允许<strong>一个进程访问</strong>的资源。诸进程间应采取<strong>互斥方式</strong>，实现对资源的共享。</li><li>共享变量，打印机 等均属于此类资源。</li></ul><h2 id="3-临界区">3.临界区</h2><h3 id="临界区的定义与进入">临界区的定义与进入</h3><ul><li><strong>临界区</strong>(critical section)：<br>在每个进程中访问临界资源的那段代码</li><li><strong>进入区</strong>：<br>在临界区前面增加一段用于进行临界资源检查的代码</li><li><strong>退出区</strong>：<br>将临界区正被访问的标志恢复为未被访问的标志。</li><li><strong>剩余区</strong>：其余部分。</li></ul><h3 id="使用临界区遵循的原则">使用临界区遵循的原则</h3><ul><li><strong>空闲则入</strong>：其他进程均不处于临界区；</li><li><strong>忙则等待</strong>：已有进程处于其临界区；</li><li><strong>有限等待</strong>：等待进入临界区的进程不能&quot;死等&quot;；</li><li><strong>让权等待</strong>：不能进入临界区的进程，应释放CPU(如转换到阻塞状态)</li></ul><h3 id="解决诸进程互斥进入临界区的方法">解决诸进程互斥进入临界区的方法</h3><ul><li>硬件同步机制</li><li>软件同步机制</li></ul><h2 id="4-硬件同步机制">4.硬件同步机制</h2><p>目的：解决诸进程互斥进入临界区。<br>目前许多计算机已提供了一些特殊的硬件指令来解决临界区问题。</p><ul><li>关中断；<ul><li>关中断是实现互斥的最简单的方法之一。在进入锁测试之前关闭中断，直到完成锁测试并上锁之后才能打开中断。</li><li>关中断的方法存在许多缺点：<ul><li>滥用关中断权力可能导致严重后果；</li><li>关中断时间过长，会影响系统效率，限制了处理器交叉执行程序的能力；</li><li>关中断方法也不适用于多CPU 系统，因为在一个处理器上关中断并不能防止进程在其它处理器上执行相同的临界段代码。</li></ul></li></ul></li><li>利用Test-and-Set指令实现互斥；</li><li>利用Swap指令实现进程互斥；</li></ul><h2 id="5-软件同步机制-进程互斥的软件方法">5.软件同步机制(进程互斥的软件方法)</h2><h3 id="利用信号量机制实现进程互斥">利用信号量机制实现进程互斥</h3><h2 id="6-管程-monitor">6.管程(monitor)</h2><h1>进程通信及线程</h1><h1>处理机调度与死锁–完成进程状态的转换</h1>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OS-概述</title>
      <link href="/post/e50618fb.html"/>
      <url>/post/e50618fb.html</url>
      
        <content type="html"><![CDATA[<h1>操作系统定义</h1><p><strong>操作系统</strong>：是管理计算机系统资源、控制程序执行、改善人机界面和为应用软件提供支持的一种系统<font color=red>软件</font>。</p><h2 id="多道程序设计：">多道程序设计：</h2><p>现代操作系统一般都采用多道程序设计技术，其基本思想是在主存中同时存放多个用户的作业，使之同时处于运行状态而共享系统资源。</p><p>多道程序设计——多个程序同时进入主存并发执行。</p><h1>操作系统的作用</h1><h2 id="OS作为用户与计算机硬件系统之间的接口">OS作为用户与计算机硬件系统之间的接口</h2><ul><li>OS是一个系统软件，因而这种接口是<strong>软件接口</strong>。</li></ul><h2 id="OS作为计算机系统资源的管理者">OS作为计算机系统资源的管理者</h2><p>OS的<strong>主要功能</strong>为:</p><ul><li><strong>处理机管理</strong>：用于分配和控制处理机；</li><li><strong>存储器管理</strong>：主要负责内存的分配与回收；</li><li><strong>I/O设备管理</strong>：负责I/O设备的分配与操纵；</li><li><strong>文件管理</strong>：负责文件的存取、共享和保护。可见，OS确是计算机系统资源的管理者。</li></ul><h2 id="OS实现了对计算机资源的抽象">OS实现了对计算机资源的抽象</h2><ul><li>通常把覆盖了软件的机器称为扩充机器或虚机器。</li></ul><h1>操作系统的基本特性</h1><h2 id="并发">并发</h2><ul><li><strong>并行性</strong>：指两个或多个事件在同一时刻发生</li><li><strong>并发性</strong>：指两个或多个事件在同一时间间隔内发生<ul><li>在多道程序环境下，并发性是指在一段时间内，宏观上有多个程序在同时运行，但在单处理机系统中，每一时刻却仅能有一道程序执行，故微观上这些程序只能是分时地交替执行。</li></ul></li></ul><h2 id="共享">共享</h2><ul><li><strong>共享</strong>的概念：指系统中的资源，可供内存中多个并发执行的进程(线程)共同使用 。</li><li>进程对资源共享的方式：<ul><li><strong>互斥共享</strong>：当某一进程访问完并释放该资源后，才允许另一进程进行访问。这种资源称为<font color=red>临界资源</font>或独占资源,如打印机；</li><li><strong>同时共享</strong>：允许在一段时间内由多个进程同时访问，如磁盘设备</li></ul></li></ul><h2 id="虚拟">虚拟</h2><h3 id="定义">定义</h3><ul><li>操作系统中的所谓“<strong>虚拟</strong>”，是指通过某种技术把一个物理实体变为若干个逻辑上的对应物。</li><li>在OS中利用了多种虚拟技术，分别用来实现虚拟处理机、虚拟内存(设置：我的电脑、属性、高级、性能选项)、 虚拟外部设备(虚拟光驱、盘符D：等)和虚拟信道等。</li></ul><h3 id="OS中采用的2种虚拟技术">OS中采用的2种虚拟技术</h3><ul><li><strong>时分复用技术</strong> -多设备分时使用物理设备<ul><li>利用该技术可以实现虚拟处理机、虚拟设备等，以<strong>提高资源利用率</strong>。</li><li>虚拟处理机：是通过多道程序设计技术，让多道程序并发执行的方法，来分时使用一台处理机的。</li><li>虚拟设备技术：将一台物理I/O设备虚拟为多台逻辑上的I/O设备。 如虚拟打印机。</li></ul></li><li><strong>空分复用技术</strong><ul><li>利用该技术可以实现虚拟磁盘技术、虚拟存储器技术等，以<strong>提高存储空间利用率</strong>。</li><li>虚拟磁盘技术：一个硬盘划分为1、2、3、4四个卷，分别安装在C、D、E、F四个逻辑驱动器上，成为四个虚拟磁盘。</li><li>虚拟存储器技术：一个100M的程序可以运行在20M的内存空间</li></ul></li></ul><h2 id="异步性">异步性</h2><ul><li>在多道程序环境下，允许多个进程并发执行。使进程的执行是以“走走停停”的方式运行；</li><li><strong>进程的异步性</strong>: 每个程序在何时执行，多个程序间的执行顺序以及完成每道程序所需的时间都是不确定和不可预知的。进程是以人们不可预知的速度向前推进</li></ul><h1>操作系统结构设计</h1><ul><li>第一代：无结构OS；</li><li>第二代：模块化结构OS；</li><li>分层式操作系统；</li></ul><h2 id="模块化结构OS">模块化结构OS</h2><ul><li>模块之间直接调用函数，除了函数调用的开销外，没有额外开销</li><li>庞大的操作系统有数以千计的函数</li></ul><h2 id="微内核-Micro-Kelnel-结构OS-现代结构">微内核(Micro Kelnel)结构OS -现代结构</h2><h3 id="微内核技术">微内核技术</h3><ul><li><p><strong>微内核技术</strong>: 指精心设计的、能实现现代OS核心功能的小型内核，它与一般的OS(程序)不同，它更小更精炼，它不仅运行在核心态，而且<strong>开机后常驻内存</strong>。</p></li><li><p>微内核<strong>并非</strong>是一个完整的OS， 而只是为构建通用OS提供一个重要基础。在微内核OS结构中，通常都采用了<strong>客户/服务器模式</strong>。<br><img src="..\..\img\OS\os微内核.png" width="50%" height="70%" align="middle"></p></li><li><p><strong>优缺点</strong></p><ul><li>内核与各个服务器之间通过通信机制进行交互，这使得微内核结构的效率大打折扣</li><li>因为各个服务器模块的相对独立性，使得其维护相对容易。</li></ul></li></ul><h3 id="客户-服务器模式">客户/服务器模式</h3><p>客户/服务器系统主要由<strong>客户机</strong>、<strong>服务器</strong>和<strong>网络系统</strong>三个部分组成。</p><ul><li>客户机：平时处理本地业务，也可发送一个消息给服务器，以请求某项服务</li><li>服务器：通常是一台规模较大的机器，在其上驻留有网络文件系统或数据库系统等，为用户提供多种服务。</li></ul><h3 id="面向对象的程序设计技术">面向对象的程序设计技术</h3><ul><li>在OS中的各类实体如进程、线程、消息、存储器和文件等，都使用了对象这一概念，相应地，便有了进程对象、线程对象、存储器对象和文件对象等</li><li>操作系统是一个极其复杂的大型软件系统，面向对象技术被广泛应用于现代操作系统的设计中。</li></ul><h3 id="微内核的基本功能">微内核的基本功能</h3><p>通常都是一些最基本的功能：</p><ul><li>进程(线程)管理。</li><li>低级存储器管理。</li><li>中断和陷入处理。<br>将OS中<strong>最基本</strong>的部分放入内核中，而把OS的<strong>绝大部分功能</strong>放在微内核**外面的一组服务器（进程）**中实现。</li></ul><h3 id="微内核操作系统存在的问题">微内核操作系统存在的问题</h3><p>微内核OS的<strong>运行效率有所降低：</strong><br>会引起更多的上下文切换。例如某个服务器自身尚无能力完成客户请求，而需其它服务器帮助时，如图1-11中所示，其中的文件服务器还需要磁盘服务器的帮助，这时就需要进行八次上下文的切换。<br><img src="..\..\img\OS\os微内核缺点.png" width="50%" height="70%" align="middle"></p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深度学习-梯度下降</title>
      <link href="/post/33115a55.html"/>
      <url>/post/33115a55.html</url>
      
        <content type="html"><![CDATA[<h1>反向传播算法</h1><img src="../../img/DeepLearning/bp推导.jpg" width="70%" height="70%" align="middle"><h1>梯度下降及其变体</h1><h2 id="批量梯度下降">批量梯度下降</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">do_gradient_descent</span>():</span><br><span class="line">    w,b,eta,max_epochs = -<span class="number">2</span>,-<span class="number">2</span>,<span class="number">1.0</span>,<span class="number">1000</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(max_epochs):</span><br><span class="line">        dw,db = <span class="number">0</span>,<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> x,y <span class="keyword">in</span> <span class="built_in">zip</span>(X,Y):</span><br><span class="line">            dw += grad_w(w,b,x,y)</span><br><span class="line">            db += grad_b(w,b,x,y)</span><br><span class="line">        w -= eta*dw</span><br><span class="line">        b -= eta*db</span><br></pre></td></tr></table></figure><h2 id="SGD">SGD</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">do_stochastic_gradient_descent</span>():</span><br><span class="line">w,b,eta,max_epochs = -<span class="number">2</span>,-<span class="number">2</span>,<span class="number">1.0</span>,<span class="number">1000</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(max_epochs):</span><br><span class="line">        dw,db = <span class="number">0</span>,<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> x,y <span class="keyword">in</span> <span class="built_in">zip</span>(X,Y):</span><br><span class="line">            dw = grad_w(w,b,x,y)</span><br><span class="line">            db = grad_b(w,b,x,y)</span><br><span class="line">            w -= eta*dw</span><br><span class="line">            b -= eta*db</span><br></pre></td></tr></table></figure><h2 id="MiniBatch">MiniBatch</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">do_mini_batch_gradient_descent</span>():</span><br><span class="line">    w,b,eta = -<span class="number">2</span>,-<span class="number">2</span>,<span class="number">1.0</span></span><br><span class="line">    mini_batch_size,num_points_seen = <span class="number">2</span>,<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(max_epochs):</span><br><span class="line">        dw,db,num_points = <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> x,y <span class="keyword">in</span> <span class="built_in">zip</span>(X,Y):</span><br><span class="line">            dw += grad_w(w,b,x,y)</span><br><span class="line">            db += grad_b(w,b,x,y)</span><br><span class="line">            num_points_seen += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> num_points_seen%mini_batch_size == <span class="number">0</span>:</span><br><span class="line">                w -= eta*dw</span><br><span class="line">                b -= eta*db</span><br><span class="line">                dw,db = <span class="number">0</span>,<span class="number">0</span></span><br></pre></td></tr></table></figure><h2 id="Momentum">Momentum</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">do_momentum_gradient_descent</span>():</span><br><span class="line">    w,b,eta = init_w,init_b,<span class="number">1.0</span></span><br><span class="line">    prev_v_w,prev_v_b,gamma = <span class="number">0</span>,<span class="number">0</span>,<span class="number">0.9</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(max_epochs):</span><br><span class="line">        dw,db = <span class="number">0</span>,<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> x,y <span class="keyword">in</span> <span class="built_in">zip</span>(X,Y):</span><br><span class="line">            dw += grad_w(w,b,x,y)</span><br><span class="line">            db += grad_b(w,b,x,y)</span><br><span class="line">        v_w = gamma * prev_v_w + eta*dw</span><br><span class="line">        v_b = gamma * prev_v_b + eta*db</span><br><span class="line">        w -= v_w</span><br><span class="line">        b -= v_b</span><br><span class="line">        prev_v_w = v_w</span><br><span class="line">        prev_v_b = v_b</span><br></pre></td></tr></table></figure><h2 id="NAGD">NAGD</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">do_nesterov_accelerated_gradient_descent</span>():</span><br><span class="line">    w,b,eta = init_w,init_b,<span class="number">1.0</span></span><br><span class="line">    prev_v_w,prev_v_b,gamma = <span class="number">0</span>,<span class="number">0</span>,<span class="number">0.9</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(max_epochs):</span><br><span class="line">        dw,db=<span class="number">0</span>,<span class="number">0</span></span><br><span class="line">       v_w = gamma * prev_v_w</span><br><span class="line">        v_b = gamma * prev_v_b</span><br><span class="line">        <span class="keyword">for</span> x,y <span class="keyword">in</span> <span class="built_in">zip</span>(X,Y):</span><br><span class="line">            dw += grad_w(w-v_w,b-v_b,x,y)</span><br><span class="line">            db += grad_b(w-v_w,b-v_b,x,y)</span><br><span class="line">        v_w = gamma*prev_v_w + eta*dw</span><br><span class="line">        v_b = gamma*prev_v_b + eta*db</span><br><span class="line">        w -= v_w</span><br><span class="line">        b -= v_b</span><br><span class="line">        prev_v_w = v_w</span><br><span class="line">        prev_v_b = v_b</span><br></pre></td></tr></table></figure><h2 id="Adagrad">Adagrad</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">do_adagrad</span>():</span><br><span class="line">    w,b,eta = init_w,init_b,<span class="number">0.1</span></span><br><span class="line">    v_w,v_b,eps = <span class="number">0</span>,<span class="number">0</span>,<span class="number">1e-8</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(max_epochs):</span><br><span class="line">        dw,db = <span class="number">0</span>,<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> x,y <span class="keyword">in</span> <span class="built_in">zip</span>(X,Y):</span><br><span class="line">            dw += grad_w(w,b,x,y)</span><br><span class="line">            db += grad_b(w,b,x,y)</span><br><span class="line">        v_w += dw**<span class="number">2</span></span><br><span class="line">        v_b += db**<span class="number">2</span></span><br><span class="line">        w -= (eta/np.sqrt(v_w+eps)) * dw</span><br><span class="line">        b -= (eta/np.sqrt(v_b+eps)) * db</span><br></pre></td></tr></table></figure><h2 id="RMSProp">RMSProp</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">do_rmsprop</span>():</span><br><span class="line">    w,b,eta = init_w,init_b,<span class="number">0</span>,<span class="number">1</span></span><br><span class="line">    v_w,v_b,eps,beta1 = <span class="number">0</span>,<span class="number">0</span>,<span class="number">1e-8</span>,<span class="number">0.9</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(max_epochs):</span><br><span class="line">        dw,db = <span class="number">0</span>,<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> x,y <span class="keyword">in</span> <span class="built_in">zip</span>(X,Y):</span><br><span class="line">            dw += grad_w(w,b,x,y)</span><br><span class="line">            db += grad_b(w,b,x,y)</span><br><span class="line">        v_w = beta1*v_w + (<span class="number">1</span>-beta1) * dw**<span class="number">2</span></span><br><span class="line">        v_b = beta1*v_b + (<span class="number">1</span>-beta1) * db**<span class="number">2</span></span><br><span class="line">        w -= (eta / np.sqrt(v_w+eps)) * dw</span><br><span class="line">        b -= (eta / np.sqrt(v_b+eps)) * db</span><br></pre></td></tr></table></figure><h2 id="Adam">Adam</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">do_adam</span>():</span><br><span class="line">    w,b,eta = init_w,init_b,<span class="number">0.1</span></span><br><span class="line">    m_w,m_b,v_w,v_b,m_w_hat,m_b_hat,v_w_hat,v_b_hat,eps,beta1,beta2 = <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1e-8</span>,<span class="number">0.9</span>,<span class="number">0.999</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(max_epochs):</span><br><span class="line">        dw,db = <span class="number">0</span>,<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> x,y <span class="keyword">in</span> <span class="built_in">zip</span>(X,Y):</span><br><span class="line">            dw += grad_w(w,b,x,y)</span><br><span class="line">            db += grad_b(w,b,x,y)</span><br><span class="line">        m_w = beta1*m_w + (<span class="number">1</span>-beta1) * dw</span><br><span class="line">        m_b = beta1*m_b + (<span class="number">1</span>-beta1) * db</span><br><span class="line">        v_w = beta2*v_w + (<span class="number">1</span>-beta2) * dw**<span class="number">2</span></span><br><span class="line">        v_b = beta2*v_b + (<span class="number">1</span>-beta2) * db**<span class="number">2</span></span><br><span class="line">        m_w_hat = m_w / (<span class="number">1</span>-math.<span class="built_in">pow</span>(beta1, i+<span class="number">1</span>))</span><br><span class="line">        m_b_hat = m_b / (<span class="number">1</span>-math.<span class="built_in">pow</span>(beta1, i+<span class="number">1</span>))</span><br><span class="line">        v_w_hat = v_w / (<span class="number">1</span>-math.<span class="built_in">pow</span>(beta2, i+<span class="number">1</span>))</span><br><span class="line">        v_b_hat = v_b / (<span class="number">1</span>-math.<span class="built_in">pow</span>(beta2, i+<span class="number">1</span>))</span><br><span class="line">        w -= (eta / np.sqrt(v_w_hat+eps)) * m_w_hat</span><br><span class="line">        b -= (eta / np.sqrt(v_b_hat+eps)) * m_b_hat</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity-NGUI之三大基础组件</title>
      <link href="/post/b9d856e4.html"/>
      <url>/post/b9d856e4.html</url>
      
        <content type="html"><![CDATA[<h1>NGUI概述</h1><p>NGUI全称 下一代用户界面（Next-Gen UI）<br>它是第三方提供的Unity付费插件<br>专门用于制作Unity中游戏UI的第三方工具<br>相对于GUI它更适用于制作游戏UI功能<br>更方便使用，性能和效率更高</p><h1>Root组件</h1><h2 id="作用">作用</h2><ul><li>Root是用于 <strong>分辨率自适应</strong> 的 根对象</li><li>可以设置 基本分辨率,相当于设置 UI显示区域</li><li>并且管理所有UI控件的 分辨率自适应<br>可以简单理解 它管理一个 UI画布 所有的UI都是显示在这个画布上的<br>它会管理 UI画布 和 不同屏幕分辨率的 适应关系</li></ul><h2 id="Root参数相关">Root参数相关</h2><p>主要包含三种缩放模式</p><ol><li><p><strong>Flexible</strong> 适用于可以手动拖窗口改变分辨率的设备 比如pc端</p></li><li><p><strong>Constrained</strong> 适用于移动设备<br>因为移动设备都是全屏应用 不会频繁改变分辨率 只用适配不同分辨率的设备<br>一般使用：<strong>横屏勾选 高fit</strong> ; <strong>竖屏勾选 宽fit</strong><br>需要注意的是: <strong>背景图</strong> 一定要考虑 <strong>极限宽高比</strong>来出 <strong>最大宽高比</strong>  19.9:9</p></li><li><p><strong>Constrained On Mobiles</strong> 是上面两者的综合体 适用于多平台发布的游戏和应用</p></li></ol><img src="../../../img/Unity/NGUI_Root_缩放模式设置.bmp" width="70%" height="50%"><h1>Panel组件</h1><h2 id="作用-2">作用</h2><ul><li>管理一个UI面板的渲染顺序</li><li>管理一个UI面板上的所有子控件</li></ul><p><strong>tips</strong>:</p><ol><li>在Root下创建多个Panel对象(挂载着Panel组件的空对象), <strong>设置不同的depth</strong>, 一般一个Panel管理一个面板, 可以理解为 Panel的depth 控制 Panel与Panel之间的层级关系，<strong>类似于文件夹</strong></li><li>同一Panel下的对象通过<strong>自身的widget中的depth</strong>来控制在<strong>当前Panel下</strong>的层级，<strong>类似于文件夹中的文件</strong></li><li>没有Panel父对象 UI控件看不到</li></ol><h2 id="Panel参数相关">Panel参数相关</h2><img src="../../../img/Unity/NGUI_Panel参数.bmp" width="70%" height="50%"><h1>EventSystem组件</h1><p>也称为 <strong>UICamera</strong></p><h2 id="作用-3">作用</h2><p>主要作用是让摄像机渲染出来的物体 能接收到NGUI的<strong>输入事件</strong><br>大部分设置不需要我们去修改<br>有了它我们通过鼠标 触碰 键盘 控制器 操作UI 响应玩家的输入</p><p><strong>tips</strong>:</p><ol><li>EventSystem很重要，如果没有它，我们没有办法监听玩家输入</li><li>创建UI时的 2DUI 和3DUI 主要就是<strong>摄像机的模式</strong> (正交或透视) 不一样</li><li>EventSystem的2D和3D主要是 采用2D<strong>碰撞器</strong> 还是3D碰撞器, <strong>不能直接改变摄像机模式</strong></li></ol><h2 id="EventSystem参数相关">EventSystem参数相关</h2><img src="../../../img/Unity/NGUI_EventSystem参数1.bmp" width="70%" height="50%"><img src="../../../img/Unity/NGUI_EventSystem参数2.bmp" width="50%" height="50%"><h1>图集 Atlas</h1><h2 id="图集作用">图集作用</h2><p>NGUI中的最小图片控件<strong>Sprite</strong>要使用图集中的图片进行显示<br>图集 就是把很多单独的小图 合并为 一张大图 合并后的大图就是图集<br><strong>目的</strong>：提高渲染性能</p><h2 id="打开图集制作工具">打开图集制作工具</h2><ul><li>方法一：<strong>Project</strong>右键打开</li><li>方法二：上方工具栏<strong>NGUI——Open——Atlas Maker</strong></li></ul><h2 id="图集关键文件">图集关键文件</h2><ol><li>图集文件 (配置文件,包含小图在图集中的位置等信息)</li><li>图集材质球</li><li>图集图片</li></ol><h2 id="新建图集-及-创建修改删除图集元素">新建图集 及 创建修改删除图集元素</h2><ul><li>在图集工具<strong>Atlas Maker</strong>中操作</li></ul>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>形式语言与自动机</title>
      <link href="/post/b01f06ff.html"/>
      <url>/post/b01f06ff.html</url>
      
        <content type="html"><![CDATA[<h1>前言</h1><ul><li>形式语言理论：<font color="red">乔姆斯基发现文法</font>，用<strong>文法产生语言</strong>的每个句子。</li><li>自动机理论：<font color="red">克林建立了有穷状态自动机</font>,为识别语言的系统</li><li>文法与自动机是<strong>等价</strong>的</li><li>文法与自动机的运算对象：<strong>集合</strong></li></ul><img src="..\img\FL&FA\5方转换图.png" width="70%" height="70%" align="middle"><h1>文法</h1><h2 id="文法构造">文法构造</h2><ul><li><p>例1<br><img src="..\img\FL&FA\文法例1.png" width="40%" height="70%" align="middle"></p></li><li><p>例2<br><img src="..\img\FL&FA\文法例2.png" width="70%" height="70%" align="middle"></p></li><li><p>例3<br><img src="..\img\FL&FA\文法例3.png" width="70%" height="70%" align="middle"></p></li><li><p>例4<br><img src="..\img\FL&FA\文法例4.png" width="70%" height="70%" align="middle"><br><img src="..\img\FL&FA\文法例4_1.png" width="70%" height="70%" align="middle"></p></li><li><p>例5<br><img src="..\img\FL&FA\文法例5.png" width="70%" height="70%" align="middle"></p></li><li><p>例6<br><img src="..\img\FL&FA\文法例6_1.png" width="70%" height="70%" align="middle"><br><img src="..\img\FL&FA\文法例6_2.png" width="40%" height="70%" align="middle"></p></li></ul><h2 id="文法分类">文法分类</h2><ul><li><p>标准<br><img src="..\img\FL&FA\文法分类.png" width="70%" height="70%" align="middle"><br><img src="..\img\FL&FA\文法分类定义.png" width="70%" height="70%" align="middle"></p></li><li><p>例子<br><img src="..\img\FL&FA\文法分类例子.png" width="70%" height="70%" align="middle"></p></li></ul><h1>线性文法与FA的转换</h1><h2 id="右线性文法">右线性文法</h2><h3 id="FA-文法">FA -&gt; 文法</h3><img src="..\img\FL&FA\FA转右线性文法.png" width="70%" height="70%" align="middle"><h3 id="文法-FA">文法 -&gt; FA</h3><img src="..\img\FL&FA\右线性文法转FA.png" width="70%" height="70%" align="middle"><h2 id="左线性文法">左线性文法</h2><h3 id="FA-文法-2">FA -&gt; 文法</h3><ul><li><p>先预处理<br><img src="..\img\FL&FA\FA转左线性文法_预处理.png" width="70%" height="70%" align="middle"></p></li><li><p>规则：<br><img src="..\img\FL&FA\FA转左线性文法_规则.png" width="70%" height="70%" align="middle"></p></li><li><p>例子<br><img src="..\img\FL&FA\FA转左线性文法_例子.png" width="70%" height="70%" align="middle"></p></li></ul><h3 id="文法-FA-2">文法 -&gt; FA</h3><ul><li><p>规则<br><img src="..\img\FL&FA\左线性文法转FA_规则.png" width="70%" height="70%" align="middle"></p></li><li><p>例子<br><img src="..\img\FL&FA\左线性文法转FA_例子.png" width="70%" height="70%" align="middle"></p></li></ul><h1>DFA、NFA、ε-NFA转换</h1><h2 id="ε-NFA-NFA">ε-NFA -&gt; NFA</h2><h3 id="前置知识">前置知识</h3><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϵ</mi><mo>−</mo><mi>C</mi><mi>L</mi><mi>O</mi><mi>S</mi><mi>U</mi><mi>R</mi><mi>E</mi><mo stretchy="false">(</mo><msub><mi>q</mi><mn>0</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\epsilon-CLOSURE(q_0)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">ϵ</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord mathnormal">L</span><span class="mord mathnormal" style="margin-right:0.05764em;">OS</span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="mord mathnormal" style="margin-right:0.05764em;">RE</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> = { p | 从<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>q</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">q_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span></span></span></span>有一条标记为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">ϵ</span></span></span></span> 的路}</li><li>ε-NFA 的 状态转移函数<br><img src="..\img\FL&FA\epsilonNFA的状态转移函数.png" width="70%" height="70%" align="middle"></li></ul><h3 id="转换过程">转换过程</h3><ul><li><p>终止状态<br>F 为 ε-NFA 的<br>F2 为转化后NFA的<br><img src="..\img\FL&FA\epsilonNFA转NFA_终止状态.png" width="70%" height="70%" align="middle"></p></li><li><p>转化后NFA的 转移函数</p><ul><li>为 去除 <font color='red'>ε列</font> 的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>δ</mi><mo>^</mo></mover></mrow><annotation encoding="application/x-tex">\hat\delta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9579em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9579em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal" style="margin-right:0.03785em;">δ</span></span><span style="top:-3.2634em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.1944em;"><span class="mord">^</span></span></span></span></span></span></span></span></span></span></li></ul></li></ul><h3 id="例子">例子</h3><img src="..\img\FL&FA\epsilonNFA转NFA_例子0.png" width="70%" height="70%" align="middle"><img src="..\img\FL&FA\epsilonNFA转NFA_例子1.png" width="70%" height="70%" align="middle"><h2 id="NFA-DFA">NFA -&gt; DFA</h2><ul><li>带 NFA 中 终止状态 的 状态簇 为 新DFA 的终止状态</li><li>例子<br><img src="..\img\FL&FA\NFA转DFA_例子0.png" width="70%" height="70%" align="middle"><br><img src="..\img\FL&FA\NFA转DFA_例子1.png" width="70%" height="70%" align="middle"><br><img src="..\img\FL&FA\NFA转DFA_例子2.png" width="70%" height="70%" align="middle"></li></ul><h1>FA 与 RE 的转化</h1><h2 id="RE-ε-NFA">RE -&gt; ε-NFA</h2><ul><li><p>n = 0<br><img src="..\img\FL&FA\RE转NFA_0.png" width="70%" height="70%" align="middle"></p></li><li><p>n = k+1<br><img src="..\img\FL&FA\RE转NFA_1.png" width="60%" height="70%" align="middle"><br><img src="..\img\FL&FA\RE转NFA_2.png" width="60%" height="70%" align="middle"><br><img src="..\img\FL&FA\RE转NFA_3.png" width="60%" height="70%" align="middle"></p></li><li><p>例子<br><img src="..\img\FL&FA\RE转NFA_例子.png" width="60%" height="70%" align="middle"></p></li></ul><h2 id="DFA-RE">DFA -&gt; RE</h2><h3 id="例子-2">例子</h3><img src="..\img\FL&FA\DFA转RE_例子.png" width="60%" height="70%" align="middle"><ul><li><p>预处理：</p><ul><li>用标记为X和Y的状态将M“括起来”：<br>在状态转移图中增加标记为X和Y的状态, 从标记为X的状态到标记为q0的状态引一条标记为ε的弧；<br>从标记为q(q∈F)的状态到标记为Y的状态分别引一条标记为ε的弧。</li><li>去掉所有的不可达状态。<br><img src="..\img\FL&FA\DFA转RE_预处理.png" width="70%" height="70%" align="middle"></li></ul></li><li><p>去掉状态q3：<br><img src="..\img\FL&FA\DFA转RE_例子0.png" width="70%" height="70%" align="middle"></p></li><li><p>去掉状态q4<br><img src="..\img\FL&FA\DFA转RE_例子1.png" width="70%" height="70%" align="middle"></p></li><li><p>合并从标记为q2的状态到标记为Y的状态的两条并行弧。<br><img src="..\img\FL&FA\DFA转RE_例子2.png" width="70%" height="70%" align="middle"></p></li><li><p>去掉状态q0<br><img src="..\img\FL&FA\DFA转RE_例子3.png" width="70%" height="70%" align="middle"></p></li><li><p>并弧<br><img src="..\img\FL&FA\DFA转RE_例子4.png" width="70%" height="70%" align="middle"></p></li><li><p>去掉状态q1<br><img src="..\img\FL&FA\DFA转RE_例子5.png" width="70%" height="70%" align="middle"></p></li><li><p>去掉状态q2<br><img src="..\img\FL&FA\DFA转RE_例子6.png" width="70%" height="70%" align="middle"></p></li></ul><h3 id="注意事项">注意事项</h3><ul><li>不计算自身到自身的弧,如果状态q的入度为n,出度为m,则将状态q及其相关的弧去掉之后,需要添加n*m条新弧。</li></ul><h1>泵引理 与 封闭性</h1><h2 id="泵引理">泵引理</h2><h3 id="定理">定理</h3><img src="..\img\FL&FA\泵引理_定理.png" width="70%" height="70%" align="middle"><h3 id="应用">应用</h3><ul><li><p>例1<br><img src="..\img\FL&FA\泵引理_例1.png" width="70%" height="70%" align="middle"></p></li><li><p>例2<br><img src="..\img\FL&FA\泵引理_例2.png" width="70%" height="70%" align="middle"></p></li><li><p>例3<br><img src="..\img\FL&FA\泵引理_例3.png" width="70%" height="70%" align="middle"></p></li><li><p>例4<br><img src="..\img\FL&FA\泵引理_例4.png" width="70%" height="70%" align="middle"></p></li></ul><h2 id="封闭性">封闭性</h2><h3 id="定义">定义</h3><p><font color='red'>交、并、补、连接、闭包、反转、同态、逆同态 运算都具有封闭性</font></p><ul><li><p>补运算的封闭性<br>如果 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi></mrow><annotation encoding="application/x-tex">L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">L</span></span></span></span> 是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Σ</mi></mrow><annotation encoding="application/x-tex">\Sigma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">Σ</span></span></span></span> 上的RE, 那么 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>L</mi><mo stretchy="true">‾</mo></mover><mo>=</mo><msup><mi mathvariant="normal">Σ</mi><mo lspace="0em" rspace="0em">∗</mo></msup><mo>−</mo><mi>L</mi></mrow><annotation encoding="application/x-tex">\overline{L} = \Sigma^{*} - L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8833em;"></span><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8833em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">L</span></span></span><span style="top:-3.8033em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.772em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">Σ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6887em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">∗</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">L</span></span></span></span> 也是 正则的。</p></li><li><p>交运算的封闭性<br>如果 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi></mrow><annotation encoding="application/x-tex">L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">L</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span> 是 RE, 那么 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo>∩</mo><mi>M</mi></mrow><annotation encoding="application/x-tex">L\cap M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">L</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∩</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span> 也是 正则的。</p></li><li><p>同态 的定义<br><img src="..\img\FL&FA\同态的定义.png" width="70%" height="70%" align="middle"></p></li><li><p>逆同态 的定义<br><img src="..\img\FL&FA\逆同态的定义.png" width="70%" height="70%" align="middle"></p></li></ul><h3 id="例子-3">例子</h3><ul><li><p>例1<br><img src="..\img\FL&FA\封闭性_例1.png" width="70%" height="70%" align="middle"></p></li><li><p>例2<br><img src="..\img\FL&FA\封闭性_例2.png" width="70%" height="70%" align="middle"></p></li><li><p>例3<br><img src="..\img\FL&FA\封闭性_例3.png" width="70%" height="70%" align="middle"></p></li></ul><h1>Myhill-Nerode定理</h1><p>定理规定以下三个命题同时成立:</p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo>⊆</mo><msup><mi mathvariant="normal">Σ</mi><mo>∗</mo></msup></mrow><annotation encoding="application/x-tex">L \subseteq \Sigma^*</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.136em;"></span><span class="mord mathnormal">L</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⊆</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6887em;"></span><span class="mord"><span class="mord">Σ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6887em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span></span></span></span> 是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mi>L</mi></mrow><annotation encoding="application/x-tex">RL</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mord mathnormal">L</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi></mrow><annotation encoding="application/x-tex">L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">L</span></span></span></span> 是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi mathvariant="normal">Σ</mi><mo>∗</mo></msup></mrow><annotation encoding="application/x-tex">\Sigma^*</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6887em;"></span><span class="mord"><span class="mord">Σ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6887em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span></span></span></span>上的某一个具有 <font color='red'>有穷指数</font> 的<font color='red'> 右不变等价关系</font> 的 <font color='red'>并</font></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>R</mi><mi>L</mi></msub></mrow><annotation encoding="application/x-tex">R_L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">L</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>具有有穷指数</li></ul><h2 id="右不变等价关系">右不变等价关系</h2><p><strong>定义</strong>：设<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span>是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi mathvariant="normal">Σ</mi><mo lspace="0em" rspace="0em">∗</mo></msup></mrow><annotation encoding="application/x-tex">\Sigma^{*}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6887em;"></span><span class="mord"><span class="mord">Σ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6887em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">∗</span></span></span></span></span></span></span></span></span></span></span></span>上的等价关系，对于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∀</mi><mrow><mi>x</mi><mo separator="true">,</mo><mi>y</mi></mrow><mo>∈</mo><msup><mi mathvariant="normal">Σ</mi><mo lspace="0em" rspace="0em">∗</mo></msup></mrow><annotation encoding="application/x-tex">\forall{x,y} \in \Sigma^{*}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord">∀</span><span class="mord"><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6887em;"></span><span class="mord"><span class="mord">Σ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6887em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">∗</span></span></span></span></span></span></span></span></span></span></span></span>, 如果<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mi>R</mi><mi>y</mi></mrow><annotation encoding="application/x-tex">xRy</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">x</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span>成立，则<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mi>z</mi><mi>R</mi><mi>y</mi><mi>z</mi></mrow><annotation encoding="application/x-tex">xzRyz</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">x</span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mord mathnormal" style="margin-right:0.04398em;">yz</span></span></span></span>也成立，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>z</mi><mo>∈</mo><msup><mi mathvariant="normal">Σ</mi><mo lspace="0em" rspace="0em">∗</mo></msup></mrow><annotation encoding="application/x-tex">z\in\Sigma^{*}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6887em;"></span><span class="mord"><span class="mord">Σ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6887em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">∗</span></span></span></span></span></span></span></span></span></span></span></span>, 则<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span>被称为 右不变等价关系</p><ul><li>关系<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>R</mi><mi>m</mi></msub></mrow><annotation encoding="application/x-tex">R_m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>R</mi><mi>L</mi></msub></mrow><annotation encoding="application/x-tex">R_L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">L</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>是 右不变等价关系</li></ul><h3 id="关系RM">关系RM</h3><ul><li>设DFA M，M所确定的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi mathvariant="normal">Σ</mi><mo>∗</mo></msup></mrow><annotation encoding="application/x-tex">Σ^*</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6887em;"></span><span class="mord"><span class="mord">Σ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6887em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span></span></span></span>上的关系 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>R</mi><mi>M</mi></msub></mrow><annotation encoding="application/x-tex">R_M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">M</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 定义为：<br>对于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∀</mi><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo>∈</mo><mi mathvariant="normal">Σ</mi><mo>∗</mo></mrow><annotation encoding="application/x-tex">∀x,y∈Σ*</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord">∀</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">Σ</span><span class="mord">∗</span></span></span></span><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><msub><mi>R</mi><mi>M</mi></msub><mi>y</mi><mo>⇔</mo><mi>δ</mi><mo stretchy="false">(</mo><mi>q</mi><mn>0</mn><mo separator="true">,</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>δ</mi><mo stretchy="false">(</mo><mi>q</mi><mn>0</mn><mo separator="true">,</mo><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">x R_M y ⇔ δ(q0,x)=δ(q0,y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">x</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">M</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⇔</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03785em;">δ</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03785em;">δ</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span></li><li>也就是说： <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><msub><mi>R</mi><mi>M</mi></msub><mi>y</mi><mo>⇔</mo><mi mathvariant="normal">∃</mi><mi>q</mi><mo>∈</mo><mi>Q</mi><mtext>，</mtext><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo>∈</mo><mi>s</mi><mi>e</mi><mi>t</mi><mo stretchy="false">(</mo><mi>q</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">x R_M y ⇔ ∃q∈Q，x,y∈set(q)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">x</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">M</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⇔</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord">∃</span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">Q</span><span class="mord cjk_fallback">，</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">se</span><span class="mord mathnormal">t</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="mclose">)</span></span></span></span>。</li><li>或者说：<font color='red'>M从<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>q</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">q_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>开始读入x和y以后进入同一个状态。</font></li></ul></li></ul><h3 id="关系RL：">关系RL：</h3><ul><li>设<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo>⊆</mo><mi mathvariant="normal">Σ</mi><mo>∗</mo></mrow><annotation encoding="application/x-tex">L ⊆ Σ*</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.136em;"></span><span class="mord mathnormal">L</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⊆</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">Σ</span><span class="mord">∗</span></span></span></span>，L确定的Σ*上的关系 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>R</mi><mi>L</mi></msub></mrow><annotation encoding="application/x-tex">R_L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">L</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 定义为：<br>对于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∀</mi><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo>∈</mo><mi mathvariant="normal">Σ</mi><mo>∗</mo></mrow><annotation encoding="application/x-tex">∀x,y∈Σ*</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord">∀</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">Σ</span><span class="mord">∗</span></span></span></span><br><font color='red'><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><msub><mi>R</mi><mi>L</mi></msub><mi>y</mi><mo>⇔</mo><mo stretchy="false">(</mo><mi mathvariant="normal">∀</mi><mi>z</mi><mo>∈</mo><msup><mi mathvariant="normal">Σ</mi><mo>∗</mo></msup><mtext>，</mtext><mi>x</mi><mi>z</mi><mo>∈</mo><mi>L</mi><mo>⇔</mo><mi>y</mi><mi>z</mi><mo>∈</mo><mi>L</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">x R_L y ⇔ (∀z∈Σ^*，xz∈L ⇔ yz∈L)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">x</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">L</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⇔</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">∀</span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0391em;"></span><span class="mord"><span class="mord">Σ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6887em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span><span class="mord cjk_fallback">，</span><span class="mord mathnormal">x</span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">L</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⇔</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7335em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.04398em;">yz</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class="mclose">)</span></span></span></span></font></li></ul><h3 id="二者关系">二者关系</h3><ul><li>如果<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><msub><mi>R</mi><mi>M</mi></msub><mi>y</mi></mrow><annotation encoding="application/x-tex">x R_M y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">x</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">M</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span>，则 <font color='red'>一定有</font> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><msub><mi>R</mi><mrow><mi>L</mi><mo stretchy="false">(</mo><mi>M</mi><mo stretchy="false">)</mo></mrow></msub><mi>y</mi></mrow><annotation encoding="application/x-tex">x R_{L(M)} y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0385em;vertical-align:-0.3552em;"></span><span class="mord mathnormal">x</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.5198em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">L</span><span class="mopen mtight">(</span><span class="mord mathnormal mtight" style="margin-right:0.10903em;">M</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3552em;"><span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span></li><li>如果<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><msub><mi>R</mi><mrow><mi>L</mi><mo stretchy="false">(</mo><mi>M</mi><mo stretchy="false">)</mo></mrow></msub><mi>y</mi></mrow><annotation encoding="application/x-tex">x R_{L(M)} y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0385em;vertical-align:-0.3552em;"></span><span class="mord mathnormal">x</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.5198em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">L</span><span class="mopen mtight">(</span><span class="mord mathnormal mtight" style="margin-right:0.10903em;">M</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3552em;"><span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span>，则 <font color='red'>不一定有</font> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><msub><mi>R</mi><mi>M</mi></msub><mi>y</mi></mrow><annotation encoding="application/x-tex">x R_M y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">x</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">M</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span></li><li><font color='red'><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><msup><mi mathvariant="normal">Σ</mi><mo lspace="0em" rspace="0em">∗</mo></msup><mi mathvariant="normal">/</mi><msub><mi>R</mi><mrow><mi>L</mi><mo stretchy="false">(</mo><mi>M</mi><mo stretchy="false">)</mo></mrow></msub><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">|\Sigma^{*}/R_{L(M)}|</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1052em;vertical-align:-0.3552em;"></span><span class="mord">∣</span><span class="mord"><span class="mord">Σ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6887em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">∗</span></span></span></span></span></span></span></span></span><span class="mord">/</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.5198em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">L</span><span class="mopen mtight">(</span><span class="mord mathnormal mtight" style="margin-right:0.10903em;">M</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3552em;"><span></span></span></span></span></span></span><span class="mord">∣</span></span></span></span> ≤ <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><msup><mi mathvariant="normal">Σ</mi><mo lspace="0em" rspace="0em">∗</mo></msup><mi mathvariant="normal">/</mi><msub><mi>R</mi><mi>M</mi></msub><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">|\Sigma^{*}/R_M|</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord"><span class="mord">Σ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6887em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">∗</span></span></span></span></span></span></span></span></span><span class="mord">/</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">M</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">∣</span></span></span></span> ≤ <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Q</mi></mrow><annotation encoding="application/x-tex">Q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">Q</span></span></span></span></font>, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>R</mi><mi>M</mi></msub></mrow><annotation encoding="application/x-tex">R_M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">M</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>R</mi><mrow><mi>L</mi><mo stretchy="false">(</mo><mi>M</mi><mo stretchy="false">)</mo></mrow></msub></mrow><annotation encoding="application/x-tex">R_{L(M)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0385em;vertical-align:-0.3552em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.5198em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">L</span><span class="mopen mtight">(</span><span class="mord mathnormal mtight" style="margin-right:0.10903em;">M</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3552em;"><span></span></span></span></span></span></span></span></span></span> 的 <font color='red'>加细</font></li></ul><h3 id="例子-4">例子</h3><img src="..\img\FL&FA\RM和RL例子.png" width="70%" height="70%" align="middle"><h2 id="关系的指数">关系的指数</h2><h3 id="R-的指数"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span> 的指数</h3><p>设<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span>是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi mathvariant="normal">Σ</mi><mo lspace="0em" rspace="0em">∗</mo></msup></mrow><annotation encoding="application/x-tex">\Sigma^{*}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6887em;"></span><span class="mord"><span class="mord">Σ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6887em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">∗</span></span></span></span></span></span></span></span></span></span></span></span>上的等价关系,则称 <font color='red'><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><msup><mi mathvariant="normal">Σ</mi><mo lspace="0em" rspace="0em">∗</mo></msup><mi mathvariant="normal">/</mi><mi>R</mi><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">|\Sigma^{*} / R|</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord"><span class="mord">Σ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6887em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">∗</span></span></span></span></span></span></span></span></span><span class="mord">/</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mord">∣</span></span></span></span></font> 是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span> 关于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi mathvariant="normal">Σ</mi><mo lspace="0em" rspace="0em">∗</mo></msup></mrow><annotation encoding="application/x-tex">\Sigma^{*}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6887em;"></span><span class="mord"><span class="mord">Σ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6887em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">∗</span></span></span></span></span></span></span></span></span></span></span></span>的指数。</p><h3 id="R-的一个等价类"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span> 的一个等价类</h3><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi mathvariant="normal">Σ</mi><mo lspace="0em" rspace="0em">∗</mo></msup></mrow><annotation encoding="application/x-tex">\Sigma^{*}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6887em;"></span><span class="mord"><span class="mord">Σ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6887em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">∗</span></span></span></span></span></span></span></span></span></span></span></span>的关于R的一个等价类,也就是<font color='red'><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi mathvariant="normal">Σ</mi><mo lspace="0em" rspace="0em">∗</mo></msup><mi mathvariant="normal">/</mi><mi>R</mi></mrow><annotation encoding="application/x-tex">\Sigma^{*}/R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord">Σ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6887em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">∗</span></span></span></span></span></span></span></span></span><span class="mord">/</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span></font>的任意一个<strong>元素</strong></p><h1>极小化</h1><h2 id="定义-2">定义</h2><p>最小状态DFA的含义:</p><ul><li><p>没有多余状态(死状态)</p><ul><li>如何消除多余状态？删除即可。<br><img src="..\img\FL&FA\极小化_定义.png" width="70%" height="70%" align="middle"></li></ul></li><li><p>没有两个状态是互相等价（不可区别）</p><ul><li>兼容性（一致性）条件——同是终态或同是非终态</li><li>传播性（蔓延性）条件——对于所有输入符号，状态s和状态t必须转换到等价的状态里。</li></ul></li></ul><h2 id="例子：">例子：</h2><p><strong>最小化下图所示的DFA</strong><br><img src="..\img\FL&FA\极小化_例1.png" width="60%" height="70%" align="middle"></p><ol><li>分成终态和非终态：</li></ol><ul><li>将Ｍ的状态分为两个子集一个由终态 k1=｛Ｃ，Ｄ，Ｅ，Ｆ｝组成，一个由非终态 k2=｛Ｓ，Ａ，Ｂ｝组成。</li></ul><ol start="2"><li><p>考察｛Ｓ，Ａ，Ｂ｝是否可分。<br><img src="..\img\FL&FA\极小化_例2.png" width="20%" height="10%" align="middle"><br>因为Ａ经过a到达C属于k1.而S经过a到达A属于k2。B经过a到达A属于k2，所以K2继续划分为{S，B}，{A}。</p></li><li><p>考察｛Ｓ，Ｂ｝是否可再分：<br>B经过b到达D属于k1。S经过b到达B属于k2，所以S，B可以划分。划分为{S},{B}</p></li><li><p>考察｛Ｃ，Ｄ，Ｅ，Ｆ｝是否可再分：<br>因为Ｃ，Ｄ，Ｅ，Ｆ经过 a和b 到达的状态都属于｛Ｃ，Ｄ，Ｅ，Ｆ｝=k1 所以相同，所以不可再分。</p></li><li><p>｛Ｃ，Ｄ，Ｅ，Ｆ｝以｛Ｄ｝来代替则，因为CDEF相同，你也可以用C来代替。无所谓的最小化的DFA如图：<br><img src="..\img\FL&FA\极小化_例3.png" width="50%" height="70%" align="middle" alt="极小化_例3"></p></li></ol><h1>RE运算</h1><h2 id="定义-3">定义</h2><p>正则表达式(regular expression,RE)</p><ol><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Φ</mi></mrow><annotation encoding="application/x-tex">\Phi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">Φ</span></span></span></span> 是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Σ</mi></mrow><annotation encoding="application/x-tex">\Sigma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">Σ</span></span></span></span>上的RE,它表示语言 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Φ</mi></mrow><annotation encoding="application/x-tex">\Phi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">Φ</span></span></span></span>；</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">ϵ</span></span></span></span> 是∑上的RE,它表示语言<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">{</mo><mi>ϵ</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\{\epsilon\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord mathnormal">ϵ</span><span class="mclose">}</span></span></span></span>；</li><li>对于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∀</mi><mi>a</mi><mo>∈</mo><mi mathvariant="normal">Σ</mi></mrow><annotation encoding="application/x-tex">\forall{a}\in \Sigma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7335em;vertical-align:-0.0391em;"></span><span class="mord">∀</span><span class="mord"><span class="mord mathnormal">a</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">Σ</span></span></span></span>, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">{a}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord"><span class="mord mathnormal">a</span></span></span></span></span>是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Σ</mi></mrow><annotation encoding="application/x-tex">\Sigma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">Σ</span></span></span></span>上的RE,它表示语言<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">{</mo><mi>a</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\{a\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord mathnormal">a</span><span class="mclose">}</span></span></span></span>；</li><li>如果r和s分别是∑上表示语言R和S的RE,则：<ul><li>r与s的“和” (r+s)是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Σ</mi></mrow><annotation encoding="application/x-tex">\Sigma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">Σ</span></span></span></span>上的RE,(r+s)表达的语言为R∪S；</li><li>r与s的“乘积” (rs)是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Σ</mi></mrow><annotation encoding="application/x-tex">\Sigma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">Σ</span></span></span></span>上的RE,(rs)表达的语言为RS；</li><li>r的克林闭包(r*)是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Σ</mi></mrow><annotation encoding="application/x-tex">\Sigma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">Σ</span></span></span></span>上的RE,(r*)表达的语言为R*。</li></ul></li><li>只有满足1、2、3、4的才是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Σ</mi></mrow><annotation encoding="application/x-tex">\Sigma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">Σ</span></span></span></span>上的RE。</li></ol><h2 id="表示">表示</h2><ul><li>0,表示语言{0}</li><li>1,表示语言{1}</li><li>(0+1),表示语言{0,1}</li><li>(01),表示语言{01}</li><li>((0+1)*),表示语言{0,1}*</li></ul><h2 id="运算">运算</h2><ul><li>结合律：<br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>r</mi><mi>s</mi><mo stretchy="false">)</mo><mi>t</mi><mo>=</mo><mi>r</mi><mo stretchy="false">(</mo><mi>s</mi><mi>t</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(rs)t=r(st)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">rs</span><span class="mclose">)</span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mopen">(</span><span class="mord mathnormal">s</span><span class="mord mathnormal">t</span><span class="mclose">)</span></span></span></span><br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>r</mi><mo>+</mo><mi>s</mi><mo stretchy="false">)</mo><mo>+</mo><mi>t</mi><mo>=</mo><mi>r</mi><mo>+</mo><mo stretchy="false">(</mo><mi>s</mi><mo>+</mo><mi>t</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(r+s)+t=r+(s+t)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">s</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6151em;"></span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">t</span><span class="mclose">)</span></span></span></span></li><li>分配律：<br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mo stretchy="false">(</mo><mi>s</mi><mo>+</mo><mi>t</mi><mo stretchy="false">)</mo><mo>=</mo><mi>r</mi><mi>s</mi><mo>+</mo><mi>r</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">r(s+t)=rs+rt</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mopen">(</span><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">t</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">rs</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6151em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">t</span></span></span></span><br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>s</mi><mo>+</mo><mi>t</mi><mo stretchy="false">)</mo><mi>r</mi><mo>=</mo><mi>s</mi><mi>r</mi><mo>+</mo><mi>t</mi><mi>r</mi></mrow><annotation encoding="application/x-tex">(s+t)r=sr+tr</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">t</span><span class="mclose">)</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">sr</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6151em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span></span></span></span></li><li>交换律：<br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mo>+</mo><mi>s</mi><mo>=</mo><mi>s</mi><mo>+</mo><mi>r</mi></mrow><annotation encoding="application/x-tex">r+s=s+r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span></span></span></span></li><li>幂等律：<br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mo>+</mo><mi>r</mi><mo>=</mo><mi>r</mi></mrow><annotation encoding="application/x-tex">r+r=r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span></span></span></span></li><li>加法运算零元素：<br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mo>+</mo><mi mathvariant="normal">Φ</mi><mo>=</mo><mi>r</mi></mrow><annotation encoding="application/x-tex">r+Φ=r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">Φ</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span></span></span></span></li><li>乘法运算单位元：<br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mi>ε</mi><mo>=</mo><mi>ε</mi><mi>r</mi><mo>=</mo><mi>r</mi></mrow><annotation encoding="application/x-tex">rε=εr=r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">ε</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">ε</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span></span></span></span></li><li>乘法运算零元素：<br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mi mathvariant="normal">Φ</mi><mo>=</mo><mi mathvariant="normal">Φ</mi><mi>r</mi><mo>=</mo><mi mathvariant="normal">Φ</mi></mrow><annotation encoding="application/x-tex">rΦ=Φr=Φ</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord">Φ</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">Φ</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">Φ</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo stretchy="false">(</mo><mi mathvariant="normal">Φ</mi><mo stretchy="false">)</mo><mo>=</mo><mi mathvariant="normal">Φ</mi></mrow><annotation encoding="application/x-tex">L(Φ)=Φ</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class="mopen">(</span><span class="mord">Φ</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">Φ</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo stretchy="false">(</mo><mi>ε</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">{</mo><mi>ε</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">L(ε)=\{ε\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class="mopen">(</span><span class="mord mathnormal">ε</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord mathnormal">ε</span><span class="mclose">}</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo stretchy="false">(</mo><mi>a</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">{</mo><mi>a</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">L(a)=\{a\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord mathnormal">a</span><span class="mclose">}</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo stretchy="false">(</mo><mi>r</mi><mi>s</mi><mo stretchy="false">)</mo><mo>=</mo><mi>L</mi><mo stretchy="false">(</mo><mi>r</mi><mo stretchy="false">)</mo><mi>L</mi><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">L(rs)=L(r)L(s)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class="mopen">(</span><span class="mord mathnormal">rs</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mclose">)</span><span class="mord mathnormal">L</span><span class="mopen">(</span><span class="mord mathnormal">s</span><span class="mclose">)</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo stretchy="false">(</mo><mi>r</mi><mo>+</mo><mi>s</mi><mo stretchy="false">)</mo><mo>=</mo><mi>L</mi><mo stretchy="false">(</mo><mi>r</mi><mo stretchy="false">)</mo><mo>∪</mo><mi>L</mi><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">L(r+s)=L(r)∪L(s)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">s</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∪</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class="mopen">(</span><span class="mord mathnormal">s</span><span class="mclose">)</span></span></span></span></li><li>$L(r*)=(L®)^* $</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo stretchy="false">(</mo><msup><mi mathvariant="normal">Φ</mi><mo>∗</mo></msup><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">{</mo><mi>ε</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">L(Φ^*)=\{ε\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class="mopen">(</span><span class="mord"><span class="mord">Φ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6887em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord mathnormal">ε</span><span class="mclose">}</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo stretchy="false">(</mo><mo stretchy="false">(</mo><mi>r</mi><mo>+</mo><mi>ε</mi><msup><mo stretchy="false">)</mo><mo>∗</mo></msup><mo stretchy="false">)</mo><mo>=</mo><mi>L</mi><mo stretchy="false">(</mo><msup><mi>r</mi><mo>∗</mo></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">L((r+ε)^*)=L(r^*)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class="mopen">((</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">ε</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6887em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6887em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo stretchy="false">(</mo><mo stretchy="false">(</mo><msup><mi>r</mi><mo>∗</mo></msup><msup><mo stretchy="false">)</mo><mo>∗</mo></msup><mo stretchy="false">)</mo><mo>=</mo><mi>L</mi><mo stretchy="false">(</mo><msup><mi>r</mi><mo>∗</mo></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">L((r^*)^*)=L(r^*)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class="mopen">((</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6887em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6887em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6887em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo stretchy="false">(</mo><mo stretchy="false">(</mo><msup><mi>r</mi><mo>∗</mo></msup><msup><mi>s</mi><mo>∗</mo></msup><msup><mo stretchy="false">)</mo><mo>∗</mo></msup><mo stretchy="false">)</mo><mo>=</mo><mi>L</mi><mo stretchy="false">(</mo><mo stretchy="false">(</mo><mi>r</mi><mo>+</mo><mi>s</mi><msup><mo stretchy="false">)</mo><mo>∗</mo></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">L((r^*s^*)^*)=L((r+s)^*)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class="mopen">((</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6887em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6887em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6887em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class="mopen">((</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">s</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6887em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></li><li>如果<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo stretchy="false">(</mo><mi>r</mi><mo stretchy="false">)</mo><mo>⊆</mo><mi>L</mi><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">L(r) \subseteq L(s)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⊆</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class="mopen">(</span><span class="mord mathnormal">s</span><span class="mclose">)</span></span></span></span>,则<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mo>+</mo><mi>s</mi><mo>=</mo><mi>s</mi></mrow><annotation encoding="application/x-tex">r+s=s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">s</span></span></span></span></li><li>$L(rn)=(L®)^n $</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>r</mi><mi>n</mi></msup><msup><mi>r</mi><mi>m</mi></msup><mo>=</mo><msup><mi>r</mi><mrow><mi>n</mi><mo>+</mo><mi>m</mi></mrow></msup></mrow><annotation encoding="application/x-tex">r^n r^m=r^{n+m}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6644em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7713em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7713em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">+</span><span class="mord mathnormal mtight">m</span></span></span></span></span></span></span></span></span></span></span></span><br>一般地, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mo>+</mo><mi>ε</mi><mo mathvariant="normal">≠</mo><mi>r</mi><mo separator="true">,</mo><mo stretchy="false">(</mo><mi>r</mi><mi>s</mi><msup><mo stretchy="false">)</mo><mi>n</mi></msup><mo mathvariant="normal">≠</mo><msup><mi>r</mi><mi>n</mi></msup><msup><mi>s</mi><mi>n</mi></msup><mo separator="true">,</mo><mi>r</mi><mi>s</mi><mo mathvariant="normal">≠</mo><mi>s</mi><mi>r</mi></mrow><annotation encoding="application/x-tex">r+ε≠r,(rs)^n ≠r^ns^n,rs≠sr</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">ε</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel"><span class="mrel"><span class="mord vbox"><span class="thinbox"><span class="rlap"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="inner"><span class="mord"><span class="mrel"></span></span></span><span class="fix"></span></span></span></span></span><span class="mrel">=</span></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mopen">(</span><span class="mord mathnormal">rs</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel"><span class="mrel"><span class="mord vbox"><span class="thinbox"><span class="rlap"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="inner"><span class="mord"><span class="mrel"></span></span></span><span class="fix"></span></span></span></span></span><span class="mrel">=</span></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">rs</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel"><span class="mrel"><span class="mord vbox"><span class="thinbox"><span class="rlap"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="inner"><span class="mord"><span class="mrel"></span></span></span><span class="fix"></span></span></span></span></span><span class="mrel">=</span></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">sr</span></span></span></span></li><li>幂<br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>r</mi><mn>0</mn></msup><mo>=</mo><mi>ε</mi></mrow><annotation encoding="application/x-tex">r^0=ε</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">ε</span></span></span></span><br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>r</mi><mi>n</mi></msup><mo>=</mo><msup><mi>r</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msup><mi>r</mi></mrow><annotation encoding="application/x-tex">r^n=r^{n-1}r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6644em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span></span></span></span></li></ul>]]></content>
      
      
      <categories>
          
          <category> 编译原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编译原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity-物理系统之刚体加力</title>
      <link href="/post/3912f0e7.html"/>
      <url>/post/3912f0e7.html</url>
      
        <content type="html"><![CDATA[<h2 id="刚体自带添加力的方法">刚体自带添加力的方法</h2><p>给刚体加力的目标是 让其有一个<strong>速度</strong> 朝向<strong>某一个方向移动</strong></p><h3 id="获取刚体组件">获取刚体组件</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Rigidbody rigidBody = <span class="keyword">this</span>.GetComponent&lt;Rigidbody&gt;();</span><br></pre></td></tr></table></figure><h3 id="添加力">添加力</h3><p>相对世界坐标 <font color="green">rigidBody.AddForce()</font></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rigidBody.AddForce(Vector3.forward * <span class="number">10</span>);</span><br></pre></td></tr></table></figure><p>相对本地坐标 <font color="green">rigidBody.AddRelativeForce()</font></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rigidBody.AddRelativeForce(Vector3.forward * <span class="number">10</span>);</span><br></pre></td></tr></table></figure><h3 id="添加扭矩力">添加扭矩力</h3><p>相对世界坐标 <font color="green">rigidBody.AddTorque()</font></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rigidBody.AddTorque(Vector3.up * <span class="number">10</span>);</span><br></pre></td></tr></table></figure><p>相对本地坐标 <font color="green">rigidBody.AddRelativeTorque()</font></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rigidBody.AddRelativeTorque(Vector3.up * <span class="number">10</span>);</span><br></pre></td></tr></table></figure><h3 id="直接改变速度">直接改变速度</h3><p><font color="green">rigidBody.velocity</font></p><p>这个速度方向 是相对于 世界坐标系的</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rigidBody.velocity = Vector3.forward * <span class="number">5</span>;</span><br></pre></td></tr></table></figure><h3 id="模拟爆炸效果">模拟爆炸效果</h3><p><font color="green">rigidBody.AddExplosionForce()</font></p><ul><li>模拟爆炸的力 一定是 <strong>所有希望产生爆炸效果影响的对象都需要得到他们的刚体</strong> 来执行这个方法 才能都有效果</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rigidBody.AddExplosionForce(<span class="number">100</span>, Vector3.zero, <span class="number">10</span>);</span><br></pre></td></tr></table></figure><h2 id="力的几种模式">力的几种模式</h2><ul><li>第二个参数 力的模式 主要的作用 就是 计算方式不同</li><li>由于4中计算方式的不同 最终的移动速度就会不同</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rigidBody.AddForce(Vector3.forward * <span class="number">10</span>, ForceMode.Acceleration);</span><br></pre></td></tr></table></figure><h3 id="Acceleration">Acceleration</h3><ul><li>给物体增加一个持续的加速度，忽略其质量</li><li>v = Ft/m</li><li>F:(0,0,10)</li><li>t:0.02s</li><li>m:默认为1</li><li>v = 10*0.02/ 1 = 0.2m/s</li><li>每物理帧移动0.2m/s*0.02 = 0.004m</li></ul><h3 id="Force">Force</h3><ul><li>给物体添加一个持续的力，与物体的质量有关</li><li>v = Ft/m</li><li>F:(0,0,10)</li><li>t:0.02s</li><li>m:2kg</li><li>v = 10*0.02/ 2 = 0.1m/s</li><li>每物理帧移动0.1m/s*0.02 = 0.002m</li></ul><h3 id="Impulse">Impulse</h3><ul><li>给物体添加一个瞬间的力，与物体的质量有关,忽略时间 默认为1</li><li>v = Ft/m</li><li>F:(0,0,10)</li><li>t:默认为1</li><li>m:2kg</li><li>v = 10*1/ 2 = 5m/s</li><li>每物理帧移动5m/s*0.02 = 0.1m</li></ul><h3 id="VelocityChange">VelocityChange</h3><ul><li>给物体添加一个瞬时速度，忽略质量，忽略时间</li><li>v = Ft/m</li><li>F:(0,0,10)</li><li>t:默认为1</li><li>m:默认为1</li><li>v = 10*1/ 1 = 10m/s</li><li>每物理帧移动10m/s*0.02 = 0.2m</li></ul><h2 id="立场脚本">立场脚本</h2><figure class="highlight plaintext"><figcaption><span>Force```组件</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">添加恒定力</span><br><span class="line"></span><br><span class="line">## 补充 刚体的休眠</span><br><span class="line">Unity为了**节约性能**，会对一些最近没改变的刚体进行休眠，可能会影响后续操作</span><br><span class="line">获取刚体是否处于休眠状态</span><br><span class="line">```C#</span><br><span class="line">if (rigidBody.IsSleeping())</span><br><span class="line">&#123;</span><br><span class="line">    //就唤醒它</span><br><span class="line">    rigidBody.WakeUp();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity-物理系统之射线检测</title>
      <link href="/post/4d19935.html"/>
      <url>/post/4d19935.html</url>
      
        <content type="html"><![CDATA[<h2 id="什么是射线检测">什么是射线检测</h2><p>解决以下问题：</p><ul><li>鼠标选择场景上一物体</li><li>FPS射击游戏（无弹道-不产生实际的子弹对象进行移动）</li><li>等需要判断一条线和物体的碰撞情况<br>它可以在<strong>指定点</strong>发射一个<strong>指定方向</strong>的射线<br>判断该射线与哪些<strong>碰撞器</strong>相交，得到对应对象</li></ul><h2 id="射线对象">射线对象</h2><p>单独的射线对于我们来说没有实际的意义,我们需要用它<strong>结合物理系统</strong>进行<strong>射线碰撞判断</strong></p><h3 id="3D世界中的射线">3D世界中的射线</h3><ul><li>参数一：起点</li><li>参数二：方向</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ray r = <span class="keyword">new</span> Ray(Vector3.right, Vector3.forward);</span><br></pre></td></tr></table></figure><h3 id="摄像机发射出的射线">摄像机发射出的射线</h3><p><strong>屏幕位置</strong> 为起点<br><strong>摄像机视口方向</strong> 为方向</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ray r2 = Camera.main.ScreenPointToRay(Input.mousePosition);</span><br></pre></td></tr></table></figure><h2 id="碰撞检测-API">碰撞检测 API</h2><p>射线检测也是<strong>瞬时</strong>的<br>执行代码时进行<strong>一次射线检测</strong></p><h3 id="最原始的射线检测">最原始的射线检测</h3><p>准备一条射线</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ray r = <span class="keyword">new</span> Ray(Vector3.zero, Vector3.forward);</span><br></pre></td></tr></table></figure><p><font color='green'>Physics.Raycast()</font></p><ul><li>参数一：射线</li><li>参数二: 检测的最大距离 超出这个距离不检测</li><li>参数三：检测指定层级（不填检测所有层）</li><li>参数四：是否忽略触发器 <code>UseGlobal</code>-使用全局设置 <code>Collide</code>-检测触发器<br><code>Ignore</code>-忽略触发器  不填使用<code>UseGlobal</code></li><li>返回值：bool 当碰撞到对象时 返回 true 没有 返回false</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (Physics.Raycast(r, <span class="number">1000</span>, <span class="number">1</span> &lt;&lt; LayerMask.NameToLayer(<span class="string">&quot;Monster&quot;</span>), </span><br><span class="line">    QueryTriggerInteraction.UseGlobal))</span><br><span class="line">&#123;</span><br><span class="line">    print(<span class="string">&quot;碰撞到了对象&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有一种重载 不用传入 射线 直接传入起点 和 方向 也可以用于判断</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (Physics.Raycast(Vector3.zero, Vector3.forward, <span class="number">1000</span>, </span><br><span class="line">    <span class="number">1</span> &lt;&lt; LayerMask.NameToLayer(<span class="string">&quot;Monster&quot;</span>),QueryTriggerInteraction.UseGlobal))</span><br><span class="line">&#123;</span><br><span class="line">    print(<span class="string">&quot;碰撞到了对象&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="获取相交的单个物体信息">获取相交的单个物体信息</h3><p>物体信息类<br>通过<font color='green'>RaycastHit</font>类 我们得到得到 <strong>碰撞到的对象信息</strong><br>还可以得到一些 碰撞的点 距离 法线等等的信息</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RaycastHit hitInfo;</span><br></pre></td></tr></table></figure><ul><li>参数一：射线</li><li>参数二：<code>RaycastHit</code>是结构体 是<strong>值类型</strong> Unity会通过<strong>out</strong><br>在函数内部处理后 得到碰撞数据后返回到该参数中</li><li>参数三：距离</li><li>参数四：检测指定层级</li><li>参数五：是否忽略触发器</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>( Physics.Raycast(r, <span class="keyword">out</span> hitInfo, <span class="number">1000</span>, <span class="number">1</span>&lt;&lt;LayerMask.NameToLayer(<span class="string">&quot;Monster&quot;</span>), </span><br><span class="line">    QueryTriggerInteraction.UseGlobal) )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//碰撞器信息</span></span><br><span class="line">    print(<span class="string">&quot;碰撞到物体的名字&quot;</span> + hitInfo.collider.gameObject.name);</span><br><span class="line">    <span class="comment">//碰撞到的点</span></span><br><span class="line">    print(hitInfo.point);</span><br><span class="line">    <span class="comment">//法线信息</span></span><br><span class="line">    print(hitInfo.normal);</span><br><span class="line">    <span class="comment">//得到碰撞到对象的位置</span></span><br><span class="line">    print(hitInfo.transform.position);</span><br><span class="line">    <span class="comment">//得到碰撞到对象 离自己的距离</span></span><br><span class="line">    print(hitInfo.distance);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同理 还有一种重载 不用传入 射线 直接传入起点 和 方向 也可以用于判断</p><h3 id="获取相交的多个物体">获取相交的多个物体</h3><p><font color='green'>Physics.RaycastAll()</font></p><p>可以得到<strong>碰撞到的多个对象</strong>，如果没有 就是容量为0的数组</p><ul><li>参数一：射线</li><li>参数二：距离</li><li>参数三：检测指定层级</li><li>参数四：是否忽略触发器</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">RaycastHit[] hits = Physics.RaycastAll(r, <span class="number">1000</span>, <span class="number">1</span> &lt;&lt; LayerMask.NameToLayer(<span class="string">&quot;Monster&quot;</span>),</span><br><span class="line">                                       QueryTriggerInteraction.UseGlobal);</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; hits.Length; i++)</span><br><span class="line">&#123;</span><br><span class="line">    print(<span class="string">&quot;碰到的所有物体 名字分别是&quot;</span> + hits[i].collider.gameObject.name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有一种NonAlloc型的函数 返回的碰撞的数量 通过out得到数据<br><font color='green'>Physics.RaycastNonAlloc()</font></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RaycastHit[] hits;</span><br><span class="line"><span class="keyword">if</span>(Physics.RaycastNonAlloc(r, hits, <span class="number">1000</span>, <span class="number">1</span> &lt;&lt; LayerMask.NameToLayer(<span class="string">&quot;Monster&quot;</span>), </span><br><span class="line">                           QueryTriggerInteraction.UseGlobal) &gt; <span class="number">0</span> )&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用时注意的问题">使用时注意的问题</h3><p><strong>注意</strong>：<br><strong>距离</strong>、<strong>层级</strong>两个参数 都是<strong>int类型</strong><br>当我们传入参数时 一定要明确传入的参数代表的是距离还是层级</p>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity-物理系统之范围检测</title>
      <link href="/post/43ff44cd.html"/>
      <url>/post/43ff44cd.html</url>
      
        <content type="html"><![CDATA[<h2 id="什么是范围检测">什么是范围检测</h2><p>游戏中<strong>瞬时</strong>的攻击范围判断一般会使用范围检测<br>举例：</p><ul><li>玩家在前方5m处释放一个地刺魔法，在此处范围内的对象将受到地刺伤害</li><li>玩家攻击，在前方1米圆形范围内对象都受到害</li></ul><p>类似这种并<strong>没有实体物体</strong> 只想要检测在指定<strong>某一范围</strong>是否让敌方受到伤害时 便可以使用范围判断</p><h2 id="范围检测">范围检测</h2><p><strong>必备条件</strong>：想要<strong>被</strong>范围检测到的对象必须<strong>具备碰撞器</strong><br>注意点：</p><ul><li>范围检测相关API <strong>只有当执行该句代码时</strong> 进行一次范围检测 它是<font color='red'>瞬时</font>的</li><li>范围检测相关API 并<font color='red'>不会真正产生一个碰撞器</font> 只是<strong>碰撞判断计算</strong>而已</li></ul><h3 id="盒状范围检测API">盒状范围检测API</h3><p><font color='green'>Physics.OverlapBox()</font></p><ul><li>参数一：立方体中心点</li><li>参数二：立方体三边大小</li><li>参数三：立方体角度</li><li>参数四：检测指定层级（不填检测所有层）</li><li>参数五：是否忽略触发器 <code>UseGlobal</code>-使用全局设置 <code>Collide</code>-检测触发器 <code>Ignore</code>-忽略触发器 不填使用<code>UseGlobal</code></li><li>返回值：在该范围内的碰撞器（得到了对象碰撞器就可以得到对象的所有信息）</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Collider[] colliders = Physics.OverlapBox(Vector3.zero, Vector3.one, </span><br><span class="line">                    Quaternion.AngleAxis(<span class="number">45</span>, Vector.Up), </span><br><span class="line">                    <span class="number">1</span> &lt;&lt; LayerMask.NameToLayer(<span class="string">&quot;UI&quot;</span>) | </span><br><span class="line">                    <span class="number">1</span> &lt;&lt; LayerMask.NameToLayer(<span class="string">&quot;Default&quot;</span>), </span><br><span class="line">                    QueryTriggerInteraction.UseGlobal);</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; colliders.Length; i++)</span><br><span class="line">&#123;</span><br><span class="line">    print(colliders[i].gameObject.name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另一个API <font color='green'>Physics.OverlapBoxNonAlloc()</font></p><ul><li>返回值：碰撞到的碰撞器<strong>数量</strong></li><li>参数：<strong>传入一个数组</strong>进行存储</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(Physics.OverlapBoxNonAlloc(Vector3.zero, Vector3.one, colliders) != <span class="number">0</span>)&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="球形范围检测API">球形范围检测API</h3><p><font color='green'>Physics.OverlapSphere()</font></p><ul><li>参数一：中心点</li><li>参数二：球半径</li><li>参数三：检测指定层级（不填检测所有层）</li><li>参数四：是否忽略触发器</li><li>返回值：在该范围内的触发器</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">colliders = Physics.OverlapSphere(Vector3.zero, <span class="number">5</span>, </span><br><span class="line">            <span class="number">1</span> &lt;&lt; LayerMask.NameToLayer(<span class="string">&quot;Default&quot;</span>));</span><br></pre></td></tr></table></figure><p>另一个API <font color='green'>Physics.OverlapSphereNonAlloc()</font></p><ul><li>返回值：碰撞到的碰撞器<strong>数量</strong></li><li>参数：传入一个<strong>数组</strong>进行存储</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>( Physics.OverlapSphereNonAlloc(Vector3.zero, <span class="number">5</span>, colliders) != <span class="number">0</span> )&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="胶囊范围检测API">胶囊范围检测API</h3><p><font color='green'>Physics.OverlapCapsule()</font></p><ul><li>参数一：半圆一中心点</li><li>参数二：半圆二中心点</li><li>参数三：半圆半径</li><li>参数四：检测指定层级（不填检测所有层）</li><li>参数五：是否忽略触发器</li><li>返回值：在该范围内的触发器</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">colliders = Physics.OverlapCapsule(Vector3.zero, Vector3.up, <span class="number">1</span>, </span><br><span class="line">            <span class="number">1</span> &lt;&lt; LayerMask.NameToLayer(<span class="string">&quot;UI&quot;</span>), </span><br><span class="line">            QueryTriggerInteraction.UseGlobal);</span><br></pre></td></tr></table></figure><p>另一个API <font color='green'>Physics.OverlapCapsuleNonAlloc()</font></p><ul><li>返回值：碰撞到的碰撞器数量</li><li>参数：传入一个数组进行存储</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( Physics.OverlapCapsuleNonAlloc(Vector3.zero, Vector3.up, <span class="number">1</span>, colliders ) != <span class="number">0</span> )&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结">总结</h2><ul><li>范围检测主要用于<strong>瞬时</strong>的<strong>碰撞范围</strong>检测</li><li>主要掌握 <strong>Physics类中的静态方法：球形 盒装 胶囊三种API的使用</strong>即可</li></ul>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity-LineRenderer组件</title>
      <link href="/post/af0e4a0a.html"/>
      <url>/post/af0e4a0a.html</url>
      
        <content type="html"><![CDATA[<h2 id="LineRenderer是什么">LineRenderer是什么</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">使用它我们可以在场景中绘制线段,一般可以用于</span><br><span class="line">- 绘制攻击范围</span><br><span class="line">- 武器红外线</span><br><span class="line">- 辅助功能</span><br><span class="line">- 其它画线功能</span><br><span class="line"></span><br><span class="line">## LineRender参数相关</span><br><span class="line">- ```Corner Vertices```(角顶点，圆角)</span><br><span class="line">此属性指示在一条线中绘制角时使用了多少个额外的顶点</span><br><span class="line">增加此值，使**线角看起来更圆**</span><br><span class="line">- ```End Cap Vertices```(终端顶点，圆角)</span><br><span class="line">终点圆角</span><br><span class="line">- 其余重点参数在代码部分介绍</span><br><span class="line">## LineRender代码相关</span><br><span class="line">- 动态添加一个线段</span><br><span class="line">```C#</span><br><span class="line">GameObject line = new GameObject();</span><br><span class="line">LineRenderer lineR = line.AddComponent&lt;LineRenderer&gt;;</span><br></pre></td></tr></table></figure><ul><li>首尾相连</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lineR.loop = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><ul><li>开始结束宽</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lineR.startWidth = <span class="number">0.02f</span>;</span><br><span class="line">lineR.endWidth = <span class="number">0.02f</span>;</span><br></pre></td></tr></table></figure><ul><li>开始结束颜色</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lineR.startColor = Color.white;</span><br><span class="line">lineR.endColor = Color.red;</span><br></pre></td></tr></table></figure><ul><li>设置材质</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">m = Resources.Load&lt;Material&gt;(<span class="string">&quot;M&quot;</span>);</span><br><span class="line">lineR.material = m;</span><br></pre></td></tr></table></figure><ul><li>设置点<br>一定注意设置点要<strong>先设置点的个数</strong><br>接着就设置 对应每个点的位置<br>当设置的位置数少于先前设置点的个数时，剩余的点坐标都默认为原点</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">lineR.positionCount = <span class="number">4</span>;</span><br><span class="line">lineR.SetPositions(<span class="keyword">new</span> Vector3[] &#123; <span class="keyword">new</span> Vector3(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>),</span><br><span class="line">                                   <span class="keyword">new</span> Vector3(<span class="number">0</span>,<span class="number">0</span>,<span class="number">5</span>),</span><br><span class="line">                                   <span class="keyword">new</span> Vector3(<span class="number">5</span>,<span class="number">0</span>,<span class="number">5</span>)&#125;);</span><br><span class="line">lineR.SetPosition(<span class="number">3</span>, <span class="keyword">new</span> Vector3(<span class="number">5</span>, <span class="number">0</span>, <span class="number">0</span>));</span><br></pre></td></tr></table></figure><ul><li>是否使用世界坐标系<br>决定了 是否随对象移动而移动</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lineR.useWorldSpace = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><ul><li>让线段受光影响 会接受光数据 进行着色器计算</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lineR.generateLightingData = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><h2 id="例子">例子</h2><h3 id="练习一">练习一</h3><p><strong>请写一个方法，传入一个中心点，传入一个半径，用LineRender画一个圆出来</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DrawLineRenderer</span>(<span class="params">Vector3 centerPos, <span class="built_in">float</span> r, <span class="built_in">int</span> pointNum</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//动态创建 画线对象</span></span><br><span class="line">    GameObject obj = <span class="keyword">new</span> GameObject();</span><br><span class="line">    obj.name = <span class="string">&quot;R&quot;</span>;</span><br><span class="line">    LineRenderer line = obj.AddComponent&lt;LineRenderer&gt;();</span><br><span class="line">    <span class="comment">//设置有多少个点</span></span><br><span class="line">    line.positionCount = pointNum;</span><br><span class="line">    <span class="comment">//让其首尾相连</span></span><br><span class="line">    line.loop = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">//得到每个点之间 间隔的度数</span></span><br><span class="line">    <span class="built_in">float</span> angle = <span class="number">360f</span> / pointNum;</span><br><span class="line">    <span class="comment">//准备得到每一个点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; pointNum; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//知识点</span></span><br><span class="line">        <span class="comment">//1.点加向量 相当于平移点</span></span><br><span class="line">        <span class="comment">//2.四元数 * 向量 相当于在 旋转向量</span></span><br><span class="line">        line.SetPosition(i, centerPos + Quaternion.AngleAxis(angle * i, Vector3.up) * Vector3.forward * r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="练习二">练习二</h3><p><strong>在Game窗口长按鼠标用LineRenderer画出鼠标移动的轨迹</strong></p><ul><li>重点是 如何得到鼠标转世界坐标的 对应点</li><li>知识点<ul><li>得到鼠标位置 <code>Input.mousePosition</code></li><li>把鼠标 转世界坐标 <code>Camera.main.ScreenToWorldPoint(Input.mousePosition);</code></li></ul></li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> LineRenderer line2;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    line2 = <span class="keyword">this</span>.gameObject.AddComponent&lt;LineRenderer&gt;();</span><br><span class="line">    line2.loop = <span class="literal">false</span>;</span><br><span class="line">    line2.startWidth = <span class="number">0.5f</span>;</span><br><span class="line">    line2.endWidth = <span class="number">0.5f</span>;</span><br><span class="line">    line2.positionCount = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> Vector3 nowPos;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>( Input.GetMouseButton(<span class="number">0</span>) )</span><br><span class="line">    &#123;</span><br><span class="line">        line2.positionCount += <span class="number">1</span>;</span><br><span class="line">        nowPos = Input.mousePosition;</span><br><span class="line">        <span class="comment">//设置z轴为横截面深度</span></span><br><span class="line">        nowPos.z = <span class="number">10</span>;</span><br><span class="line">        line2.SetPosition(line2.positionCount - <span class="number">1</span>, Camera.main.ScreenToWorldPoint(nowPos));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity-场景异步切换</title>
      <link href="/post/33841c46.html"/>
      <url>/post/33841c46.html</url>
      
        <content type="html"><![CDATA[<h2 id="场景同步切换">场景同步切换</h2><p><font color='green'>SceneManger.LoadScene()</font></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SceneManger.LoadScene(<span class="string">&quot;TestScene&quot;</span>);</span><br></pre></td></tr></table></figure><p>场景同步切换的<strong>缺点</strong>：</p><ul><li>因为先删除当前场景中所有对象，且去加载新场景的相关信息，会很耗时，造成卡顿</li></ul><h2 id="场景异步切换">场景异步切换</h2><p><font color='green'>SceneManger.LoadSceneAsync()</font></p><p>和<strong>资源异步加载</strong>几乎一致，有两种方法</p><h3 id="通过事件回调函数-异步加载">通过事件回调函数 异步加载</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">AsyncOperation ao = SceneManger.LoadSceneAsync(<span class="string">&quot;TestScene&quot;</span>);</span><br><span class="line">ao.completed += (a) =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    print(<span class="string">&quot;加载结束&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="通过协程-异步加载">通过协程 异步加载</h3><ul><li>需要注意的是 加载场景会把当前场景上<strong>没有特别处理</strong>的对象<strong>都删除了</strong>，所以<strong>协程中的部分逻辑执行不了</strong></li><li>解决思路：<br>让处理场景加载的<strong>脚本依附的对象</strong> 过场景时<strong>不被移除</strong></li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">DontDestroyOnLoad(<span class="keyword">this</span>.gameObject);</span><br><span class="line">StartCoroutine(LoadScene(<span class="string">&quot;TestScene&quot;</span>));</span><br><span class="line"><span class="function">IEnumerator <span class="title">LoadScene</span>(<span class="params"><span class="built_in">string</span> name</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//第一步</span></span><br><span class="line">    <span class="comment">//异步加载场景</span></span><br><span class="line">    AsyncOperation ao = SceneManager.LoadSceneAsync(name);</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">return</span> ao;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用协程的好处">使用协程的好处</h4><ul><li>可以在异步<strong>加载场景的同时</strong>做一些别的逻辑，比如<strong>更新进度条</strong></li></ul><h5 id="方法一">方法一</h5><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//利用 场景异步加载的进度去更新 不是特别准确</span></span><br><span class="line"><span class="function">IEnumerator <span class="title">LoadScene</span>(<span class="params"><span class="built_in">string</span> name</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//第一步</span></span><br><span class="line">    <span class="comment">//异步加载场景</span></span><br><span class="line">    AsyncOperation ao = SceneManager.LoadSceneAsync(name);</span><br><span class="line">    <span class="keyword">while</span>(!ao.isDone)</span><br><span class="line">    &#123;</span><br><span class="line">        print(ao.progress);</span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//离开循环后 就会认为场景加载结束</span></span><br><span class="line"><span class="comment">//可以把进度条顶满 然后 隐藏进度条</span></span><br></pre></td></tr></table></figure><h5 id="方法二">方法二</h5><p>根据游戏规则<strong>自定义</strong>进度条变化的条件,例如：</p><ul><li>场景加载结束 更新20%进度</li><li>动态加载怪物 再更新20%进度</li><li>动态加载场景模型 认为加载结束 进度条顶满</li><li>隐藏进度条</li></ul><h2 id="总结">总结</h2><h3 id="事件回调函数">事件回调函数</h3><ul><li>优点：写法简单，逻辑清晰</li><li>缺点：只能<strong>加载完场景</strong>做一些事情 不能再加载过程中处理逻辑</li></ul><h3 id="协程异步加载">协程异步加载</h3><ul><li>优点：可以在<strong>加载过程中</strong>处理逻辑，比如进度条更新等</li><li>缺点：写法较为麻烦，要通过协程</li></ul>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity-物理系统之碰撞检测</title>
      <link href="/post/2b4a076a.html"/>
      <url>/post/2b4a076a.html</url>
      
        <content type="html"><![CDATA[<p><strong>碰撞</strong>和<strong>触发</strong>响应函数 属于 特殊的<font color="red">生命周期函数</font> 也是<strong>通过反射调用</strong></p><h2 id="知识点回顾">知识点回顾</h2><ul><li>如何让两个游戏物体之间<strong>产生碰撞</strong> – <font color="blue">至少1个刚体 和 两个碰撞器</font></li><li>如何让两个物体之间<strong>碰撞时表现出不同效果</strong> – <font color="blue">物理材质</font></li><li><strong>触发器</strong>的作用是什么 – <font color="blue">让两个物体碰撞没有物理效果，只进行碰撞处理</font></li></ul><h2 id="物理碰撞检测响应函数">物理碰撞检测响应函数</h2><figure class="highlight plaintext"><figcaption><span>参数 包含了 **碰到自己的对象**的相关信息</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- 碰撞对象 的碰撞器 ```collision.collider```</span><br><span class="line">- 碰撞对象 的依附对象 ```collision.gameObject```</span><br><span class="line">- 碰撞对象 的依附对象的位置 ```collision.transform```</span><br><span class="line">- 触碰点 个数 ```collision.contactCount```</span><br><span class="line">- 接触点 具体坐标 ```ContactPoint[] pos = collision.contacts;```</span><br><span class="line">- 只要得到了 碰撞到的对象的 任意一个信息 就可以得到它的所有信息</span><br><span class="line"></span><br><span class="line">### 碰撞 接触时 自动执行</span><br><span class="line">&lt;font color=&quot;green&quot;&gt;OncollisionEnter(Collision collision)&lt;/font&gt;</span><br><span class="line"></span><br><span class="line">```C#</span><br><span class="line">private void OncollisionEnter(Collision collision)</span><br><span class="line">&#123;</span><br><span class="line">    print(this.name + &quot;被&quot; + collision.gameObject.name + &quot;撞到了&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="碰撞-结束分离时-自动执行">碰撞 结束分离时 自动执行</h3><p><font color="green">OnCollisionExit(Collision collision)</font></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnCollisionExit</span>(<span class="params">Collision collision</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    print(<span class="keyword">this</span>.name + <span class="string">&quot;被&quot;</span> + collision.gameObject.name + <span class="string">&quot;结束碰撞了&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="碰撞-相互接触时-自动不停执行">碰撞 相互接触时 自动不停执行</h3><p><font color="green">OnCollisionStay(Collision collision)</font></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnCollisionStay</span>(<span class="params">Collision collision</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    print(<span class="keyword">this</span>.name + <span class="string">&quot;一直在和&quot;</span> + collision.gameObject.name + <span class="string">&quot;接触&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="触发器检测响应函数">触发器检测响应函数</h2><h3 id="触发-开始时-自动调用">触发 开始时 自动调用</h3><p><font color="green">OnTriggerEnter(Collider other)</font></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnTriggerEnter</span>(<span class="params">Collider other</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    print(<span class="keyword">this</span>.name + <span class="string">&quot;被&quot;</span> + other.gameObject.name + <span class="string">&quot;触发了&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="触发-结束时-自动调用">触发 结束时 自动调用</h3><p><font color="green">OnTriggerExit(Collider other)</font></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnTriggerExit</span>(<span class="params">Collider other</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    print(<span class="keyword">this</span>.name + <span class="string">&quot;被&quot;</span> + other.gameObject.name + <span class="string">&quot;结束相融的状态了&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="触发-相融时-自动不停调用">触发 相融时 自动不停调用</h3><p><font color="green">OnTriggerStay(Collider other)</font></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnTriggerStay</span>(<span class="params">Collider other</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    print(<span class="keyword">this</span>.name + <span class="string">&quot;和&quot;</span> + other.gameObject.name + <span class="string">&quot;正在相融&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="要明确什么时候会响应函数">要明确什么时候会响应函数</h2><ul><li><font color="red">！！！</font>碰撞和触发都是<strong>相互的</strong>，不是说只有isTrigger为True的对象才能触发，和这个触发的对象也会被触发</li><li>只要挂载的对象 能和别的物体产生碰撞或者触发 那么对应的这6个函数 就能够被响应</li><li>6个函数根据需求来进行选择书写</li><li>如果是一个异形物体，刚体在父对象上，如果你想通过子对象上挂脚本检测碰撞是不行的 必须<strong>挂载到这个刚体父对象上</strong>才行</li><li>要明确 物理碰撞和触发器响应的区别</li></ul><h2 id="6个函数都可以写成虚函数">6个函数都可以写成虚函数</h2><p>一般会把想要重写的 碰撞和触发函数 写成<strong>保护类型</strong>的 没有必要写成public 因为不会自己手动调用 都是Unity通过反射帮助我们自动调用的</p>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库系统5-数据库设计</title>
      <link href="/post/4c0f8279.html"/>
      <url>/post/4c0f8279.html</url>
      
        <content type="html"><![CDATA[<h1>1 数据库设计概论</h1><ul><li>数据库设计是指设计<strong>数据库应用程序</strong></li></ul><h1>2 数据库设计的基本步骤</h1><h2 id="2-1-需求分析">2.1 需求分析</h2><ul><li><strong>收集</strong>用户业务活动及活动数据，由系统分析人员按照分析方法加以<strong>总结提炼</strong>，<strong>描述</strong>用户使用中<strong>的业务信息</strong></li></ul><h2 id="2-2-概念结构设计">2.2 概念结构设计</h2><ul><li>将需求分析结果<strong>抽象为概念模型</strong>的过程，具体内容为<strong>建立概念模型(E-R图)</strong></li></ul><h2 id="2-3-逻辑结构设计">2.3 逻辑结构设计</h2><ul><li><strong>选择</strong>使用的数据模型类型</li><li>将E-R图<strong>转换</strong>为数据模型</li><li>对数据模型进行<strong>优化</strong></li><li>设计子模式</li></ul><h2 id="2-4-数据库物理设计">2.4 数据库物理设计</h2><ul><li><strong>确定</strong>数据库的<strong>物理结构</strong></li><li>对物理结构进行<strong>评价</strong>，评价的重点是<strong>空间和时间效率</strong></li><li>若评价结果满足设计要求则进入物理实施阶段</li><li>关系数据库物理设计的内容:<ul><li>为关系模式选择<strong>存取方法</strong>(建立存取路径)</li><li>设计<strong>关系</strong>、<strong>索引</strong>等数据库文件的<strong>物理存储结构</strong></li></ul></li></ul><h2 id="2-5-数据库实施">2.5 数据库实施</h2><ul><li>用DDL<strong>定义</strong>数据库结构</li><li><strong>组织</strong>数据入库</li><li><strong>编制与调试</strong>应用程序</li><li>数据库<strong>试运行</strong></li></ul><h2 id="2-6-数据库运行和维护">2.6 数据库运行和维护</h2><p>维护工作主要由DBA完成</p><ul><li>数据库的<strong>转储和恢复</strong></li><li>数据库的<strong>安全性、完整性控制</strong></li><li>数据库<strong>性能</strong>的<strong>监督、分析和改进</strong></li><li>数据库的<strong>重组织</strong>和<strong>重构造</strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库系统6-数据库恢复技术</title>
      <link href="/post/487a1363.html"/>
      <url>/post/487a1363.html</url>
      
        <content type="html"><![CDATA[<h1>1 事务的基本概念</h1><h2 id="1-1-事务概念">1.1 事务概念</h2><ul><li><strong>事务</strong>：是用户定义的一个数据库操作序列，这些操作要么全做，要么全不做，是一个不可分割的<strong>工作单位</strong></li><li>一个事务可以是一条SQL语句、一组SQL语句或整个程序</li><li>一个应用程序通常包含多个事务</li><li>事务是<strong>恢复和并发控制的基本单位</strong></li></ul><h2 id="1-2-如何定义事务">1.2 如何定义事务</h2><ul><li><strong>COMMIT</strong>语句表示：事务<strong>正常结束</strong>，<strong>提交事务的所有操作</strong>(读+更新)，事务中所有对数据库的更新永久生效</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BEGIN TRANSACTION</span><br><span class="line">    SQL语句1</span><br><span class="line">    SQL语句2</span><br><span class="line">    …………</span><br><span class="line">COMMIT</span><br></pre></td></tr></table></figure><ul><li><strong>ROLLBACK</strong>语句表示：事务<strong>异常终止</strong>，<strong>回滚事务的所有更新操作</strong>，使事务<strong>回滚到开始时</strong>的状态</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BEGIN TRANSACTION</span><br><span class="line">    SQL语句1</span><br><span class="line">    SQL语句2</span><br><span class="line">    …………</span><br><span class="line">ROLLBACK</span><br></pre></td></tr></table></figure><h2 id="1-3-事务的特性-ACID">1.3 事务的特性 ACID</h2><ul><li><strong>原子性</strong>(Atomicity)<ul><li>事务中包含的诸操作要么都做，要么都不做</li></ul></li><li><strong>一致性</strong>(Consistency)<ul><li>事务执行使数据库从一个一致性状态变到另一个一致性状态</li></ul></li><li><strong>隔离性</strong>(Isolation)<ul><li>一个事务的执行不能被其他事务干扰，而影响它对数据的正常使用和修改</li></ul></li><li><strong>持续性</strong>(Durability)<ul><li>一个事务一旦提交，它对数据库中数据的改变就应该是永久性的，接下来的其他操作或故障不应该对其执行结果由任何影响</li></ul></li></ul><h1>2 故障的种类</h1><h2 id="2-1-事务故障">2.1 事务故障</h2><h3 id="定义">定义</h3><ul><li>某个事务由于某种原因未运行至终止点就夭折了</li></ul><h3 id="恢复">恢复</h3><ul><li>对于<strong>可预见</strong>的错误，由<strong>事务程序来处理</strong>(如越界判断等)</li><li>对于<strong>不可预见</strong>的错误，由DBMS<strong>强行回滚</strong>该事务</li></ul><h2 id="2-2-系统故障">2.2 系统故障</h2><h3 id="定义-2">定义</h3><ul><li>整个系统的正常运行突然被破坏</li><li>所有正在运行的事务都非正常终止</li></ul><h3 id="恢复-2">恢复</h3><ul><li>清除尚未完成的事务对数据库的所有修改</li><li>将缓冲区中已完成的事务提交的结果写入数据库</li></ul><h2 id="2-3-介质故障">2.3 介质故障</h2><h3 id="定义-3">定义</h3><ul><li>存储数据库的设备(如硬盘)发生故障导致存储在其上的数据部分丢失或全部丢失</li></ul><h3 id="恢复-3">恢复</h3><ul><li>装入数据库发生介质故障前某个时刻的数据副本</li><li>重做自此时开始的所有成功事务，将这些事务已提交的结果重新记入数据库</li></ul><h1>3 恢复的实现技术</h1><h2 id="3-1-数据恢复的基本原理">3.1 数据恢复的基本原理</h2><ul><li>数据恢复的基本原理是<strong>冗余</strong>，即利用存储在系统其他地方的<strong>冗余数据</strong>来<strong>重建</strong>数据库中已被破坏或不正确的那部分数据<br>关键技术：</li></ul><ol><li>如何建立冗余数据<ul><li>数据转储(backup)</li><li>登录日志文件(logging)</li></ul></li><li>如何利用这些冗余数据实施数据库恢复</li></ol><h2 id="3-2-数据转储">3.2 数据转储</h2><h3 id="定义-4">定义</h3><ul><li>转储是指DBA将整个数据库复制到磁带或另一个磁盘上保存起来的过程</li><li>这些备用的数据文件称为后备副本或后援副本</li></ul><h3 id="分类">分类</h3><ol><li>静态转储<ul><li>转储必须等用户事务结束</li><li>新的事务必须等转储结束</li></ul></li><li>动态转储<ul><li>转储操作与用户事务并发进行</li><li>转储期间允许对数据库进行存储或修改</li></ul></li><li>海量转储<ul><li>每次转储全部数据库</li></ul></li><li>增量转储<ul><li>只转储上次转储后更新过的数据</li></ul></li></ol><h3 id="转储策略">转储策略</h3><ul><li>应定期进行海量转储</li><li>DBA应该更具使用情况确定适当的转储周期和转储方式</li></ul><h2 id="3-3-登录日志文件">3.3 登录日志文件</h2><h3 id="定义-5">定义</h3><ul><li>日志文件(log)是用来记录事务对数据库的更新操作的文件</li></ul><h3 id="格式和内容">格式和内容</h3><h4 id="以记录为单位的日志文件">以记录为单位的日志文件</h4><ul><li>格式<ul><li>各个事务开始标记 BEGIN TRANSACTION</li><li>各个事务结束标记 COMMIT 或 ROLLBACK</li></ul></li><li>内容<ul><li>各个事物的所有更新操作</li><li>各个事物的内部更新操作</li></ul></li></ul><h4 id="以数据块为单位的日志文件">以数据块为单位的日志文件</h4><ul><li>事务标识</li><li>操作类型(插入、删除或修改)</li><li>操作对象(记录ID、Block NO.)</li><li>更新前数据的旧值</li><li>更新后数据的新值</li></ul><h3 id="日志文件的用途">日志文件的用途</h3><ul><li>进行故障恢复</li></ul><h1>恢复策略</h1><h1>具有检查点的恢复技术</h1><h1>数据库镜像</h1>]]></content>
      
      
      <categories>
          
          <category> 数据库系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库系统4-关系数据库理论</title>
      <link href="/post/1203c0f8.html"/>
      <url>/post/1203c0f8.html</url>
      
        <content type="html"><![CDATA[<h1>第五章 关系数据库理论</h1><h2 id="关系模式设计引论">关系模式设计引论</h2><h2 id="函数依赖与规范化">函数依赖与规范化</h2><h2 id="数据依赖的公理系统">数据依赖的公理系统</h2><h2 id="实例分析">实例分析</h2><h1>第八章 并发控制</h1><h2 id="并发控制概述">并发控制概述</h2><h2 id="封锁">封锁</h2><h2 id="封锁协议">封锁协议</h2><h2 id="活锁和死锁">活锁和死锁</h2><h2 id="并发调度的可串行性">并发调度的可串行性</h2><h2 id="两段锁协议">两段锁协议</h2><h1>第十章 数据库完整性</h1><h2 id="完整性概述">完整性概述</h2><h2 id="完整性约束条件">完整性约束条件</h2><h2 id="触发器技术">触发器技术</h2><h2 id="实例分析-2">实例分析</h2>]]></content>
      
      
      <categories>
          
          <category> 数据库系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库系统3-SQL语言</title>
      <link href="/post/d733c799.html"/>
      <url>/post/d733c799.html</url>
      
        <content type="html"><![CDATA[<p><a url="https://www.cnblogs.com/rqy0526/p/11015943.html#:~:text=%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%E5%A4%A7%E5%85%A8%201%201.%20C%20%28Create%29%3A%E5%88%9B%E5%BB%BA%201.%20%E8%AF%AD%E6%B3%95%EF%BC%9A%20create,%E5%88%97%E5%90%8D%20%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%3B%204.%20...%204%204.%20D%20%28Delete%29%3A%E5%88%A0%E9%99%A4">数据库操作的基本语法大全</a></p><h1>1 SQL概述</h1><p>SQL(Structured Query Language):结构化查询语言，是关系数据库的标准语言</p><h2 id="1-1-SQL的特点">1.1 SQL的特点</h2><ul><li>综合统一<ul><li>集DDL、DML、DCL于一体</li></ul></li><li>高度非过程化</li><li>面向集合的操作方式</li><li>以同一种语法结构提供两种使用方式<ul><li>可交互式和嵌入式使用</li></ul></li><li>以简捷的自然语言作为操作语言</li></ul><h2 id="1-2-SQL语言所使用的动词">1.2 SQL语言所使用的动词</h2><table><thead><tr><th style="text-align:center">SQL功能</th><th style="text-align:center">动词</th></tr></thead><tbody><tr><td style="text-align:center">数据查询</td><td style="text-align:center">SELECT</td></tr><tr><td style="text-align:center">数据定义</td><td style="text-align:center">CREATE、DROP、ALTER</td></tr><tr><td style="text-align:center">数据操纵</td><td style="text-align:center">INSERT、UPDATE、DELETE</td></tr><tr><td style="text-align:center">数据控制</td><td style="text-align:center">GRANT、REVOKE</td></tr></tbody></table><h2 id="1-3-SQL支持数据库三级模式体系结构">1.3 SQL支持数据库三级模式体系结构</h2><img src="..\..\img\DB\SQL-支持数据库三级模式体系结构.png" width="70%" height="70%" align="middle"><h1>2 数据定义</h1><ul><li>SQL提供了专门的语言用来定义数据库、表、索引等数据库对象，这些语言被称作<strong>数据库定义语言DDL</strong></li><li>SQL的数据库定义语句<br><img src="..\..\img\DB\SQL-数据库定义语句.png" width="70%" height="70%" align="middle"></li></ul><h2 id="2-1-创建基本表">2.1 创建基本表</h2><img src="..\..\img\DB\SQL-创建基本表.png" width="70%" height="70%" align="middle"><h3 id="2-1-1-常用完整性约束">2.1.1 常用完整性约束</h3><ul><li>主码约束：<strong>PRIMARY KEY</strong></li><li>唯一性约束：<strong>UNIQUE</strong></li><li>非空值约束：<strong>NOT NULL</strong></li><li>参照完整性约束：<ul><li><strong>FOREIGN KEY&lt;列名&gt;REFERENCES&lt;表名&gt;(&lt;列名&gt;)</strong></li></ul></li><li>用户定义完整性约束：<ul><li><strong>Check(&lt;约束条件表达式&gt;)</strong></li></ul></li><li>缺省值约束：Default<ul><li><strong>Default&lt;缺省值&gt;</strong></li></ul></li></ul><h3 id="2-1-2-SQL中数据类型">2.1.2 SQL中数据类型</h3><img src="..\..\img\DB\SQL-数据类型.png" width="70%" height="70%" align="middle"><h2 id="2-2-索引">2.2 索引</h2><h1>查询</h1><h1>实例分析</h1><h1>数据更新</h1><h1>视图</h1><h1>嵌入式SQL</h1>]]></content>
      
      
      <categories>
          
          <category> 数据库系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库系统2-关系数据库</title>
      <link href="/post/63fbbbb3.html"/>
      <url>/post/63fbbbb3.html</url>
      
        <content type="html"><![CDATA[<h1>1 关系模式概述</h1><ul><li>关系数据库系统 是 <strong>支持关系模型的DBS</strong></li><li>关系模型的组成<ul><li>关系数据结构</li><li>关系操作集合</li><li>关系完整性约束</li></ul></li></ul><h2 id="1-1-关系数据结构-–-关系-二维表">1.1 关系数据结构 – 关系(二维表)</h2><ul><li>关系数据结构的特点：实体和联系都用关系这种单一的数据结构来实现</li></ul><h2 id="1-2-关系操作">1.2 关系操作</h2><ul><li>并、交、差、广义笛卡尔积、选择、投影、连接、除</li><li>插入、删除、修改</li><li>关系操作的特点<ul><li>操作对象和操作结果都是集合</li></ul></li></ul><h2 id="1-3-关系完整性约束">1.3 关系完整性约束</h2><ul><li>实体完整性、参照完整性、用户定义完整性</li></ul><h1>2 关系的形式化定义</h1><h2 id="2-1-关系的定义">2.1 关系的定义</h2><h3 id="2-1-1-定义">2.1.1 定义</h3><ul><li><strong>域</strong>：一组具有相同数据类型的值的集合，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>D</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">D_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>表示一个域</li><li><strong>关系</strong>：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>D</mi><mn>1</mn></msub><mi>X</mi><msub><mi>D</mi><mn>2</mn></msub><mi>X</mi><mo>…</mo><mi>X</mi><msub><mi>D</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">D_1 X D_2 X \dots X D_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 的一个子集叫做域<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>D</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">D_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>上的关系，表示为：<ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mo stretchy="false">(</mo><msub><mi>D</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>D</mi><mn>2</mn></msub><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><msub><mi>D</mi><mi>n</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">R(D_1, D_2, \dots, D_n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span>为关系名，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span>为关系的目或度</li></ul></li><li><strong>基数</strong>：一个域<strong>允许的不同取值</strong>个数称为这个域的基数<ul><li>关系中基数是指 <strong>行数</strong></li></ul></li></ul><h3 id="2-1-2-几个概念">2.1.2 几个概念</h3><img src="..\..\img\DB\候选码和主码.png" width="70%" height="70%" align="middle"><ul><li><strong>候选码</strong>：能唯一标识元组的属性(组)</li><li><strong>主码</strong>：多个候选码中选的一个作为主码</li><li><strong>主属性</strong>：候选码中的诸属性</li><li><strong>非主属性</strong>：不出现在任何候选码中的属性</li></ul><h2 id="2-2-关系的六条性质">2.2 关系的六条性质</h2><ul><li><strong>列是同质的</strong>：每一列中的风量来自同一域，数据类型相同</li><li><strong>不同列可以出自同一个域</strong></li><li><strong>列序无关性</strong></li><li><strong>任意两个元组不能完全相同</strong></li><li><strong>行许无关系</strong></li><li><strong>分量不可再分</strong></li></ul><h1>3 关系的完整性约束</h1><h2 id="3-1-实体完整性">3.1 实体完整性</h2><ul><li>若属性A是基本关系R的<strong>主属性</strong>，则A不能取空值</li></ul><h2 id="3-2-参照完整性">3.2 参照完整性</h2><h3 id="3-2-1-参照关系与外码">3.2.1 参照关系与外码</h3><ul><li><p>设F是关系R的一个或一组属性<strong>但不是R的码</strong>。如果F与关系S的<strong>主码<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>K</mi><mi>S</mi></msub></mrow><annotation encoding="application/x-tex">K_S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05764em;">S</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><strong>相对应，则称</strong>F是R的外码</strong>，<strong>R称为参照关系</strong>，<strong>S称为被参照关系(目标关系)</strong></p></li><li><p>例子：<br><img src="..\..\img\DB\参照关系与外码.png" width="70%" height="70%" align="middle"></p></li><li><p>说明</p><ul><li>关系R和S<strong>不一定是不同的关系</strong></li><li>目标关系S的主码<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>K</mi><mi>S</mi></msub></mrow><annotation encoding="application/x-tex">K_S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05764em;">S</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>和参照关系的外码F必须在<strong>同一个(一组)域</strong>上</li><li>外码<strong>并不一定要与对应的主码同名</strong>，当位于不同关系时往往同名，以便识别</li></ul></li></ul><h3 id="3-2-2-参照完整性规则">3.2.2 参照完整性规则</h3><ul><li><p>若属性(组)F是关系R的<strong>外码</strong>，它与关系S的**主码<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>K</mi><mi>S</mi></msub></mrow><annotation encoding="application/x-tex">K_S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05764em;">S</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>**相对应，则对于R中的每个元组在F上的值必须为：</p><ul><li>或者取<strong>空值</strong></li><li>或者等于<strong>S中某个元组的主码值</strong><br><img src="..\..\img\DB\参照完整性例子.png" width="70%" height="70%" align="middle"></li></ul></li><li><p>思考题：</p><ul><li>某关系R的外码是指<strong>其他关系的候选码</strong>，同时作为<strong>R的非主属性</strong></li><li>外码和被参照的主码可以不同名，但必须取自同一值域</li></ul></li></ul><h2 id="3-3-用户定义完整性">3.3 用户定义完整性</h2><ul><li>用户定义的完整性是针对某一具体关系数据库的约束条件，<strong>反映某一具体应用所涉及的数据</strong>必须满足的语义要求，如性别只能取&quot;男&quot;、&quot;女&quot;值。</li><li>通常由RDBMS的Check约束提供这类检查</li></ul><h1>4 关系代数</h1><h2 id="4-1-表示记号">4.1 表示记号</h2><img src="..\..\img\DB\关系代数表示记号1.png" width="70%" height="70%" align="middle"><img src="..\..\img\DB\关系代数表示记号2.png" width="70%" height="70%" align="middle"><img src="..\..\img\DB\关系代数表示记号3.png" width="70%" height="70%" align="middle"><h2 id="4-2-关系代数">4.2 关系代数</h2><h3 id="4-2-1-并、交、差">4.2.1 并、交、差</h3><ul><li>并、交、差 运算都是<strong>针对行的</strong></li></ul><h3 id="4-2-2-广义笛卡尔积">4.2.2 广义笛卡尔积</h3><ul><li>n + m 列</li><li>k1 * K2 行<br><img src="..\..\img\DB\关系代数-广义笛卡尔积.png" width="70%" height="70%" align="middle"></li></ul><h3 id="4-2-3-选择、投影、连接、除">4.2.3 选择、投影、连接、除</h3><h4 id="选择-取行">选择 -&gt; 取行</h4><ul><li>符号：<strong><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>σ</mi></mrow><annotation encoding="application/x-tex">\sigma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span></span></span></span></strong></li><li>含义：在关系R中选择满足给定条件的诸元组</li></ul><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>σ</mi><mi>F</mi></msub><mo stretchy="false">(</mo><mi>R</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">{</mo><mi>t</mi><mi mathvariant="normal">∣</mi><mi>t</mi><mo>∈</mo><mi>R</mi><mo>∧</mo><mi>F</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><msup><mo>=</mo><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><msup><mtext>真</mtext><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\sigma_F(R)=\{t|t\in R \land F(t)=&#x27;真&#x27;\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">F</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord mathnormal">t</span><span class="mord">∣</span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∧</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.0519em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel"><span class="mrel">=</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8019em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0519em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord cjk_fallback">真</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8019em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mclose">}</span></span></span></span></span></p><ul><li>F：选择条件<br><img src="..\..\img\DB\关系代数-选择.png" width="70%" height="70%" align="middle"></li></ul><h4 id="投影-取列">投影 -&gt; 取列</h4><ul><li><p>相关符号<br><img src="..\..\img\DB\关系代数-属性列.png" width="70%" height="70%" align="middle"></p></li><li><p>符号：<strong><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>π</mi></mrow><annotation encoding="application/x-tex">\pi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">π</span></span></span></span></strong></p></li><li><p>含义：在R中选择出若干属性列组成新的关系</p></li></ul><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>π</mi><mi>A</mi></msub><mo stretchy="false">(</mo><mi>R</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">{</mo><mi>t</mi><mo stretchy="false">[</mo><mi>A</mi><mo stretchy="false">]</mo><mi mathvariant="normal">∣</mi><mi>t</mi><mo>∈</mo><mi>R</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\pi_A(R)=\{t[A]|t\in R\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">A</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord mathnormal">t</span><span class="mopen">[</span><span class="mord mathnormal">A</span><span class="mclose">]</span><span class="mord">∣</span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mclose">}</span></span></span></span></span></p><ul><li>A：R中的属性列的集合<br><img src="..\..\img\DB\关系代数-投影.png" width="70%" height="70%" align="middle"></li></ul><p><strong>注：投影后不仅取消了原关系中的某些行，而且还可能取消某些元组(避免重复行)</strong></p><h4 id="连接-混合">连接 -&gt; 混合</h4><ul><li>符号：<strong><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⋈</mo></mrow><annotation encoding="application/x-tex">\bowtie</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.51em;vertical-align:-0.005em;"></span><span class="mrel">⋈</span></span></span></span></strong></li><li>含义：从两个关系的广义笛卡尔积中选取属性间满足一定条件的元组</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>σ</mi></mrow><annotation encoding="application/x-tex">\sigma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span></span></span></span> 连接<br><img src="..\..\img\DB\关系代数-sigma连接.png" width="70%" height="70%" align="middle"></li></ul><h5 id="常用两种连接运算">常用两种连接运算</h5><ul><li><p><strong>等值运算</strong></p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>σ</mi></mrow><annotation encoding="application/x-tex">\sigma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span></span></span></span> 为’='的连接运算<br><img src="..\..\img\DB\关系代数-等值连接.png" width="70%" height="70%" align="middle"></li></ul></li><li><p><strong>自然连接</strong></p><ul><li>一种特殊的等值连接</li><li>关系中比较的两个分量必须是<strong>同名的属性(组)</strong></li><li>在结果中把重复的属性列去掉</li><li><strong>意义：将两个有关联的表合成一张有意义的表</strong><br><img src="..\..\img\DB\关系代数-自然连接.png" width="70%" height="70%" align="middle"></li></ul></li></ul><h5 id="外连接">外连接</h5><img src="..\..\img\DB\关系代数-外连接.png" width="70%" height="70%" align="middle"><h4 id="除-混合">除 -&gt; 混合</h4><ul><li><p>相关符号<br><img src="..\..\img\DB\关系代数-象集.png" width="70%" height="70%" align="middle"><br><img src="..\..\img\DB\关系代数-象集例子.png" width="70%" height="70%" align="middle"></p></li><li><p>符号：<strong><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>÷</mo></mrow><annotation encoding="application/x-tex">\div</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord">÷</span></span></span></span></strong><br><img src="..\..\img\DB\关系代数-除.png" width="70%" height="70%" align="middle"></p></li></ul><img src="..\..\img\DB\关系代数-除例子.png" width="70%" height="70%" align="middle"><ul><li>例子：查询选修了全部课程的学号和姓名</li></ul><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>π</mi><mrow><mi>s</mi><mi>n</mi><mi>o</mi><mo separator="true">,</mo><mi>s</mi><mi>n</mi><mi>a</mi><mi>m</mi><mi>e</mi></mrow></msub><mo stretchy="false">(</mo><mi>S</mi><mo stretchy="false">)</mo><mo>⋈</mo><mo stretchy="false">(</mo><msub><mi>π</mi><mrow><mi>s</mi><mi>n</mi><mi>o</mi><mo separator="true">,</mo><mi>c</mi><mi>n</mi><mi>o</mi></mrow></msub><mo stretchy="false">(</mo><mi>S</mi><mi>C</mi><mo stretchy="false">)</mo><mo>÷</mo><msub><mi>π</mi><mrow><mi>c</mi><mi>n</mi><mi>o</mi></mrow></msub><mo stretchy="false">(</mo><mi>C</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\pi_{sno,sname}(S)\bowtie(\pi_{sno,cno}(SC)\div\pi_{cno}(C))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span><span class="mord mathnormal mtight">n</span><span class="mord mathnormal mtight">o</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight">s</span><span class="mord mathnormal mtight">nam</span><span class="mord mathnormal mtight">e</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⋈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span><span class="mord mathnormal mtight">n</span><span class="mord mathnormal mtight">o</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight">c</span><span class="mord mathnormal mtight">n</span><span class="mord mathnormal mtight">o</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07153em;">SC</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">÷</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">c</span><span class="mord mathnormal mtight">n</span><span class="mord mathnormal mtight">o</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mclose">))</span></span></span></span></span></p><h1>5 关系代数实用案例</h1><ul><li><p><strong>详情见ppt第181页</strong></p></li><li><p>易错题1</p><ul><li>应该用除法<br><img src="..\..\img\DB\关系代数-易错题1.png" width="70%" height="70%" align="middle"></li></ul></li><li><p>易错题2<br><img src="..\..\img\DB\关系代数-易错题2.png" width="70%" height="70%" align="middle"></p></li><li><p>易错题3<br><img src="..\..\img\DB\关系代数-易错题3.png" width="70%" height="70%" align="middle"></p></li></ul><h1>6 关系演算</h1><ul><li>可分为<strong>元组演算</strong>和<strong>域演算(不讲)</strong></li></ul><h2 id="6-1-元组演算">6.1 元组演算</h2><ul><li>元组演算表达式：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">{</mo><mi>t</mi><mi mathvariant="normal">∣</mi><mi mathvariant="normal">Φ</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\{t|\Phi(t)\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord mathnormal">t</span><span class="mord">∣Φ</span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mclose">)}</span></span></span></span><ul><li>t称为元组变量</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Φ</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Phi(t)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Φ</span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mclose">)</span></span></span></span>称为元组演算公式</li></ul></li><li>原子公式：<br><img src="..\..\img\DB\元组演算-原子公式.png" width="70%" height="70%" align="middle"></li></ul><h2 id="6-2-关系代数表达式与元组演算表达式的等价转换">6.2 关系代数表达式与元组演算表达式的等价转换</h2><img src="..\..\img\DB\元组演算-等价转换.png" width="70%" height="70%" align="middle"><h2 id="6-3-例子">6.3 例子</h2><p><a url="https://www.cnblogs.com/SimbaWang/p/13252557.html">蕴含式(包含EXISTS的运用与分析) </a></p><img src="..\..\img\DB\元组演算-例子.png" width="70%" height="70%" align="middle"><h1>7 关系演算实用案例 - <font color=red>难点</font></h1><ul><li><strong>详情见ppt第206页</strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库系统1-概述</title>
      <link href="/post/8bcdf547.html"/>
      <url>/post/8bcdf547.html</url>
      
        <content type="html"><![CDATA[<h1>1 数据库系统概述</h1><h2 id="1-1-数据库管理系统DBMS">1.1 数据库管理系统DBMS</h2><ul><li>DBMS是位于用户与操作系统之间的一层数据管理软件。</li><li>功能：<ul><li>数据定义功能 – 数据定义语言<strong>DDL</strong></li><li>数据组织、存储和管理功能</li><li>数据库操纵功能 – 数据库操纵语言<strong>DML</strong></li><li>数据控制功能<ul><li>数据的安全性保护</li><li>数据的完整性检查</li><li>并发控制</li><li>数据库恢复</li></ul></li></ul></li></ul><h2 id="1-2-数据库系统DBS">1.2 数据库系统DBS</h2><ul><li>特点：<ul><li>数据结构化</li><li>数据的共享性高、冗余度低且易扩充</li><li>数据独立性高</li><li>数据由DBMS统一管理和控制</li></ul></li></ul><h1>2 概念模型与数据模型</h1><img src="..\..\img\DB\模型抽象.png" width="70%" height="70%" align="middle"><h2 id="2-1-概念模型">2.1 概念模型</h2><ul><li>概念模型也称信息模型，是对现实世界的事物符号化的描述</li><li><strong>现实世界</strong>到<strong>信息世界</strong>是<strong>第一级抽象</strong></li><li>信息世界的主要概念<ul><li><strong>实体</strong>：客观存在的各类事物 如：学生</li><li><strong>属性</strong>：实体所具有的特性 如：学号</li><li><strong>实体型</strong>：用实体名及属性名集抽象实体 如：学生(学号，姓名，性别)</li><li><strong>实体集</strong>：同型实体的集合</li><li><strong>码</strong>：能<strong>唯一标识</strong>实体的属性集</li><li><strong>域</strong>：属性的取值范围</li><li><strong>联系</strong>：不同实体集中实体之间的联系<ul><li>一对一联系</li><li>一对多联系</li><li>多对多联系</li></ul></li></ul></li><li>E-R图建立概念模型<br><img src="..\..\img\DB\E-R图.png" width="70%" height="70%" align="middle"></li></ul><h2 id="2-2-数据模型">2.2 数据模型</h2><ul><li><strong>信息世界</strong>到<strong>机器世界</strong>是<strong>第二级抽象</strong></li><li>数据模型是概念模型的数据化，从计算机角度出发，提供表示和组织数据的方法，对应机器世界</li><li>数据模型三要素：<ul><li>数据结构：记录间的组织形式</li><li>数据操纵：建立在特定结构下的操纵实现</li><li>数据完整性约束：记录内部及记录间的限定</li></ul></li><li>数据模型的分类<ul><li>层次模型：树形结构</li><li>网状模型：图型结构</li><li>关系模型：表型结构</li><li>面向对象模型：对象结构</li></ul></li></ul><h3 id="2-2-1-关系模型">2.2.1 关系模型</h3><img src="..\..\img\DB\关系模型的数据结构.png" width="70%" height="70%" align="middle"><ul><li>关系模式：对关系数据结构的描述，即<ul><li>关系名(属性1，属性2，···,属性n)</li><li>例：学生(学号，姓名，年龄，性别)</li></ul></li></ul><h3 id="2-2-2-E-R图向关系模型的转换">2.2.2 E-R图向关系模型的转换</h3><ul><li>实体型 -&gt; 关系模式<ul><li>实体型的属性 -&gt; 关系的属性</li><li>实体码 -&gt; 关系的码</li></ul></li><li>联系的转换<ul><li>1:1联系：将<strong>其中一端</strong>的码连同联系的属性放入<strong>另一端</strong></li><li>1:n联系：将<strong>1端</strong>的码连同联系的属性放入<strong>n端</strong></li><li>m:n联系：将<strong>1端</strong>的码、<strong>n端</strong>的码连同联系的属性组成一个新的关系模式</li></ul></li></ul><h3 id="2-2-3-数据操纵与完整性约束">2.2.3 数据操纵与完整性约束</h3><ul><li>数据操纵<ul><li>数据操作是集合操作，操作对象和操作结果都是关系</li><li>查询、插入、删除、修改</li></ul></li><li>完整性约束<ul><li>实体完整性</li><li>参照完整性</li><li>用户定义完整性</li></ul></li></ul><h1>3 数据库系统结构</h1><p>两种划分</p><ul><li>从DBMS角度看：三级模式结构</li><li>从数据库最终用户角度看<ul><li>集中式结构</li><li>分布式结构</li><li>C/S结构</li><li>并行结构</li></ul></li></ul><h2 id="3-1-三级模式结构">3.1 三级模式结构</h2><img src="..\..\img\DB\三级模式映像.png" width="70%" height="70%" align="middle"><img src="..\..\img\DB\三级模式映像实例.png" width="70%" height="70%" align="middle"><h3 id="3-1-1-模式-逻辑模式">3.1.1 模式(逻辑模式)</h3><ul><li>数据库中全体数据的逻辑结构和特征的描述，是<strong>所有用户的公共数据视图</strong></li><li>模式的地位：<ul><li>是DBS模式结构的中间层</li><li>与数据的物理存储细节和硬件无关</li><li>与具体应用程序等无关</li></ul></li><li>一个数据库只能有1个模式</li></ul><h3 id="3-1-2-外模式-用户模式">3.1.2 外模式(用户模式)</h3><ul><li>数据库用户(程序员和最终用户)使用的<strong>局部数据描述</strong>，是数据库用户的数据视图，<strong>与具体某一用户有关</strong></li><li>外模式的地位：<ul><li>介于模式与应用之间</li></ul></li><li>模式与外模式的关系：<strong>一对多</strong><ul><li>外模式通常是模式的子集</li><li>一个数据库可以有多个外模式</li></ul></li><li>外模式与应用的关系：<strong>一对多</strong><ul><li>同一个外模式可以为某一用户的多个应用系统所使用</li><li>一个应用程序只能使用一个外模式</li></ul></li></ul><h3 id="3-1-3-内模式-存储模式">3.1.3 内模式(存储模式)</h3><ul><li>是数据物理结构和存储方式的描述</li><li>是数据在数据库内部的表示方式<ul><li>记录的存储方式</li><li>索引的组织方式</li><li>数据是否压缩存储</li><li>数据是否加密</li></ul></li><li>一个数据库只有一个内模式</li></ul><h3 id="3-1-4-外模式-模式映像">3.1.4 外模式/模式映像</h3><ul><li>定义外模式与模式之间的对应关系</li><li>每一个外模式都包含一个外模式/模式映像</li><li>映像定义通常包含在各自外模式的描述中</li><li>用途 – <strong>保证数据的逻辑独立性</strong><ul><li>当模式改变时，DBA修改有关外模式/模式映像，使外模式保持不变</li><li>因而应用程序不必修改，保证了数据和程序的逻辑独立性</li></ul></li></ul><h3 id="3-1-5-模式-内模式映像">3.1.5 模式/内模式映像</h3><ul><li>定义了数据全局逻辑结构与存储结构之间的对应关系</li><li>用途 – <strong>保证数据的物理独立性</strong><ul><li>当数据的存储结构改变了，DBA修改模式/内模式映像，使模式保持不变</li><li>因而应用程序不必修改，保证了数据和程序的物理独立性</li></ul></li></ul><h1>4 数据库系统的组成</h1><img src="..\..\img\DB\数据库系统的组成.png" width="70%" height="70%" align="middle"><ul><li><strong>数据库管理员 DBA</strong><ul><li>决定数据库中的信息内容和结构</li><li>决定数据库的存储结构和存取策略</li><li>定义数据的安全性要求和完整性约束条件</li><li>监控数据库的使用和运行</li><li>数据库的改进和重组</li></ul></li></ul><h1>5 总结</h1><ul><li>关键词<br>DBMS、DBS、主码、关系、关系模式、模式、外模式、内模式、模式映射、E-R图转关系模型</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>收藏夹-计算机</title>
      <link href="/post/7df71ba4.html"/>
      <url>/post/7df71ba4.html</url>
      
        <content type="html"><![CDATA[<h2 id="操作系统">操作系统</h2><h3 id="银行家算法"><a href="https://www.cnblogs.com/wkfvawl/p/11929508.html">银行家算法</a></h3>]]></content>
      
      
      <categories>
          
          <category> 收藏夹 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 收藏夹 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity-Resources资源动态加载</title>
      <link href="/post/d86321cd.html"/>
      <url>/post/d86321cd.html</url>
      
        <content type="html"><![CDATA[<h2 id="特殊文件夹">特殊文件夹</h2><h3 id="工程路径获取">工程路径获取</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(Application.dataPath);</span><br></pre></td></tr></table></figure><ul><li>注意 该方式 获取到的路径 一般情况下 只在 编辑模式下使用</li><li>我们不会在实际发布游戏后 还使用该路径</li><li>游戏发布过后 该路径就不存在了</li></ul><h3 id="Resources-资源文件夹">Resources 资源文件夹</h3><ul><li>路径获取：<ul><li>一般不获取<br>只能使用Resources相关API进行加载</li><li>如果硬要获取 可以用工程路径拼接</li></ul>  <figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(Application.dataPath + <span class="string">&quot;/Resources&quot;</span>);</span><br></pre></td></tr></table></figure></li><li>注意：<br>该文件夹需要我们自己创建</li><li>作用：资源文件夹<ul><li>需要通过Resources相关API动态加载的资源需要放在其中</li><li>该文件夹下所有文件都会被打包出去</li><li>打包时Unity会对其压缩加密</li><li>该文件夹打包后<font color=red>只读</font> 只能通过Resources相关API加载</li></ul></li></ul><h3 id="StreamingAssets-流动资源文件夹">StreamingAssets 流动资源文件夹</h3><ul><li>路径获取：</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(Application.streamingAssetsPath);</span><br></pre></td></tr></table></figure><ul><li>注意：<br>需要我们自己将创建</li><li>作用：流文件夹<ul><li>打包出去不会被压缩加密，可以任由我们摆布</li><li>移动平台<font color=red>只读</font>，PC平台<font color=red>可读可写</font></li><li>可以放入一些需要自定义动态加载的初始资源</li></ul></li></ul><h3 id="persistentDataPath-持久数据文件夹">persistentDataPath 持久数据文件夹</h3><ul><li>路径获取：</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(Application.persistentDataPath);</span><br></pre></td></tr></table></figure><ul><li>注意：<br>不需要我们自己将创建</li><li>作用：固定数据文件夹<ul><li>所有平台都<font color=red>可读可写</font></li><li>一般用于放置动态下载或者动态创建的文件，游戏中创建或者获取的文件都放在其中</li></ul></li></ul><h3 id="Plugins-插件文件夹">Plugins 插件文件夹</h3><ul><li>路径获取：一般不获取</li><li>注意：<br>需要我们自己将创建</li><li>作用：插件文件夹<ul><li>不同平台的插件相关文件放在其中比如IOS和Android平台</li></ul></li></ul><h3 id="Editor-编辑器文件夹">Editor 编辑器文件夹</h3><ul><li>路径获取：<ul><li>一般不获取</li><li>如果硬要获取 可以用工程路径拼接</li></ul>  <figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(Application.dataPath + <span class="string">&quot;/Editor&quot;</span>);</span><br></pre></td></tr></table></figure></li><li>注意：需要我们自己将创建</li><li>作用：编辑器文件夹<ul><li>开发Unity编辑器时，编辑器相关脚本放在该文件夹中</li><li>该文件夹中内容不会被打包出去</li></ul></li></ul><h3 id="默认资源文件夹-Standard-Assets">默认资源文件夹 Standard Assets</h3><ul><li>路劲过去：一般不获取</li><li>注意：需要我们自己将创建</li><li>作用：默认资源文件夹<ul><li>一般Unity自带资源都放在这个文件夹下</li><li>代码和资源优先被编译</li></ul></li></ul><h2 id="Resources资源动态加载">Resources资源动态加载</h2><h3 id="作用">作用</h3><ul><li>通过代码动态加载<strong>Resources</strong>文件夹下指定路径资源</li><li>避免繁琐的拖曳操作</li></ul><h3 id="常用资源类型">常用资源类型</h3><ul><li>预设体对象——<code>GameObject</code></li><li>音效文件——<code>AudioClip</code></li><li>文本文件——<code>TextAsset</code></li><li>图片文件——<code>Texture</code></li><li>其它类型——需要什么用什么类型</li><li>注意：<br>预设体对象加载需要实例化<br>其它资源加载一般直接用</li></ul><h2 id="Resources资源同步加载">Resources资源同步加载</h2><h3 id="同步加载-普通方法">同步加载(普通方法)</h3><p>使用<code>Resources.Load()</code>方法加载预设体的资源文件<font color="red">(本质上 是加载 配置数据 到内存中)</font></p><h4 id="预设体对象">预设体对象</h4><ul><li><font color="red">需要实例化</font></li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object obj = Resources.Load(<span class="string">&quot;Cube&quot;</span>);</span><br><span class="line">Instantiate(obj);</span><br></pre></td></tr></table></figure><h4 id="音效资源">音效资源</h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">AudioSource audioS;</span><br><span class="line">audioS.clip = Resource.Load(<span class="string">&quot;Music/BKMusic&quot;</span>) <span class="keyword">as</span> AudioClip;</span><br><span class="line">audioS.Play();</span><br></pre></td></tr></table></figure><h4 id="文本资源">文本资源</h4><p>支持的格式<font color='blue'>.txt, .xml, .bytes, .json, .html, .csv, …</font></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">TextAsset ta = Resouces.Load(<span class="string">&quot;Txt/Test&quot;</span>) <span class="keyword">as</span> TextAsset;</span><br><span class="line"><span class="comment">//文本内容</span></span><br><span class="line">print(ta.text);</span><br><span class="line"><span class="comment">//字节数据组</span></span><br><span class="line">print(ta.bytes);</span><br></pre></td></tr></table></figure><h4 id="图片">图片</h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Texture tex;</span><br><span class="line">tex = Resources.Load(<span class="string">&quot;Tex/TestJPG&quot;</span>) <span class="keyword">as</span> Texture;</span><br></pre></td></tr></table></figure><h4 id="问题">问题</h4><p>若资源同名时怎么办，因为同一个文件夹中不同格式的文件可以同名</p><ul><li>方法一：加载指定类型的资源</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tex = Resources.Load(<span class="string">&quot;Tex/TestJPG&quot;</span>, <span class="keyword">typeof</span>(TextAsset)) <span class="keyword">as</span> TextAsset;</span><br></pre></td></tr></table></figure><ul><li>方法二：加载指定名字的所有资源</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Object[] objs = Resources.LoadAll(<span class="string">&quot;Tex/TestJPG&quot;</span>);</span><br><span class="line"><span class="keyword">foreach</span> (Object item <span class="keyword">in</span> objs)&#123;</span><br><span class="line">    <span class="keyword">if</span> (item <span class="keyword">is</span> Texture)&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(item <span class="keyword">is</span> TextAsset)&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="同步加载-泛型方法">同步加载(泛型方法)</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TextAsset ta = Resources.Load&lt;TextAsset&gt;(<span class="string">&quot;Test&quot;</span>);</span><br><span class="line">Texture tex = Resouces.Load&lt;Texture&gt;(<span class="string">&quot;Test&quot;</span>);</span><br></pre></td></tr></table></figure><h2 id="Resources资源异步加载">Resources资源异步加载</h2><h3 id="什么是Resources异步加载">什么是Resources异步加载</h3><p>同步加载过大的资源可能会造成程序卡顿//<br>异步加载是内部新开一个线程进行资源加载 不会造成主线程卡顿</p><h3 id="Resources异步加载方法">Resources异步加载方法</h3><p><strong>使用<code>Resources.LoadAsync()</code>方法</strong><br>异步加载 不能马上得到加载的资源 <strong>至少要<font color='red'>等一帧</font></strong></p><h4 id="完成事件监听异步加载">完成事件监听异步加载</h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ResourceRequest rq = Resources.LoadAsync&lt;Texture&gt;(<span class="string">&quot;Tex/TestJPG&quot;</span>);</span><br><span class="line"><span class="comment">//进行一个 资源下载结束 的一个事件函数监听(当资源加载结束后自动调用事件)</span></span><br><span class="line">rq.completed += LoadOver;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">LoadOver</span>(<span class="params">AsyncOperation rq</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    print(<span class="string">&quot;加载结束&quot;</span>);</span><br><span class="line">    <span class="comment">//asset 是资源对象 加载完毕过后 就能够得到它</span></span><br><span class="line">    tex = (rq <span class="keyword">as</span> ResourceRequest).asset <span class="keyword">as</span> Texture;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="..\img\Unity\AsyncOperation类.png" width="50%" height="50%"><img src="..\img\Unity\ResourceRequest类.png" width="50%" height="50%"><h4 id="协程异步加载">协程异步加载</h4><h5 id="协程回顾">协程回顾</h5><ul><li>两大关键<ul><li>迭代器函数 (自己写)</li><li>协程协调器 (Unity自带)</li></ul></li><li><strong>迭代器函数</strong>当遇到<code>yield return</code>时就会停止执行之后的代码;<br>然后<strong>协程协调器</strong>通过得到<strong>返回的值</strong>去判断下一次执行后面的步骤<strong>将会是何时</strong></li></ul><h5 id="协程异步加载-2">协程异步加载</h5><ol><li>使用<code>yield return rq;</code>时Unity 会自己判断 该资源是否加载完毕了; 加载完毕过后 才会继续执行后面的代码.</li></ol><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">StartCoroutine(Load1());</span><br><span class="line"></span><br><span class="line"><span class="function">IEnumerator <span class="title">Load1</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    ResourceRequest rq = Resources.LoadAsync(<span class="string">&quot;Tex/TestJPG&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">return</span> rq;</span><br><span class="line">    tex = rq.asset <span class="keyword">as</span> Texture;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>使用<code>rq.isDone</code>判断是否加载结束</li></ol><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">StartCoroutine(Load2());</span><br><span class="line"></span><br><span class="line"><span class="function">IEnumerator <span class="title">Load2</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//加载两个资源</span></span><br><span class="line">    ResourceRequest rq1 = Resources.LoadAsync(<span class="string">&quot;Tex/TestJPG1&quot;</span>);</span><br><span class="line">    ResourceRequest rq2 = Resources.LoadAsync(<span class="string">&quot;Tex/TestJPG2&quot;</span>);</span><br><span class="line">    <span class="comment">//判断资源是否加载结束</span></span><br><span class="line">    <span class="keyword">while</span>(!rq1.isDone || !rq2.isDone)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//打印当前的 加载进度 </span></span><br><span class="line">        <span class="comment">//该进度 不会特别准确 过渡也不是特别明显</span></span><br><span class="line">        print(rq1.progress);</span><br><span class="line">        print(rq2.progress);</span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    tex1 = rq1.asset <span class="keyword">as</span> Texture;</span><br><span class="line">    tex2 = rq2.asset <span class="keyword">as</span> Texture;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结">总结</h3><h4 id="完成事件监听异步加载-2">完成事件监听异步加载</h4><ul><li><font color='red'>我们在只加载一个资源时使用</font></li><li>好处：写法简单</li><li>坏处：只能在资源加载结束后 进行处理</li><li>“线性加载”</li></ul><h4 id="协程异步加载-3">协程异步加载</h4><ul><li><font color='red'>我们在加载多个资源时使用</font></li><li>好处：可以在协程中处理复杂逻辑，比如<strong>同时加载多个资源</strong>，比如进度条更新</li><li>坏处：写法稍麻烦</li><li>“并行加载”</li></ul><h4 id="注意：">注意：</h4><ul><li>理解为什么异步加载不能马上加载结束，为什么至少要等1帧</li><li>理解协程异步加载的原理</li></ul><h2 id="Resources资源卸载">Resources资源卸载</h2><h3 id="Resources重复加载资源会浪费内存吗？">Resources重复加载资源会浪费内存吗？</h3><ul><li>在Resources加载一次资源过后该资源就一直存放在内存中作为缓存，第二次加载时发现缓存中存在该资源，会直接取出来进行使用，所以<strong>多次重复加载不会浪费内存</strong></li><li>但是 <strong>会浪费性能</strong>(每次加载都会去查找取出，始终伴随一些性能消耗)</li></ul><h3 id="手动释放掉缓存中的资源">手动释放掉缓存中的资源</h3><h4 id="卸载指定资源">卸载指定资源</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">注意：</span><br><span class="line">- 该方法 不能释放 ```GameObject```对象 因为它会用于实例化对象</span><br><span class="line">- 它只能用于一些 **不需要实例化的内容** 比如 图片 和 音效 文本等等</span><br><span class="line">- **一般情况下 我们很少单独使用它**</span><br><span class="line">``` C# </span><br><span class="line">Resources.UnloadAsset(tex);</span><br></pre></td></tr></table></figure><h4 id="卸载未使用的资源">卸载未使用的资源</h4><ul><li>注意：<strong>一般在过场景时和GC一起使用</strong></li></ul><pre><code class="language-C#">Resources.UnloadUnusedAssets();GC.Collect();</code></pre>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity-协同程序</title>
      <link href="/post/2befdcf2.html"/>
      <url>/post/2befdcf2.html</url>
      
        <content type="html"><![CDATA[<h2 id="Unity是否支持多线程？">Unity是否支持多线程？</h2><ul><li>Unity是支持多线程的, 只是新开线程<font color="red">无法访问Unity相关对象的内容</font></li><li>注意：Unity中的多线程要记住关闭，否则即使停止运行主线程新开线程也会继续运行</li></ul><h2 id="协同程序是什么？">协同程序是什么？</h2><ul><li>协同程序简称协程，它是“假”的多线程，它不是多线它的主要作用</li><li>将代码分时执行，不卡主线程<ul><li>简单理解，是把可能会让主线程卡顿的耗时的分步执</li></ul></li><li>主要使用场景<ul><li>异步加载文件</li><li>异步下载文件</li><li>场景异步加载</li><li>批量创建时防止卡顿</li></ul></li></ul><h2 id="协同程序和线程的区别">协同程序和线程的区别</h2><ul><li>新开一个线程是独立的一个管道，和主线程并行执行</li><li>新开一个协程是在原线程之上开启，进行逻辑分时分步执行</li></ul><h2 id="协程的使用">协程的使用</h2><ul><li>继承MonoBehavior的类 都可以开启 协程函数</li></ul><h3 id="第一步：申明协程函数">第一步：申明协程函数</h3><ul><li>协程函数2个关键点<ul><li>1-1返回值为IEnumerator类型及其子类</li><li>1-2函数中通过 yield return 返回值;</li></ul></li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//关键点一： 协同程序（协程）函数 返回值 必须是 IEnumerator或者继承它的类型 </span></span><br><span class="line"><span class="function">IEnumerator <span class="title">MyCoroutine</span>(<span class="params"><span class="built_in">int</span> i, <span class="built_in">string</span> str</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    print(i);</span><br><span class="line">    <span class="comment">//关键点二： 协程函数当中 必须使用 yield return 进行返回</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    print(str);</span><br><span class="line">    <span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title">WaitForSeconds</span>(<span class="params"><span class="number">1f</span></span>)</span>;</span><br><span class="line">    print(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">    <span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title">WaitForFixedUpdate</span>()</span>;</span><br><span class="line">    print(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">    <span class="comment">//主要会用来截图时会使用，保证画面完整正常</span></span><br><span class="line">    <span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title">WaitForEndOfFrame</span>()</span>;</span><br><span class="line">    <span class="comment">//可以写死循环，不会卡死主线程</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        print(<span class="string">&quot;5&quot;</span>);</span><br><span class="line">        <span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title">WaitForSeconds</span>(<span class="params"><span class="number">5f</span></span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="第二步：开启协程函数">第二步：开启协程函数</h3><ul><li>这样执行没有任何效果</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MyCoroutine(<span class="number">1</span>, <span class="string">&quot;123&quot;</span>);</span><br></pre></td></tr></table></figure><ul><li>常用开启方式</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">IEnumerator ie = MyCoroutine(<span class="number">1</span>, <span class="string">&quot;123&quot;</span>);</span><br><span class="line">StartCoroutine(ie);</span><br></pre></td></tr></table></figure><h3 id="第三步：关闭协程">第三步：关闭协程</h3><ul><li>关闭所有协程</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">StopAllCoroutines();</span><br></pre></td></tr></table></figure><ul><li>关闭指定协程</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Coroutine c1 = StartCoroutine(MyCoroutine(<span class="number">1</span>,<span class="string">&quot;123&quot;</span>));</span><br><span class="line">StopCoroutine(c1);</span><br></pre></td></tr></table></figure><h2 id="yield-return-不同内容的含义">yield return 不同内容的含义</h2><h3 id="下一帧执行">下一帧执行</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">yield</span> <span class="keyword">return</span> 数字;</span><br><span class="line"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><ul><li>在Update和LateUpdate之间执行</li></ul><h3 id="等待指定秒后执行">等待指定秒后执行</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title">WaitForSeconds</span>(<span class="params">second</span>)</span>;</span><br></pre></td></tr></table></figure><ul><li>在Update和LateUpdate之间执行</li></ul><h3 id="等待下一个固定物理帧更新时执行">等待下一个固定物理帧更新时执行</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title">WaitForFixedUpdate</span>()</span>;</span><br></pre></td></tr></table></figure><ul><li>在FixedUpdate和碰撞检测相关函数之后执行</li></ul><h3 id="等待摄像机和GUI渲染完成后执行">等待摄像机和GUI渲染完成后执行</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title">WaitForEndOfFrame</span>()</span>;</span><br></pre></td></tr></table></figure><ul><li>在LateUpdate之后的渲染相关处理完毕后之执行</li></ul><h3 id="一些特殊类型的对象-比如异步加载相关函对象">一些特殊类型的对象 比如异步加载相关函对象</h3><ul><li>之后讲解：异步加载资源、异步加载场景、网络加载时讲解</li><li>一般在Update和LateUpdate之间执</li></ul><h3 id="跳出协程">跳出协程</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">yield</span> <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><h2 id="协程受对象和组件失活销毁的影响">协程受对象和组件失活销毁的影响</h2><ul><li>协程开启后<ul><li>组件和物体销毁，协程<font color="red">不执行</font></li><li>物体失活协程<font color="red">不执行</font>，组件失活协程<font color="red">执行</font></li></ul></li><li>与延迟函数相比 延迟函数：<ul><li>组件和物体销毁，延迟函数<font color="red">不执行</font></li><li>物体失活延迟函数<font color="red">执行</font>，组件失活延迟函数<font color="red">执行</font></li></ul></li></ul><h2 id="协程的本质">协程的本质</h2><ul><li>协程可以分成两部分<ul><li>协程函数本体<br>协程本体就是一个能够中间暂停返回的函数,本质上就是一个 C#的迭代器方法</li><li>协程调度器<br>协程调度器是Unity内部实现的，会在对应的时机帮助我们继续执行协程函数</li></ul></li><li>Unity只实现了协程调度部分</li></ul><h3 id="理解">理解</h3><ul><li><p>C#看到迭代器函数和yield return 语法糖就会把原本是一个的 函数变成&quot;几部分&quot;<br>我们可以通过迭代器  从上到下遍历这 &quot;几部分&quot;进行执行  就达到了将一个函数中的逻辑分时执行的目的</p></li><li><p>而协程调度器就是 利用迭代器函数返回的内容来进行之后的处理<br>比如Unity中的协程调度器 根据yield return 返回的内容 决定了下一次在何时继续执行迭代器函数中的&quot;下一部分&quot;</p></li><li><p>理论上来说 我们可以利用迭代器函数的特点 自己实现协程调度器来取代Unity自带的调度器</p></li></ul><h2 id="例子：使用协程避免批量加载物体时卡顿">例子：使用协程避免批量加载物体时卡顿</h2><p>问题：请在场景中创建100000各随机位置的立方体，让其不会明显卡顿<br>分析：如果在同一帧中同时创建100000个物体，会超出1帧的时间，让玩家感到明显卡顿；<br>此时可以使用协程分不同帧分批次创建，例如每帧创建1000个，可减少卡顿。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">IEnumerator <span class="title">CreateCube</span>(<span class="params"><span class="built_in">int</span> num</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>; i&lt;num; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        GameObject obj = GameObject.CreatePrimitive(Primitive.Cube);</span><br><span class="line">        obj.transform.position = <span class="keyword">new</span> Vector3(Random.Range(<span class="number">-100</span>, <span class="number">100</span>),Random.Range(<span class="number">-100</span>, <span class="number">100</span>),Random.Range(<span class="number">-100</span>, <span class="number">100</span>));</span><br><span class="line">        <span class="keyword">if</span>(i % <span class="number">1000</span> == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">yield</span> <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结">总结</h2><ol><li>Unity支持多线程，只是新开线程无法访问主线程中Unity相关内容<ul><li>一般主要用于进行复杂逻辑运算或者网络消息接收等等</li><li>注意：Unity中的多线程一定记住关闭</li></ul></li><li>协同程序不是多线程，它是将线程中逻辑进行分时执行，避免卡顿</li><li>继承MonoBehavior的类都可以使用协程</li><li>开启协程方法、关闭协程方法</li><li>yield return 返回的内容对于我们的意义</li><li>协程只有当组件单独失活时不受影响，其它情况协程会停止</li></ol>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>5G技术概述</title>
      <link href="/post/e255a10a.html"/>
      <url>/post/e255a10a.html</url>
      
        <content type="html"><![CDATA[<h1>摘要</h1><p>随着技术的快速发展，移动通信已经从最初的1G网络逐步演变到4G的广泛部署。本文深入探讨了第五代移动通信技术——5G的定义、特点和潜在影响。本文首先回顾了移动通信的历史，从模拟技术的1G到4G的高速数据传输，强调了每一代技术如何塑造人类的生活和工作方式。本文指出，21世纪的移动通信正面临前所未有的繁荣与变革，特别是随着智能设备和大数据应用的兴起。为了满足这些新的技术需求，5G技术应运而生。本文详细分析了5G的关键技术组件，包括毫米波技术、大规模MIMO、全双工通信、网络切片，以及为5G通信提供高效率和可靠性的极化码技术。这些技术组合为5G提供了前所未有的数据传输速度和低延迟性能，使其成为支持物联网、虚拟现实和其他创新应用的理想选择。总的来说，5G技术不仅是前一代技术的简单进步，它预示着一个多连接、超高速、低延迟的未来，为全球经济和社会带来了巨大的潜在影响。<br><strong>关键词</strong>：毫米波；大规模MIMO；全双工通信；网络切片；极化码</p><h1>1 引言</h1><p>在技术的长河中，每一次波澜壮阔的变革都为人类社会带来了前所未有的机遇和挑战。从最初的电话通信到如今的全球移动网络，通信技术的每一次飞跃都重塑了我们的日常生活和商业模式。从最初的 1G 网络，到 4G 的广泛部署，每一代技术都以其独特的方式改变了人们的生活和工作方式。而今，我们正站在一个全新的技术革命的前沿——5G。作为第五代移动通信技术，5G 不仅仅是前一代技术的简单进步，它预示着一个多连接、超高速、低延迟的未来。此报告旨在深入探讨5G技术的定义、特点、技术核心、应用及其对全球经济和社会的潜在影响，为读者呈现一个全面的5G技术图景</p><h1>2 研究现状</h1><h2 id="2-1-移动通信的历史回顾">2.1 移动通信的历史回顾</h2><p>自1980年代初推出的1G开始，移动通信经历了显著的变革。1G基于模拟技术，主要支持语音通信。随后，2G引入了数字技术，不仅提高了通话质量，还支持了简单的数据服务如短信。进入21世纪，3G带来了更快的数据传输速度，使得视频通话和移动互联网成为可能。最后，4G进一步加快了数据速度，为高清流媒体和更复杂的在线应用提供了支持。</p><h2 id="2-2-21世纪移动通信的需求与挑战">2.2 21世纪移动通信的需求与挑战</h2><p>21世纪的移动通信迎来了前所未有的繁荣与变革，伴随着智能设备的日益普及和大数据应用的兴起。人们不再满足于简单的语音通话，而是追求高清视频、无缝的在线协作和实时的大数据交互。同时，随着物联网的兴起，从家用电器到城市基础设施，越来越多的设备需要接入网络。这不仅带来了对更高带宽和更低延迟的迫切需求，还对网络的稳定性和安全性提出了更高的要求。如何满足这些需求，同时应对频谱资源有限、网络安全威胁增多等挑战，已成为当代移动通信领域面临的关键课题。</p><h2 id="2-3-前驱技术的局限性和为什么我们需要5G">2.3 前驱技术的局限性和为什么我们需要5G</h2><p>前驱技术，尤其是4G，虽然为我们提供了快速的网络连接，但在处理大量设备连接、超高速数据传输和低延迟应用方面仍存在局限性。随着物联网、虚拟现实和自动驾驶等技术的兴起，对网络的要求也日益增长。5G应运而生，不仅为了满足这些新的技术需求，还为解决4G无法覆盖的领域提供了解决方案，从而推动数字化的下一步发展。</p><h1>3 5G技术的具体内容</h1><h2 id="3-1-频率与毫米波">3.1 频率与毫米波</h2><p>5G的一个关键指标是传输速率：按照通信行业的预期，5G应当实现比4G快十倍以上的传输速率，即5G的传输速率可实现1Gbps。无线传输增加传输速率一般有两种方法，一是增加频谱利用率，二是增加频谱带宽。但相对于提高频谱利用率，增加频谱带宽的方法显得更简单直接，在频谱利用率不变的情况下，可用带宽翻倍则可以实现的数据传输速率也会翻倍，但问题是，现在常用的5GHz以下的频段已经非常拥挤，所以为了获得新的频谱资源，人们想到的方法是使用毫米波技术。<br>5G技术在频率选择上涵盖了从低至高的多个范围，其中毫米波是高频段的代表。毫米波是指波长在毫米级别的电磁波，其频率通常在30GHz到300GHz之间。这一频率范围位于微波与红外波之间。</p><img src='../img/CN/毫米波.png' width="50%" height="70%" align="middle" alt='常用通信频段与毫米波频段范围'><p>根据通信原理，无线通信的最大信号带宽大约是载波频率的5%左右，因此载波频率越高，可实现的信号带宽也越大。在毫米波频段中，28GHz频段和60GHz频段是最有希望使用在5G的两个频段。28GHz频段的可用频谱带宽可达1GHz，而60GHz频段每个信道的可用信号带宽则到了2GHz。相比而言，4G-LTE频段最高频率的载波在2GHz上下，而可用频谱带宽只有100MHz。因此，如果使用毫米波频段，频谱带宽可以轻松达到4G标准的10倍，并且传输速率也可以得到很大的提升。<br>毫米波频段的另一个特征是它由于波长较短，穿透力差，在空气中衰减较大。因此毫米波几乎不可能实现信号穿墙传输，且传输距离较短。因此人们或许会感到遗憾，这项技术不太适合在室外手机终端和距离基站比较远的地区，这就使得5G在布局上需结合其他频率以实现全面覆盖，这也是为什么现在在很多情况下依然需要使用4G的原因。<br>为了解决这个问题，其中一个方案就是采用微型基站。在现在，信号的传输是通过一个大型高功率基站进行传输，由于不会过多的被介质影响，所以通过大功率传输能覆盖更多的设备。但是如果使用毫米波，人们和基站之间有介质格挡，则很难收到信号，为此人们采用用上千个低功耗小型基站进行首发信号来代替现在的大型基站。</p><img src='../img/CN/45G基站对比图.png' width="50%" height="70%" align="middle" alt='4G与5G基站模式对比图'><p>但这个并不意味着穿透力差就没有价值，因为与此同时，其他终端发出的毫米波信号的衰减也会很大，如果设计得当，则不需要考虑来自其他毫米波信号源的干扰。选择使用60Hz毫米波更是很好的利用了这点，因为60Hz正是氧气的共振频率，其信号在空气中衰减会非常快，从而很大程度上减少了来自不同终端的干扰。</p><h2 id="3-2-大规模MIMO-多输入多输出">3.2 大规模MIMO (多输入多输出)</h2><p>MIMO是“多输入多输出”（Multiple Input, Multiple Output）的缩写，是一种无线通信技术，通过在发送和接收两端使用多个天线来提高无线系统的性能。在物理空间中，多个天线之间存在多个独立的传播路径。MIMO技术通过这些不同的路径同时发送和接收多个数据流，从而提高数据速率和/或信号质量。<br>而5G使用的大规模MIMO技术区别于传统4G MIMO的最多8天线通道，大规模MIMO[2]在5G中实现16/32/64通道。5G的大规模MIMO技术就是大量天线的波束成形。<br>波束成形是一种无线通信技术，旨在控制发射的无线信号波束的方向，从而优化信号的传输效率和质量。通过精确地指向接收设备或避免潜在的干扰源，波束成形有助于提高信号质量、增加数据传输速率和扩大覆盖范围。随着5G技术中MIMO系统天线数量的增加，波束成形通过生成不同方向的波束如垂直波束和水平波束，形成了3D模式的波束成形，其借助移动终端的反馈，可以定位到空间中任意一个点，以提升面向具体对象的数据传输速率和容量。<br>大规模MIMO因为波束成形后天线的波束非常窄，并且可以精确的为用户提供覆盖，故可以很大程度上减少对其他通信信号的干扰。</p><img src='../img/CN/波束成形.png' width="70%" height="70%" align="middle" alt='单天线通信方式与3D波束成形对比图'><h2 id="3-3-全双工通信">3.3 全双工通信</h2><p>5G技术的全双工通信[3]是5G通信技术中的一个重要组成部分，它允许在同一时间、同一频段上进行双向通信。这与传统的半双工和单工通信方式不同，它们只允许在给定的时间或频率上进行单向通信。使用全双工技术可以提高频谱效率，因为它允许在同一频段上同时进行发送和接收。这意味着运营商可以在现有的频谱资源上提供更高的数据速率和更多的用户连接。</p><img src='../img/CN/全双工通信.png' width="50%" height="70%" align="middle" alt='全双工通信流程图'><p>这种全双工技术的实现主要依赖于先进的自干扰消除技术。在全双工通信中，设备在同一时间、同一频段上进行发送和接收。这意味着发送的信号有可能对接收的信号产生强烈的干扰，这种干扰被称为自干扰。自干扰的存在严重影响了全双工通信的性能和可靠性。<br>为了成功实现全双工通信，必须有效地消除或至少大大减少这种自干扰。自干扰消除技术主要分为数字和模拟两大类。<br>在模拟领域，自干扰消除的方法主要集中在射频前端的设计。首先，天线设计和放置策略起到了关键作用。通过使用天线隔离技术，可以减少发送和接收天线之间的相互干扰。此外，方向性天线和波束成形技术也被用来进一步减少发送和接收路径之间的干扰。<br>数字自干扰消除则依赖于先进的信号处理算法。这些算法能够实时地估计和消除自干扰，确保接收到的信号质量。这通常涉及到复杂的自适应滤波器，它们可以根据当前的通信环境动态地调整参数，以最大限度地减少自干扰。上文提到的MIMO技术，也在数字自干扰消除中发挥了重要作用。通过使用多个天线，系统可以更好地估计和消除自干扰。</p><h2 id="3-4-网络切片">3.4 网络切片</h2><p>在物联网技术快速发展的今天，接入互联网的设备数量剧增，要实现从人-人连接到万物连接，连接的数量成倍上升，网络必将愈发拥堵，越来越复杂。因为我们就得像交通管理一样，对网络实行分流管理，即网络切片。<br>在人群密集的场所，4G网络就会变得很慢，出现这种情况的原因是，假设一个基站相当于一个路由器，而附近的用户全部连接到该基站上，基站所提供的带宽是有上限的，一旦连接的人数过多，速度会变得很慢，这就是大家常说的“抢网速”，网络切片就可以解决这个问题。通过将5G网络分成很多片，每一片满足不同用户的需求。这是因为不同用户对于网络的需求是不同的，比如直播用户对上传要求更高，游戏用户则要求延迟低。网络切片技术则可以针对性的为不同用户提供不同的网络能力，从而满足不同业务场景对于网络的需求。<br>我们将5G网络的应用场景划分为三类：移动宽带、海量物联网和任务关键性物联网。</p><table><thead><tr><th style="text-align:center">5G应用场景</th><th style="text-align:center">应用举例</th><th style="text-align:center">需求</th></tr></thead><tbody><tr><td style="text-align:center">移动带宽</td><td style="text-align:center">4K/8K视频、全息技术、AR、VR</td><td style="text-align:center">高容量，视频存储</td></tr><tr><td style="text-align:center">海量物联网</td><td style="text-align:center">海量传感器（部署于测量、农业、智慧城市、家庭等）</td><td style="text-align:center">大规模连接且大部分静止</td></tr><tr><td style="text-align:center">任务关键性物联网</td><td style="text-align:center">无人驾驶、自动工厂、智能电网等</td><td style="text-align:center">延时低、高可靠性</td></tr></tbody></table><p>我们并不需要为每一类应用场景构建一个网络，我们要做的是，将一个物理网络分成多个虚拟的逻辑网络，每一个虚拟网络对应不同的应用场景，这就叫网络切片。<br>网络切片是一种网络虚拟化技术，它将单一的物理网络分割成多个逻辑网络，每个逻辑网络都有其独特的网络资源、功能和优化策略。网络切片的创建和管理依赖于5G核心网络中的多个关键组件，包括网络切片子系统、网络功能虚拟化基础设施(NFVI)和服务基于编排系统。这些组件共同确保网络切片可以动态地创建、修改和删除，以满足不断变化的业务需求。</p><img src='../img/CN/网络切片.png' width="30%" height="70%" align="middle" alt='网络切片技术'><p>网络切片技术可以比喻为一栋大楼的多个独立公寓。想象一下，这栋大楼（物理网络）有多个公寓单元（网络切片），每个公寓单元都有自己的入口、客厅、卧室和厨房（网络资源和功能）。尽管所有的公寓单元都位于同一栋大楼内，但每个公寓都为其居民提供了独立、私密的生活空间。<br>每个公寓可以根据其居民的需求进行定制，例如，一个三口之家可能需要一个带有儿童房的大公寓，而一对新婚夫妇可能只需要一个小公寓。同样，网络切片可以根据不同的业务需求进行优化和定制。例如，某些切片可能被优化用于高速数据传输，而其他切片可能被优化用于低延迟通信。<br>此外，就像大楼管理员可以根据需要增加或减少公寓单元，网络运营商也可以动态地创建、修改或删除网络切片，以满足不断变化的业务需求。</p><h1>4 5G的数据传输</h1><h2 id="4-1-数据传输以及与4G相比的优势">4.1 数据传输以及与4G相比的优势</h2><ul><li><strong>速度</strong>：理论上，5G的峰值下载速度可以达到20Gbps，而上传速度可以达到10Gbps。然而，实际使用中的速度可能会受到多种因素的影响，如网络拥塞、用户距离基站的远近等。在实际部署中，用户可以期望在城市和其他高密度地区获得1Gbps到3Gbps的速度。而4G LTE的峰值速度通常在1Gbps以下。这意味着5G的速度是4G的多倍。</li><li><strong>容量</strong>：5G技术采用了更高效的编码和调制方案，使得每赫兹的频谱可以传输更多的数据；5G还利用了更多的频谱资源，包括毫米波频段，这为更高的数据速率和更大的网络容量提供了空间；通过部署大量的小型基站，5G网络可以在相同的地理区域内支持更多的用户和设备</li><li><strong>延迟</strong>：5G的延迟可以低至1毫秒，而4G的延迟通常在30-50毫秒之间。低延迟对于实时应用如在线游戏、自动驾驶汽车和远程手术至关重要。</li><li><strong>连接密度</strong>：5G可以支持每平方公里内多达100万个连接设备，而4G的连接密度远低于这个数字。这使得5G更适合物联网应用。</li></ul><h2 id="4-2-数据的编码与调制">4.2 数据的编码与调制</h2><p>5G的通信编码是为了确保在无线信道中高效、可靠地传输数据。在5G中，特别引入了两种先进的信道编码技术：极化码Polar Codes[5]和低密度奇偶校验码LDPC。</p><h3 id="4-2-1-信道模型">4.2.1 信道模型</h3><p>通信过程中，物理层传输的就是电信号，假如我们只用0和1传输信号，并且这些信道互相都没有关系，我们称为二进制离散无记忆信道。信道模型是研究信道编码的基础，常见的几种信道模型分别有：二进制删除信道（BEC）、二进制对称信道（BSC）、高斯信道（AWGN）。设信道的输入和输出分别是长为N的序列，输入是x，输出是y，其信道的转移概率满足：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>P</mi><mrow><mo fence="true">(</mo><mi>y</mi><mi mathvariant="normal">∣</mi><mi>x</mi><mo fence="true">)</mo></mrow><mo>=</mo><mi><munder><mo><mi><mover><mo><mi>Σ</mi></mo><mi>N</mi></mover></mi></mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow></munder></mi><mi>P</mi><mrow><mo fence="true">(</mo><msub><mi>y</mi><mi>i</mi></msub><mi mathvariant="normal">∣</mi><msub><mi>x</mi><mi>i</mi></msub><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">P\left( y|x \right) =\underset{i=1}{\overset{N}{\varSigma}}P\left( y_i|x_i \right) </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mord">∣</span><span class="mord mathnormal">x</span><span class="mclose delimcenter" style="top:0em;">)</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.1893em;vertical-align:-0.7277em;"></span><span class="mord"><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.4617em;"><span style="top:-2.834em;margin-left:0em;"><span class="pstrut" style="height:3.4617em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.4617em;"><span class="pstrut" style="height:3.4617em;"></span><span><span class="mop"><span class="mord"><span class="mop op-limits"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.4617em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span><span class="mop mathit">Σ</span></span></span><span style="top:-3.8833em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.7277em;"><span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">∣</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;">)</span></span></span></span></span></span></p><p>二进制删除信道，简记为BEC。 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">ϵ</span></span></span></span>称为删除概率，表示有 的概率这个信号会丢失。当接收方得到一个位，它是100%确定的位是正确的。只有当位被擦除时，才会出现唯一的混淆。对于二进制离散无记忆信道，我们有 的概率丢失0或者1的比特位。BEC的信道容量为：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>C</mi><mtext> </mtext><mtext> </mtext><mo>=</mo><mtext> </mtext><mtext> </mtext><mn>1</mn><mo>−</mo><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">C\,\,=\,\,1-\epsilon </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">ϵ</span></span></span></span></span></p><h3 id="4-2-2-极化码">4.2.2 极化码</h3><p>极化码的核心是信道极化。这个过程通过特殊的“合成”操作，将多个独立的二进制删除信道（BEC）转换为两类极端信道：一类几乎无错误，另一类错误率很高。理论上，当这种合成操作重复多次时（即信道数量趋向于无限），完美信道的比例将接近信道的初始容量。在这些“极化”信道中，信息被发送通过接近完美的信道，而冗余信息（用于错误更正）被放置在质量较差的信道中。<br>假设有一个二元消除信道（BEC），其消除概率为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">ϵ</span></span></span></span>，我们假设其为0.5。这意味着发送的比特要么不变，要么被“消除”变成一个未知状态，标记为“？”。<br>现在，我们创建两个并行的 BEC 信道，并应用极化变换。为了简化，我们考虑发送两个比特，U1 和 U2。我们通过以下方式将其转换为 X1 和 X2：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mo fence="true">{</mo><mtable rowspacing="0.36em" columnalign="left left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>X</mi><mn>1</mn><mo>=</mo><mi>U</mi><mn>1</mn><mo>⊕</mo><mi>U</mi><mn>2</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>X</mi><mn>2</mn><mo>=</mo><mi>U</mi><mn>2</mn></mrow></mstyle></mtd></mtr></mtable></mrow><annotation encoding="application/x-tex">\begin{cases}X1=U1\oplus U2\\X2=U2\\\end{cases}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:3em;vertical-align:-1.25em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size4">{</span></span><span class="mord"><span class="mtable"><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.69em;"><span style="top:-3.69em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="mord">2</span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="mord">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.19em;"><span></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p>X1通过信道一在接收端得到Y1，X2通过信道二在接收端得到Y2，由于异或算的特性，且BEC信道如果传输成功那么一定是正确的的特点，我们可以得到</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mo fence="true">{</mo><mtable rowspacing="0.36em" columnalign="left left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>X</mi><mn>1</mn><mo>⊕</mo><mi>U</mi><mn>2</mn><mo>=</mo><mi>U</mi><mn>1</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>X</mi><mn>1</mn><mo>=</mo><mi>Y</mi><mn>1</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>U</mi><mn>2</mn><mo>=</mo><mi>X</mi><mn>2</mn><mo>=</mo><mi>Y</mi><mn>2</mn></mrow></mstyle></mtd></mtr></mtable></mrow><annotation encoding="application/x-tex">\begin{cases}X1\oplus U2=U1\\X1=Y1\\U2=X2=Y2\\\end{cases}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:4.32em;vertical-align:-1.91em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.35em;"><span style="top:-2.2em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎩</span></span></span><span style="top:-2.192em;"><span class="pstrut" style="height:3.15em;"></span><span style="height:0.316em;width:0.8889em;"><svg xmlns="http://www.w3.org/2000/svg" width='0.8889em' height='0.316em' style='width:0.8889em' viewBox='0 0 888.89 316' preserveAspectRatio='xMinYMin'><path d='M384 0 H504 V316 H384z M384 0 H504 V316 H384z'/></svg></span></span><span style="top:-3.15em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎨</span></span></span><span style="top:-4.292em;"><span class="pstrut" style="height:3.15em;"></span><span style="height:0.316em;width:0.8889em;"><svg xmlns="http://www.w3.org/2000/svg" width='0.8889em' height='0.316em' style='width:0.8889em' viewBox='0 0 888.89 316' preserveAspectRatio='xMinYMin'><path d='M384 0 H504 V316 H384z M384 0 H504 V316 H384z'/></svg></span></span><span style="top:-4.6em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎧</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.85em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.41em;"><span style="top:-4.41em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="mord">1</span></span></span><span style="top:-2.97em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mord">1</span></span></span><span style="top:-1.53em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mord">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.91em;"><span></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p>由这三个已知条件进而可以得到 ，如果将中间的模型视作一个黑箱，我们可以得到输入U1的影响，扩散到Y1、Y2两个值里面，即</p><img src='../img/CN/信道传输黑箱模型.png' width="70%" height="70%" align="middle" alt='信道传输黑箱模型'><p>这个过程在理论上可以看作是产生了一个新的信道，取<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>W</mi><mo>−</mo></msup></mrow><annotation encoding="application/x-tex">W^-</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7713em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7713em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">−</span></span></span></span></span></span></span></span></span></span></span> 。这里U1能解出来的前提是两个BEC信道都传输成功，但实际上是因为信道的不完美性（例如噪声），我们得到的结果可能有不同的组合如下：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mtext>信道</mtext><msup><mi>W</mi><mo>−</mo></msup><mtext> </mtext><mtext> </mtext><mrow><mo fence="true">{</mo><mtable rowspacing="0.36em" columnalign="left left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>Y</mi><mn>1</mn><mi>Y</mi><mn>2</mn><mi>U</mi><mn>1</mn><mo>=</mo><mi>Y</mi><mn>1</mn><mo>⊕</mo><mi>Y</mi><mn>2</mn><mtext>解码成功</mtext></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mtext>？</mtext><mi>Y</mi><mn>2</mn><mi>U</mi><mn>1</mn><mo>=</mo><mtext> </mtext><mtext> </mtext><mtext>？</mtext><mo>⊕</mo><mi>Y</mi><mn>2</mn><mtext>解码失败</mtext></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>Y</mi><mn>1</mn><mtext>？</mtext><mi>U</mi><mn>1</mn><mo>=</mo><mi>Y</mi><mn>1</mn><mo>⊕</mo><mtext> </mtext><mtext> </mtext><mtext>？解码失败</mtext></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mtext>？？</mtext><mi>U</mi><mn>1</mn><mo>=</mo><mtext> </mtext><mtext> </mtext><mtext>？</mtext><mo>⊕</mo><mtext> </mtext><mtext> </mtext><mtext>？解码失败</mtext></mrow></mstyle></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">\text{信道}W^-\,\, \begin{cases}Y1 Y2   U1=Y1\oplus Y2     \text{解码成功}\\\text{？} Y2   U1=\,\,\text{？}\oplus Y2     \text{解码失败}\\Y1 \text{？}   U1=Y1\oplus \,\,\text{？}     \text{解码失败}\\\text{？}  \text{？}   U1=\,\,\text{？}\oplus \,\,\text{？}     \text{解码失败}\\\end{cases}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:5.76em;vertical-align:-2.63em;"></span><span class="mord text"><span class="mord cjk_fallback">信道</span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8213em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">−</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.95em;"><span style="top:-1.6em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎩</span></span></span><span style="top:-1.592em;"><span class="pstrut" style="height:3.15em;"></span><span style="height:0.916em;width:0.8889em;"><svg xmlns="http://www.w3.org/2000/svg" width='0.8889em' height='0.916em' style='width:0.8889em' viewBox='0 0 888.89 916' preserveAspectRatio='xMinYMin'><path d='M384 0 H504 V916 H384z M384 0 H504 V916 H384z'/></svg></span></span><span style="top:-3.15em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎨</span></span></span><span style="top:-4.292em;"><span class="pstrut" style="height:3.15em;"></span><span style="height:0.916em;width:0.8889em;"><svg xmlns="http://www.w3.org/2000/svg" width='0.8889em' height='0.916em' style='width:0.8889em' viewBox='0 0 888.89 916' preserveAspectRatio='xMinYMin'><path d='M384 0 H504 V916 H384z M384 0 H504 V916 H384z'/></svg></span></span><span style="top:-5.2em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎧</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.45em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:3.13em;"><span style="top:-5.13em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mord">1</span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mord">2</span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mord">2</span><span class="mord text"><span class="mord cjk_fallback">解码成功</span></span></span></span><span style="top:-3.69em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord text"><span class="mord cjk_fallback">？</span></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mord">2</span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord text"><span class="mord cjk_fallback">？</span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mord">2</span><span class="mord text"><span class="mord cjk_fallback">解码失败</span></span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mord">1</span><span class="mord text"><span class="mord cjk_fallback">？</span></span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord text"><span class="mord cjk_fallback">？</span></span><span class="mord text"><span class="mord cjk_fallback">解码失败</span></span></span></span><span style="top:-0.81em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord text"><span class="mord cjk_fallback">？</span></span><span class="mord text"><span class="mord cjk_fallback">？</span></span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord text"><span class="mord cjk_fallback">？</span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord text"><span class="mord cjk_fallback">？</span></span><span class="mord text"><span class="mord cjk_fallback">解码失败</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.63em;"><span></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p>也就是说在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>W</mi><mo>−</mo></msup></mrow><annotation encoding="application/x-tex">W^-</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7713em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7713em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">−</span></span></span></span></span></span></span></span></span></span></span>信道里，信息传输成功的概率由<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>−</mo><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">1-\epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">ϵ</span></span></span></span> 变成了 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mrow><mo fence="true">(</mo><mn>1</mn><mo>−</mo><mi>ϵ</mi><mo fence="true">)</mo></mrow><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">\left( 1-\epsilon \right) ^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.204em;vertical-align:-0.25em;"></span><span class="minner"><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal">ϵ</span><span class="mclose delimcenter" style="top:0em;">)</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.954em;"><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span>，被擦除的概率变为了 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>−</mo><msup><mrow><mo fence="true">(</mo><mn>1</mn><mo>−</mo><mi>ϵ</mi><mo fence="true">)</mo></mrow><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">1-\left( 1-\epsilon \right) ^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.204em;vertical-align:-0.25em;"></span><span class="minner"><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal">ϵ</span><span class="mclose delimcenter" style="top:0em;">)</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.954em;"><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span>，我们前面假设 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϵ</mi><mo>=</mo><mn>0.5</mn></mrow><annotation encoding="application/x-tex">\epsilon =0.5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">ϵ</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0.5</span></span></span></span>，那么<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>W</mi><mo>−</mo></msup></mrow><annotation encoding="application/x-tex">W^-</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7713em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7713em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">−</span></span></span></span></span></span></span></span></span></span></span>信道中的信息将有75%的概率被擦除，相较于开始的50%, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>W</mi><mo>−</mo></msup></mrow><annotation encoding="application/x-tex">W^-</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7713em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7713em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">−</span></span></span></span></span></span></span></span></span></span></span>信道明显变差了。<br>现在解码U2，由于U2可以由U1和Y1异或得来，我们可以得到输入U2的影响，可以扩散到Y1、Y2和U1三个值里，取名为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>W</mi><mo>+</mo></msup></mrow><annotation encoding="application/x-tex">W^+</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7713em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7713em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">+</span></span></span></span></span></span></span></span></span></span></span>，可以得到如下情况：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mtext>信道</mtext><msup><mi>W</mi><mo>+</mo></msup><mtext> </mtext><mtext> </mtext><mrow><mo fence="true">{</mo><mtable rowspacing="0.36em" columnalign="left left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>Y</mi><mn>1</mn><mi>Y</mi><mn>2</mn><mi>U</mi><mn>2</mn><mo>=</mo><mi>X</mi><mn>2</mn><mo>=</mo><mi>Y</mi><mn>2</mn><mtext>解码成功</mtext></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mtext>？</mtext><mi>Y</mi><mn>2</mn><mi>U</mi><mn>2</mn><mo>=</mo><mtext> </mtext><mtext> </mtext><mi>X</mi><mn>2</mn><mo>=</mo><mi>Y</mi><mn>2</mn><mtext>解码成功</mtext></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>Y</mi><mn>1</mn><mtext>？</mtext><mi>U</mi><mn>2</mn><mo>=</mo><mtext> </mtext><mtext> </mtext><mi>U</mi><mn>1</mn><mo>⊕</mo><mtext> </mtext><mtext> </mtext><mi>Y</mi><mn>1</mn><mtext>解码成功</mtext></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mtext>？？</mtext><mi>U</mi><mn>2</mn><mo>=</mo><mtext> </mtext><mtext> </mtext><mtext>？解码失败</mtext></mrow></mstyle></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">\text{信道}W^+\,\, \begin{cases}Y1 Y2   U2=X2=Y2     \text{解码成功}\\\text{？} Y2   U2=\,\,X2=Y2     \text{解码成功}\\Y1 \text{？}   U2=\,\,U1\oplus \,\,Y1     \text{解码成功}\\\text{？}  \text{？}   U2=\,\,\text{？}              \text{解码失败}\\\end{cases}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:5.76em;vertical-align:-2.63em;"></span><span class="mord text"><span class="mord cjk_fallback">信道</span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8213em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">+</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.95em;"><span style="top:-1.6em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎩</span></span></span><span style="top:-1.592em;"><span class="pstrut" style="height:3.15em;"></span><span style="height:0.916em;width:0.8889em;"><svg xmlns="http://www.w3.org/2000/svg" width='0.8889em' height='0.916em' style='width:0.8889em' viewBox='0 0 888.89 916' preserveAspectRatio='xMinYMin'><path d='M384 0 H504 V916 H384z M384 0 H504 V916 H384z'/></svg></span></span><span style="top:-3.15em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎨</span></span></span><span style="top:-4.292em;"><span class="pstrut" style="height:3.15em;"></span><span style="height:0.916em;width:0.8889em;"><svg xmlns="http://www.w3.org/2000/svg" width='0.8889em' height='0.916em' style='width:0.8889em' viewBox='0 0 888.89 916' preserveAspectRatio='xMinYMin'><path d='M384 0 H504 V916 H384z M384 0 H504 V916 H384z'/></svg></span></span><span style="top:-5.2em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎧</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.45em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:3.13em;"><span style="top:-5.13em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mord">1</span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mord">2</span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mord">2</span><span class="mord text"><span class="mord cjk_fallback">解码成功</span></span></span></span><span style="top:-3.69em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord text"><span class="mord cjk_fallback">？</span></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mord">2</span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mord">2</span><span class="mord text"><span class="mord cjk_fallback">解码成功</span></span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mord">1</span><span class="mord text"><span class="mord cjk_fallback">？</span></span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mord">1</span><span class="mord text"><span class="mord cjk_fallback">解码成功</span></span></span></span><span style="top:-0.81em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord text"><span class="mord cjk_fallback">？</span></span><span class="mord text"><span class="mord cjk_fallback">？</span></span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord text"><span class="mord cjk_fallback">？</span></span><span class="mord text"><span class="mord cjk_fallback">解码失败</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.63em;"><span></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>W</mi><mo>+</mo></msup></mrow><annotation encoding="application/x-tex">W^+</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7713em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7713em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">+</span></span></span></span></span></span></span></span></span></span></span> 信道只有一种可能信被擦除，被擦除率为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>ϵ</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">\epsilon^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord mathnormal">ϵ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span> ， <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>W</mi><mo>+</mo></msup></mrow><annotation encoding="application/x-tex">W^+</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7713em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7713em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">+</span></span></span></span></span></span></span></span></span></span></span>的擦除率由开始的50%变为了25%。在<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>U</mi><mn>2</mn><mo>=</mo><mtext> </mtext><mtext> </mtext><mi>U</mi><mn>1</mn><mo>⊕</mo><mtext> </mtext><mtext> </mtext><mi>Y</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">U2=\,\,U1\oplus \,\,Y1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mord">1</span></span></span></span>的这种情况下，可能无法确定U1的值，所以在这里的思路是U1的值提前约定好，在接收端不用解码，直接用已知的U1值算出U2，这里的想法叫冻结。<br>如果增加信道，每个信道间都采取这种模型链接，我们会观察到，仅仅八个信道相连，就可以得到擦除概率为0.0039的信道。可以证明当信道足够多时，它们会被分成完全无噪声的好信道和完全噪声的差信道，前者传输成功的概率为1，后者为0。<br>只要将有效信息都编码在好信道里，舍弃无用的差信道，信息就能完全无损失的传播，这个过程就是极化。</p><h1>5 5G未来方向的讨论</h1><h2 id="5-1-5G技术的短期与长期前景">5.1 5G技术的短期与长期前景</h2><h3 id="5-1-1-短期前景（近五年）">5.1.1 短期前景（近五年）</h3><ul><li><strong>增强的移动通信</strong>：5G将在短期内提供更高的数据速度和更低的延迟，这将使用户能够享受更快的下载速度、更流畅的视频流和更快的网页加载时间。这对于智能手机、平板电脑和其他移动设备的用户来说将是一个巨大的改进。</li><li><strong>物联网的爆发</strong>：5G的低延迟和高容量将推动物联网的爆发。这将带来更多的智能家居设备、智能城市解决方案、智能工业和医疗设备，从而改善生活质量、提高效率并创造新的商机。</li><li><strong>自动驾驶汽车</strong>：5G将为自动驾驶汽车提供关键的通信基础设施，使它们能够实现更高级别的自动化，同时提高安全性。短期内，我们可以预期看到更多的汽车制造商推出与5G通信集成的自动驾驶功能。</li><li><strong>增强现实和虚拟现实</strong>：5G将为增强现实（AR）和虚拟现实（VR）提供更稳定、高清的图像传输，这将改善游戏、娱乐和培训等领域的用户体验。</li><li><strong>新的商业机会</strong>：5G将为企业带来新的商业机会，包括增强的云计算、边缘计算和工业自动化。这将改变许多行业的商业模式，推动创新和竞争。</li></ul><h3 id="5-1-2-长期前景（五到十年以及更远的未来）">5.1.2 长期前景（五到十年以及更远的未来）</h3><ul><li><strong>工业4.0的推动</strong>：5G将成为工业4.0的关键驱动力，加速制造业的数字化转型。自动化、智能制造和远程监控将在制造业中变得更加普遍。</li><li><strong>医疗保健创新</strong>：5G将推动远程医疗、医疗影像传输和医疗设备的进一步发展，提高医疗保健的可及性和效率。</li><li><strong>教育和培训</strong>：5G将改变教育和培训方式，使远程学习、虚拟实验室和远程培训更容易实现，提高教育的质量和可及性。</li><li><strong>新兴技术的崛起</strong>：长期来看，5G将为新兴技术如人工智能、区块链、量子计算等提供更快的数据传输速度和更强大的计算能力，促进这些领域的创新。<br>总之，5G技术在短期和长期内都将对社会和经济产生深远的影响，带来更快的连接、更多的创新和更多的商机。然而，它也可能带来一些挑战，如网络安全和隐私问题，需要得到妥善处理。</li></ul><h2 id="5-2-对未来移动信息技术的推动">5.2 对未来移动信息技术的推动</h2><p>5G技术将在未来移动通信技术领域产生革命性的推动作用。其高速、低延迟和大容量特性将极大地提升了移动通信的性能水平。用户将能够以前所未有的速度下载和上传数据，享受更高质量的通话和视频通信，以及更快速的互联网浏览体验。<br>5G的影响还将深远到物联网领域，将数十亿台智能设备连接到网络，并实现实时数据传输和互联。这将推动智能家居、智能城市、智能交通等领域的发展，为人们的生活带来更多便利和智能化解决方案。<br>此外，5G技术将为自动驾驶汽车提供关键支持，实现更高级别的自动化和实时通信，从而提高交通系统的安全性和效率。<br>总之，5G技术将引领未来移动通信技术的发展，为用户提供更快、更可靠的连接，同时也将催生出许多新的应用和商业机会，深刻地改变了人们与移动信息技术互动的方式。</p><h1>6 总结</h1><p>本文深入探讨了5G技术的发展及其对全球通信领域的革命性影响。从最初的1G模拟技术到4G的高速数据传输，移动通信技术已经经历了几十年的演变。每一次技术的进步都为社会带来了巨大的变革，重塑了人们的生活和工作方式。然而，随着21世纪对高速、低延迟和高可靠性通信的需求日益增长，尤其是在物联网、智能设备和大数据应用的推动下，现有的4G技术已经难以满足这些需求。这为5G技术的发展提供了契机。5G不仅预计将提供前所未有的数据传输速度，还将引入一系列创新技术，如毫米波、大规模MIMO、全双工通信和极化码。这些技术将确保5G能够支持未来的技术应用，如物联网、虚拟现实和增强现实。<br>总的来说，5G技术标志着通信领域的一个新时代，预示着一个连接更加紧密、通信更加高效的未来</p><h1>参考文献</h1><p>[1]李艳林. 5G毫米波阵列天线[D].电子科技大学,2023.<br>[2]李琳. 大规模MIMO系统中BFGS检测算法与实现技术研究[D].电子科技大学,2023.DOI:10.27005/d.cnki.gdzku.2022.004862.<br>[3]董冽沸,汪丽珍.5G通信场景技术要点分析[J].中国新通信,2022,24(08):4-6.<br>[4]田晨景,谢钧,曹浩彤等.5G网络切片研究进展[J/OL].计算机科学:1-22[2023-10-23].<a href="http://kns.cnki.net/kcms/detail/50.1075.TP.20230913.1311.024.html">http://kns.cnki.net/kcms/detail/50.1075.TP.20230913.1311.024.html</a>.<br>[5]E. Arikan, “Channel Polarization: A Method for Constructing Capacity-Achieving Codes for Symmetric Binary-Input Memoryless Channels,” in IEEE Transactions on Information Theory, vol. 55, no. 7, pp. 3051-3073, July 2009, doi: 10.1109/TIT.2009.2021379.</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HMM隐马尔可夫模型</title>
      <link href="/post/1cf48c7a.html"/>
      <url>/post/1cf48c7a.html</url>
      
        <content type="html"><![CDATA[<h2 id="HMM隐马尔可夫模型">HMM隐马尔可夫模型</h2><h3 id="观察序列与观察值">观察序列与观察值</h3><ul><li>时间序列：某些应用中，识别对象是一个动态的过程，无法用静态的矢量描述<ul><li>这些动态过程往往与时间相关，一般采用时间序列来描述</li></ul></li><li>观察序列：识别对象（样本）需要用一个长度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span></span>的观察序列来描述</li></ul><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msup><mi>V</mi><mi>T</mi></msup><mo>=</mo><msub><mi>v</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>v</mi><mn>2</mn></msub><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><msub><mi>v</mi><mi>T</mi></msub></mrow><annotation encoding="application/x-tex">V^T=v_1,v_2,\dots,v_T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8913em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></p><ul><li>观察值：观察序列中的元素<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mi>t</mi></msub></mrow><annotation encoding="application/x-tex">v_t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>对应时刻<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6151em;"></span><span class="mord mathnormal">t</span></span></span></span>的观察值，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mo>=</mo><mn>1</mn><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><mi>T</mi></mrow><annotation encoding="application/x-tex">t=1,\dots,T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6151em;"></span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span></span><ul><li>观察值描述了时刻<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6151em;"></span><span class="mord mathnormal">t</span></span></span></span>的特征，一般用一个特征矢量描述</li><li>语音信号，一般用一个采样帧的频谱特征作为观察矢量</li><li>视频信号，可以用每一帧图像的特征作为观察矢量</li></ul></li></ul><h3 id="一阶Markov模型">一阶Markov模型</h3><h4 id="状态序列">状态序列</h4><ul><li>M个状态 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>w</mi><mn>1</mn></msub><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><msub><mi>w</mi><mi>M</mi></msub></mrow><annotation encoding="application/x-tex">w_1,\dots,w_M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">M</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></li><li>时刻<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6151em;"></span><span class="mord mathnormal">t</span></span></span></span>,模型处于状态<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">w(t)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mclose">)</span></span></span></span>,并发生一次状态转移<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mo>−</mo><mo>&gt;</mo><mi>w</mi><mo stretchy="false">(</mo><mi>t</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">w(t)-&gt;w(t+1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mclose">)</span><span class="mord">−</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span></li><li>经过<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span></span>个状态，得到状态转移序列</li></ul><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msup><mi>W</mi><mi>T</mi></msup><mo>=</mo><mi>w</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo><mo>…</mo><mi>w</mi><mo stretchy="false">(</mo><mi>T</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">W^T=w(1)\dots w(T)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8913em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mclose">)</span></span></span></span></span></p><h4 id="两个规定">两个规定</h4><ul><li>模型在时刻<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6151em;"></span><span class="mord mathnormal">t</span></span></span></span>处于状态<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mo>=</mo><msub><mi>w</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">w(t)=w_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7167em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span>的概率完全由<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">t-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6984em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>时刻的状态<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi><mo stretchy="false">(</mo><mi>t</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>=</mo><msub><mi>w</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">w(t-1)=w_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>决定，与之前及以后的其他状态无关</li></ul><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>w</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mi mathvariant="normal">∣</mi><msup><mi>W</mi><mi>T</mi></msup><mo stretchy="false">)</mo><mo>=</mo><mi>P</mi><mo stretchy="false">(</mo><mi>w</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mi mathvariant="normal">∣</mi><mi>w</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><mi>w</mi><mo stretchy="false">(</mo><mi>T</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>=</mo><mi>P</mi><mo stretchy="false">(</mo><mi>w</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mi mathvariant="normal">∣</mi><mi>w</mi><mo stretchy="false">(</mo><mi>t</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">P(w(t)|W^T) = P(w(t)|w(1),\dots,w(T))=P(w(t)|w(t-1))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1413em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mclose">)</span><span class="mord">∣</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mclose">)</span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mclose">))</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mclose">)</span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">))</span></span></span></span></span></p><ul><li>由状态<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>w</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">w_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>转移到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>w</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">w_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7167em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span>的概率，与时刻<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6151em;"></span><span class="mord mathnormal">t</span></span></span></span>无关。</li></ul><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>w</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mo>=</mo><msub><mi>w</mi><mi>j</mi></msub><mi mathvariant="normal">∣</mi><mi>w</mi><mo stretchy="false">(</mo><mi>t</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>=</mo><msub><mi>w</mi><mi>i</mi></msub><mo stretchy="false">)</mo><mo>=</mo><msub><mi>a</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">P(w(t)=w_j|w(t-1)=w_i) = a_{ij}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7167em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">ij</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span></span></p><h4 id="模型参数">模型参数</h4><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>θ</mi><mo>=</mo><mo stretchy="false">(</mo><mi>π</mi><mo separator="true">,</mo><mi>A</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\theta=(\pi,A)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">A</span><span class="mclose">)</span></span></span></span></span></p><ul><li>模型初始位于状态<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>w</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">w_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的概率用<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>π</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">\pi_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>表示</li></ul><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>π</mi><mo>=</mo><mo stretchy="false">(</mo><msub><mi>π</mi><mn>1</mn></msub><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><msub><mi>π</mi><mi>M</mi></msub><msup><mo stretchy="false">)</mo><mi>t</mi></msup></mrow><annotation encoding="application/x-tex">\pi=(\pi_1,\dots,\pi_M)^t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0936em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">M</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8436em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span></span></span></span></span></span></span></span></span></p><ul><li>状态转移概率矩阵：</li></ul><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mo fence="true">[</mo><mtable rowspacing="0.16em" columnalign="center center center center" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>a</mi><mn>11</mn></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>a</mi><mn>12</mn></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mo lspace="0em" rspace="0em">⋯</mo></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>a</mi><mrow><mn>1</mn><mi>M</mi></mrow></msub></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>a</mi><mn>21</mn></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>a</mi><mn>22</mn></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mo lspace="0em" rspace="0em">⋯</mo></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>a</mi><mrow><mn>2</mn><mi>M</mi></mrow></msub></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mi><mi mathvariant="normal">⋮</mi><mpadded height="0em" voffset="0em"><mspace mathbackground="black" width="0em" height="1.5em"></mspace></mpadded></mi></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mi><mi mathvariant="normal">⋮</mi><mpadded height="0em" voffset="0em"><mspace mathbackground="black" width="0em" height="1.5em"></mspace></mpadded></mi></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mo lspace="0em" rspace="0em">⋱</mo></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mi><mi mathvariant="normal">⋮</mi><mpadded height="0em" voffset="0em"><mspace mathbackground="black" width="0em" height="1.5em"></mspace></mpadded></mi></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>a</mi><mrow><mi>M</mi><mn>1</mn></mrow></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>a</mi><mrow><mi>M</mi><mn>2</mn></mrow></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mo lspace="0em" rspace="0em">⋯</mo></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>a</mi><mrow><mi>M</mi><mi>M</mi></mrow></msub></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><annotation encoding="application/x-tex">\begin{bmatrix}a_{11}&amp;a_{12}&amp;\cdots&amp;a_{1M}\\a_{21}&amp;a_{22}&amp;\cdots&amp;a_{2M}\\\vdots&amp;\vdots&amp;\ddots&amp;\vdots\\a_{M1}&amp;a_{M2}&amp;\cdots&amp;a_{MM}\end{bmatrix}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:5.46em;vertical-align:-2.48em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.95em;"><span style="top:-4.95em;"><span class="pstrut" style="height:7.4em;"></span><span style="width:0.667em;height:5.400em;"><svg xmlns="http://www.w3.org/2000/svg" width='0.667em' height='5.400em' viewBox='0 0 667 5400'><path d='M403 1759 V84 H666 V0 H319 V1759 v1800 v1759 h347 v-84H403z M403 1759 V0 H319 V1759 v1800 v1759 h84z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.45em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.98em;"><span style="top:-5.8275em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">11</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-4.6275em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">21</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-2.7675em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"><span class="mord">⋮</span><span class="mord rule" style="border-right-width:0em;border-top-width:1.5em;bottom:0em;"></span></span></span></span><span style="top:-1.5675em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">M</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.48em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.98em;"><span style="top:-5.8275em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">12</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-4.6275em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">22</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-2.7675em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"><span class="mord">⋮</span><span class="mord rule" style="border-right-width:0em;border-top-width:1.5em;bottom:0em;"></span></span></span></span><span style="top:-1.5675em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">M</span><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.48em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.98em;"><span style="top:-5.64em;"><span class="pstrut" style="height:3.5em;"></span><span class="mord"><span class="minner">⋯</span></span></span><span style="top:-4.44em;"><span class="pstrut" style="height:3.5em;"></span><span class="mord"><span class="minner">⋯</span></span></span><span style="top:-2.58em;"><span class="pstrut" style="height:3.5em;"></span><span class="mord"><span class="minner">⋱</span></span></span><span style="top:-1.38em;"><span class="pstrut" style="height:3.5em;"></span><span class="mord"><span class="minner">⋯</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.48em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.98em;"><span style="top:-5.8275em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mathnormal mtight" style="margin-right:0.10903em;">M</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-4.6275em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mathnormal mtight" style="margin-right:0.10903em;">M</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-2.7675em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"><span class="mord">⋮</span><span class="mord rule" style="border-right-width:0em;border-top-width:1.5em;bottom:0em;"></span></span></span></span><span style="top:-1.5675em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">MM</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.48em;"><span></span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.95em;"><span style="top:-4.95em;"><span class="pstrut" style="height:7.4em;"></span><span style="width:0.667em;height:5.400em;"><svg xmlns="http://www.w3.org/2000/svg" width='0.667em' height='5.400em' viewBox='0 0 667 5400'><path d='M347 1759 V0 H0 V84 H263 V1759 v1800 v1759 H0 v84 H347zM347 1759 V0 H263 V1759 v1800 v1759 h84z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.45em;"><span></span></span></span></span></span></span></span></span></span></span></span></p><h4 id="一阶Markov模型输出状态序列的概率">一阶<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mi>a</mi><mi>r</mi><mi>k</mi><mi>o</mi><mi>v</mi></mrow><annotation encoding="application/x-tex">Markov</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span></span></span></span>模型输出状态序列的概率</h4><ul><li>给定参数<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>θ</mi><mo>=</mo><mo stretchy="false">(</mo><mi>π</mi><mo separator="true">,</mo><mi>A</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\theta=(\pi,A)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">A</span><span class="mclose">)</span></span></span></span>,可以很容易地计算一阶<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mi>a</mi><mi>r</mi><mi>k</mi><mi>o</mi><mi>v</mi></mrow><annotation encoding="application/x-tex">Markov</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span></span></span></span>模型输出特定状态转移序列的概率</li><li>模型输出状态序列的概率可以由初始状态概率与各次状态<br>转移概率相乘得到</li><li>例如，模型输出序列 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>𝑊</mi><mn>5</mn></msup><mo>=</mo><msub><mi>𝑤</mi><mn>1</mn></msub><msub><mi>𝑤</mi><mn>1</mn></msub><msub><mi>𝑤</mi><mn>3</mn></msub><msub><mi>𝑤</mi><mn>1</mn></msub><msub><mi>𝑤</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">𝑊^5 = 𝑤_1𝑤_1𝑤_3𝑤_1𝑤_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的概率：</li></ul><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>𝑃</mi><mo stretchy="false">(</mo><msup><mi>𝑊</mi><mn>5</mn></msup><mo stretchy="false">)</mo><mo>=</mo><msub><mtext>𝜋</mtext><mn>1</mn></msub><msub><mi>𝑎</mi><mn>11</mn></msub><msub><mi>𝑎</mi><mn>13</mn></msub><msub><mi>𝑎</mi><mn>31</mn></msub><msub><mi>𝑎</mi><mn>12</mn></msub></mrow><annotation encoding="application/x-tex">𝑃(𝑊^5) = 𝜋_1𝑎_{11}𝑎_{13}𝑎_{31}𝑎_{12}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1141em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord">𝜋</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">11</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">13</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">31</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">12</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></p><h4 id="一阶Markov模型在时刻t的状态概率𝑃-w-t-𝑤-𝑖">一阶<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mi>a</mi><mi>r</mi><mi>k</mi><mi>o</mi><mi>v</mi></mrow><annotation encoding="application/x-tex">Markov</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span></span></span></span>模型在时刻<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6151em;"></span><span class="mord mathnormal">t</span></span></span></span>的状态概率<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝑃</mi><mo stretchy="false">(</mo><mi>w</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mo>=</mo><msub><mi>𝑤</mi><mi>𝑖</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">𝑃(w(t)=𝑤_𝑖)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></h4><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>w</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mo>=</mo><msub><mi>w</mi><mi>i</mi></msub><mo stretchy="false">)</mo><mo>=</mo><munderover><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><mi>N</mi></munderover><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>w</mi><mo stretchy="false">(</mo><mi>t</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>=</mo><msub><mi>w</mi><mi>j</mi></msub><mo stretchy="false">)</mo><msub><mi>a</mi><mrow><mi>j</mi><mi>i</mi></mrow></msub></mrow></mrow><annotation encoding="application/x-tex">P(w(t)=w_i)=\sum\limits^N_{j=1}{P(w(t-1)=w_j)a_{ji}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:3.2421em;vertical-align:-1.4138em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8283em;"><span style="top:-1.8723em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.4138em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">ji</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span></span></span></p><h3 id="HMM：Hidden-Markov-Model">HMM：Hidden Markov Model</h3><ul><li>HMM 包含一个一阶 Markov 模型，但模型的状态以及状态<br>转移过程是隐含的，不可见的</li><li>HMM 在时刻<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6151em;"></span><span class="mord mathnormal">t</span></span></span></span>由隐状态 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">w(t)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mclose">)</span></span></span></span> 输出观察值 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mo>∈</mo><mo stretchy="false">{</mo><msub><mi>𝑣</mi><mn>1</mn></msub><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><msub><mi>𝑣</mi><mi>K</mi></msub><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">w(t)∈ \{𝑣_1,\dots, 𝑣_K\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.07153em;">K</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">}</span></span></span></span></li><li>经过 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝑇</mi></mrow><annotation encoding="application/x-tex">𝑇</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span></span> 个时刻之后，可以观察到 HMM 输出一个观察序列：</li></ul><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msup><mi>𝑉</mi><mi>T</mi></msup><mo>=</mo><mi>𝑣</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo><mi>𝑣</mi><mo stretchy="false">(</mo><mn>2</mn><mo stretchy="false">)</mo><mo>…</mo><mi>𝑣</mi><mo stretchy="false">(</mo><mi>𝑇</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">𝑉^T = 𝑣(1)𝑣(2)\dots𝑣(𝑇)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8913em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mopen">(</span><span class="mord">2</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mclose">)</span></span></span></span></span></p><h4 id="三个假设">三个假设</h4><ul><li>对于一个随机事件，有一个观察值序列：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>𝑣</mi><mn>1</mn></msub><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><msub><mi>𝑣</mi><mi>T</mi></msub></mrow><annotation encoding="application/x-tex">𝑣_1,\dots, 𝑣_T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></li><li>该事件隐含着一个状态序列<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>𝑤</mi><mn>1</mn></msub><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><msub><mi>𝑤</mi><mi>T</mi></msub></mrow><annotation encoding="application/x-tex">𝑤_1,\dots,𝑤_T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></li><li>假设1：马尔可夫假设（状态构成一阶马尔可夫链）</li></ul><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>𝑃</mi><mi>𝑃</mi><mo stretchy="false">(</mo><msub><mi>𝑤</mi><mi>𝑖</mi></msub><mi mathvariant="normal">∣</mi><msub><mi>𝑤</mi><mrow><mi>𝑖</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>…</mo><msub><mi>𝑤</mi><mn>1</mn></msub><mo stretchy="false">)</mo><mo>=</mo><mi>𝑃</mi><mo stretchy="false">(</mo><msub><mi>𝑤</mi><mi>𝑖</mi></msub><mi mathvariant="normal">∣</mi><msub><mi>𝑤</mi><mrow><mi>𝑖</mi><mo>−</mo><mn>1</mn></mrow></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">𝑃𝑃(𝑤_𝑖|𝑤_{𝑖−1}\dots 𝑤_1) = 𝑃(𝑤_𝑖|𝑤_{𝑖−1})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">PP</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">∣</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">∣</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span></p><ul><li>假设2：不动性假设（状态转移概率与具体时间无关）</li><li>假设3：输出独立性假设（输出仅与当前状态有关）</li></ul><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>𝑃</mi><mo stretchy="false">(</mo><msub><mi>𝑣</mi><mn>1</mn></msub><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><msub><mi>𝑣</mi><mi>𝑇</mi></msub><mi mathvariant="normal">∣</mi><msub><mi>𝑤</mi><mn>1</mn></msub><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><msub><mi>𝑤</mi><mi>𝑇</mi></msub><mo stretchy="false">)</mo><mo>=</mo><munderover><mo>∏</mo><mrow><mi>t</mi><mo>=</mo><mn>1</mn></mrow><mi>T</mi></munderover><mi>P</mi><mo stretchy="false">(</mo><msub><mi>𝑣</mi><mi>𝑡</mi></msub><mi mathvariant="normal">∣</mi><msub><mi>𝑤</mi><mi>𝑡</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">𝑃(𝑣_1,\dots,𝑣_𝑇|𝑤_1,\dots, 𝑤_𝑇)=\prod\limits_{t=1}^TP(𝑣_𝑡|𝑤_𝑡)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">∣</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:3.0954em;vertical-align:-1.2671em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8283em;"><span style="top:-1.8829em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∏</span></span></span><span style="top:-4.3em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.2671em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">∣</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span></p><h4 id="模型参数-theta-pi-A-B">模型参数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>θ</mi><mo>=</mo><mo stretchy="false">(</mo><mi>π</mi><mo separator="true">,</mo><mi>A</mi><mo separator="true">,</mo><mi>B</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\theta=(\pi,A,B)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">A</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mclose">)</span></span></span></span></h4><ul><li>初始状态概率：𝜋𝜋，𝑀𝑀 维矢量</li></ul><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>π</mi><mo>=</mo><mo stretchy="false">(</mo><msub><mi>π</mi><mn>1</mn></msub><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><msub><mi>π</mi><mi>M</mi></msub><msup><mo stretchy="false">)</mo><mi>t</mi></msup></mrow><annotation encoding="application/x-tex">\pi=(\pi_1,\dots,\pi_M)^t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0936em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">M</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8436em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span></span></span></span></span></span></span></span></span></p><ul><li>状态转移概率矩阵：𝐴𝐴，𝑀𝑀 ×𝑀𝑀 维矩阵<br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>=</mo><mo stretchy="false">(</mo><msub><mi>a</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub><msub><mo stretchy="false">)</mo><mrow><mi>M</mi><mi>x</mi><mi>M</mi></mrow></msub></mrow><annotation encoding="application/x-tex">A=(a_{ij})_{MxM}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">ij</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">M</span><span class="mord mathnormal mtight">x</span><span class="mord mathnormal mtight" style="margin-right:0.10903em;">M</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub><mo>=</mo><mi>P</mi><mo stretchy="false">(</mo><mi>w</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mo>=</mo><msub><mi>w</mi><mi>j</mi></msub><mi mathvariant="normal">∣</mi><mi>w</mi><mo stretchy="false">(</mo><mi>t</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>=</mo><msub><mi>w</mi><mi>i</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">a_{ij}=P(w(t)=w_j|w(t-1)=w_i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7167em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">ij</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></li><li>输出概率矩阵：𝐵𝐵，𝑀𝑀 × 𝐾𝐾 维矩阵<ul><li>M为状态数，K为观测值数</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span>的元素 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>𝑏</mi><mrow><mi>𝑖</mi><mi>𝑘</mi></mrow></msub></mrow><annotation encoding="application/x-tex">𝑏_{𝑖𝑘}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">ik</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 表示状态 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>𝑤</mi><mi>𝑖</mi></msub></mrow><annotation encoding="application/x-tex">𝑤_𝑖</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 输出观察值 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>𝑣</mi><mi>𝑘</mi></msub></mrow><annotation encoding="application/x-tex">𝑣_𝑘</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 的概率，与时刻 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝑡</mi></mrow><annotation encoding="application/x-tex">𝑡</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6151em;"></span><span class="mord mathnormal">t</span></span></span></span> 无关<br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi><mo>=</mo><mo stretchy="false">(</mo><msub><mi>b</mi><mrow><mi>i</mi><mi>k</mi></mrow></msub><mrow><mi>M</mi><mi>x</mi><mi>K</mi></mrow><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">B=(b_{ik}{MxK})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">ik</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mord mathnormal">x</span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span></span><span class="mclose">)</span></span></span></span><br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>b</mi><mrow><mi>i</mi><mi>k</mi></mrow></msub><mo>=</mo><mi>P</mi><mo stretchy="false">(</mo><mi>v</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mo>=</mo><msub><mi>v</mi><mi>k</mi></msub><mi mathvariant="normal">∣</mi><mi>w</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mo>=</mo><msub><mi>w</mi><mi>i</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">b_{ik}=P(v(t)=v_k|w(t)=w_i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">ik</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity-四元数</title>
      <link href="/post/f9b28ede.html"/>
      <url>/post/f9b28ede.html</url>
      
        <content type="html"><![CDATA[<h2 id="为什么使用四元数">为什么使用四元数</h2><ul><li>欧拉角的缺点<ul><li>同一旋转的表示不唯一</li><li>万向节死锁(Gimbal Lock)<ul><li><p>当某个特定轴到达某个特殊值时，绕一个轴旋转可能会覆盖住另一个轴的旋转，从而失去一维自由度<br><img src="..\img\Unity\GimbalLock.png" width="50%" height="50%"></p></li><li><p>最外层和最内层的旋转轴重合</p></li><li><p>例如 Unity中X轴达到90度时就会发生</p></li></ul></li></ul></li><li>四元数不存在万向节死锁的问题</li></ul><h2 id="四元数是什么">四元数是什么</h2><h3 id="定义">定义</h3><ul><li>形如 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>i</mi><mo>+</mo><mi>b</mi><mi>j</mi><mo>+</mo><mi>c</mi><mi>k</mi><mo>+</mo><mi>d</mi></mrow><annotation encoding="application/x-tex">ai+bj+ck+d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7429em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">ai</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">bj</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">c</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">d</span></span></span></span>的数字，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo separator="true">,</mo><mi>c</mi><mo separator="true">,</mo><mi>d</mi></mrow><annotation encoding="application/x-tex">a,b,c,d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">b</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">c</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">d</span></span></span></span>是实数<ul><li>可以看作一个四元数包含了一个标量和一个3D向量</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>w</mi><mo separator="true">,</mo><mi>v</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[w,v]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">]</span></span></span></span>,<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi></mrow><annotation encoding="application/x-tex">w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span></span></span></span>为标量，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span></span></span></span>为3D向量</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>w</mi><mo separator="true">,</mo><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo separator="true">,</mo><mi>z</mi><mo stretchy="false">)</mo><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[w,(x,y,z)]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="mclose">)]</span></span></span></span></li></ul></li><li>对于给定的任意一个四元数：表示3D空间的一个旋转量</li></ul><h3 id="轴-角对">轴-角对</h3><ul><li>在3D空间中，任意旋转都可以表示绕着某个轴旋转一个旋转角得到(该轴是任意一个轴，不一定是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo separator="true">,</mo><mi>z</mi></mrow><annotation encoding="application/x-tex">x,y,z</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span></span></span></span>轴)</li></ul><h3 id="四元数旋转">四元数旋转</h3><ul><li>对于给定旋转，假设绕着<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span>轴，旋转<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>β</mi></mrow><annotation encoding="application/x-tex">\beta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span></span></span></span>度，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span>轴为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo separator="true">,</mo><mi>z</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(x,y,z)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="mclose">)</span></span></span></span>，那么可以构成四元数为<ul><li>四元数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>q</mi><mo>=</mo><mo stretchy="false">[</mo><mi>c</mi><mi>o</mi><mi>s</mi><mo stretchy="false">(</mo><mi>β</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>s</mi><mi>i</mi><mi>n</mi><mo stretchy="false">(</mo><mi>β</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo stretchy="false">)</mo><mi>n</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">q = [cos(\beta/2),sin(\beta/2)n]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal">cos</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span><span class="mord">/2</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">in</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span><span class="mord">/2</span><span class="mclose">)</span><span class="mord mathnormal">n</span><span class="mclose">]</span></span></span></span></li><li>四元数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>q</mi><mo>=</mo><mo stretchy="false">[</mo><mi>c</mi><mi>o</mi><mi>s</mi><mo stretchy="false">(</mo><mi>β</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>s</mi><mi>i</mi><mi>n</mi><mo stretchy="false">(</mo><mi>β</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo stretchy="false">)</mo><mi>x</mi><mo separator="true">,</mo><mi>s</mi><mi>i</mi><mi>n</mi><mo stretchy="false">(</mo><mi>β</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo stretchy="false">)</mo><mi>y</mi><mo separator="true">,</mo><mi>s</mi><mi>i</mi><mi>n</mi><mo stretchy="false">(</mo><mi>β</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo stretchy="false">)</mo><mi>z</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">q = [cos(\beta/2),sin(\beta/2)x,sin(\beta/2)y,sin(\beta/2)z]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal">cos</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span><span class="mord">/2</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">in</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span><span class="mord">/2</span><span class="mclose">)</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">in</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span><span class="mord">/2</span><span class="mclose">)</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">in</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span><span class="mord">/2</span><span class="mclose">)</span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="mclose">]</span></span></span></span><br><font color=red>这里一定为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>β</mi><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">\beta/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span><span class="mord">/2</span></span></span></span></font></li></ul></li><li>四元数q表示绕着轴<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span>，旋转<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>β</mi></mrow><annotation encoding="application/x-tex">\beta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span></span></span></span>度的旋转量</li></ul><h2 id="Unity中的四元数">Unity中的四元数</h2><p><font color=green><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Q</mi><mi>u</mi><mi>a</mi><mi>t</mi><mi>e</mi><mi>r</mi><mi>n</mi><mi>i</mi><mi>o</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">Quaternion</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">Q</span><span class="mord mathnormal">u</span><span class="mord mathnormal">a</span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.02778em;">er</span><span class="mord mathnormal">ni</span><span class="mord mathnormal">o</span><span class="mord mathnormal">n</span></span></span></span></font>是Unity中表示四元数的结构体</p><h3 id="初始化">初始化</h3><p>轴角对公式初始化</p><ul><li>方法一 (为计算原理，不用)<br>四元数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>q</mi><mo>=</mo><mo stretchy="false">[</mo><mi>c</mi><mi>o</mi><mi>s</mi><mo stretchy="false">(</mo><mi>β</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>s</mi><mi>i</mi><mi>n</mi><mo stretchy="false">(</mo><mi>β</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo stretchy="false">)</mo><mi>x</mi><mo separator="true">,</mo><mi>s</mi><mi>i</mi><mi>n</mi><mo stretchy="false">(</mo><mi>β</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo stretchy="false">)</mo><mi>y</mi><mo separator="true">,</mo><mi>s</mi><mi>i</mi><mi>n</mi><mo stretchy="false">(</mo><mi>β</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo stretchy="false">)</mo><mi>z</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">q = [cos(\beta/2),sin(\beta/2)x,sin(\beta/2)y,sin(\beta/2)z]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal">cos</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span><span class="mord">/2</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">in</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span><span class="mord">/2</span><span class="mclose">)</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">in</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span><span class="mord">/2</span><span class="mclose">)</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">in</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span><span class="mord">/2</span><span class="mclose">)</span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="mclose">]</span></span></span></span></li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//假设绕(1,0,0)旋转60度</span></span><br><span class="line">Quaternino q = <span class="keyword">new</span> Quaternino(Mathf.Sin(<span class="number">30</span> * Mathf.Deg2Rad), <span class="number">0</span>, <span class="number">0</span>, Mathf.Cos(<span class="number">30</span> * Mathf.Deg2Rad));</span><br></pre></td></tr></table></figure><ul><li>方法二 (封装的方法)</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//假设绕(1,0,0)旋转60度</span></span><br><span class="line">Quaternino q = Quaternino.AngleAxis(<span class="number">60</span>, Vector3.right);</span><br></pre></td></tr></table></figure><h3 id="四元数和欧拉角转换">四元数和欧拉角转换</h3><ul><li>欧拉角转四元数 (静态方法)</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Quaternino q = Quaternino.Euler(<span class="number">60</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><ul><li>四元数转欧拉角 (成员属性)</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(q.eulerAngles)</span><br></pre></td></tr></table></figure><h3 id="四元数弥补欧拉角缺点">四元数弥补欧拉角缺点</h3><p><font color=red>四元数相乘代表旋转四元数</font></p><ul><li><p>解决同一旋转的表示不唯一<br>四元数旋转角度始终在<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mo>−</mo><mn>18</mn><msup><mn>0</mn><mi>o</mi></msup><mo>∼</mo><mn>18</mn><msup><mn>0</mn><mi>o</mi></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(-180^o\sim180^o)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">−</span><span class="mord">18</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">o</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">18</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">o</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>之间</p></li><li><p>解决万向节死锁(Gimbal Lock)<br>在万向节死锁时仍然可以通过四元数乘法来使物体绕自己指定的轴旋转</p></li><li><p>tips:以下代码在界面上rotation = (90,0,0)的前提下演示，此时万向节已经死锁</p></li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 提示：这里的Vector3.up代表的是本地坐标系的y轴,不是世界坐标系的</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>.transform.rotation *= Quatenion.AngleAxis(<span class="number">1</span>, Vector3.up);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对比欧拉角，这个会出现万向节死锁</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Vector3 e;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    e = <span class="keyword">this</span>.transform.rotation.eulerAngles;</span><br><span class="line">    e += Vector3.up;</span><br><span class="line">    <span class="keyword">this</span>.transform.rotation = Quatenion.Euler(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="四元数的常用方法">四元数的常用方法</h3><h4 id="单位四元数-用于初始化对象">单位四元数 用于初始化对象</h4><p><font color=green>Quatenion.identity</font></p><ul><li>当角度为0或者360度时</li><li>单位四元数表示没有旋转量</li><li>对于任何给定轴都有单位四元数</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>1</mn><mo separator="true">,</mo><mo stretchy="false">(</mo><mn>0</mn><mo separator="true">,</mo><mn>0</mn><mo separator="true">,</mo><mn>0</mn><mo stretchy="false">)</mo><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[1,(0,0,0)]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mopen">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">0</span><span class="mclose">)]</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mo stretchy="false">(</mo><mn>0</mn><mo separator="true">,</mo><mn>0</mn><mo separator="true">,</mo><mn>0</mn><mo stretchy="false">)</mo><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[-1,(0,0,0)]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">−</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mopen">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">0</span><span class="mclose">)]</span></span></span></span>都是单位四元数表示没有旋转量</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">print(Quatenion.identity);</span><br><span class="line"><span class="comment">//实例化时使用</span></span><br><span class="line">Instantiate(testObj, Vector3.zero, Quaternion.identity);</span><br></pre></td></tr></table></figure><h4 id="四元数插值运算">四元数插值运算</h4><p><font color=green>Quaternion.Slerp()</font></p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mi>e</mi><mi>s</mi><mi>u</mi><mi>l</mi><mi>t</mi><mo>=</mo><mi>s</mi><mi>t</mi><mi>a</mi><mi>r</mi><mi>t</mi><mo>+</mo><mo stretchy="false">(</mo><mi>e</mi><mi>n</mi><mi>d</mi><mo>−</mo><mi>s</mi><mi>t</mi><mi>a</mi><mi>r</mi><mi>t</mi><mo stretchy="false">)</mo><mo>∗</mo><mi>t</mi></mrow><annotation encoding="application/x-tex">result = start + (end-start) * t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">res</span><span class="mord mathnormal">u</span><span class="mord mathnormal">lt</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6984em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">t</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">e</span><span class="mord mathnormal">n</span><span class="mord mathnormal">d</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">t</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">t</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6151em;"></span><span class="mord mathnormal">t</span></span></span></span></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Quaternion.Slerp(start, end, t);</span><br></pre></td></tr></table></figure><ul><li>四元数同样提供如同Vector3的插值运算<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mi>e</mi><mi>r</mi><mi>p</mi></mrow><annotation encoding="application/x-tex">Lerp</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">L</span><span class="mord mathnormal" style="margin-right:0.02778em;">er</span><span class="mord mathnormal">p</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mi>l</mi><mi>e</mi><mi>r</mi><mi>p</mi></mrow><annotation encoding="application/x-tex">Slerp</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">Sl</span><span class="mord mathnormal" style="margin-right:0.02778em;">er</span><span class="mord mathnormal">p</span></span></span></span></li><li>二者区别不大,<font color=red><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mi>l</mi><mi>e</mi><mi>r</mi><mi>p</mi></mrow><annotation encoding="application/x-tex">Slerp</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">Sl</span><span class="mord mathnormal" style="margin-right:0.02778em;">er</span><span class="mord mathnormal">p</span></span></span></span>效果好一些，建议使用</font></li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//1. 无限接近 先快后慢</span></span><br><span class="line">    A.transform.rotation = Quaternion.Slerp(A.transform.rotation, target.rotation, Time.deltaTime);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2. 匀速变化 time&gt;=1到达目标</span></span><br><span class="line">    <span class="comment">//这种匀速移动 当time&gt;=1时 当目标位置改变后 他会直接瞬间变到目标的角度 所以加入以下判断</span></span><br><span class="line">    <span class="keyword">if</span>(nowTarget != target.rotation)</span><br><span class="line">    &#123;</span><br><span class="line">        nowTarget = target.rotation;</span><br><span class="line">        time = <span class="number">0</span>;</span><br><span class="line">        start = B.rotation;</span><br><span class="line">    &#125;</span><br><span class="line">    time += Time.deltaTime;</span><br><span class="line">    B.trainsform.rotation = Quaternion.Slerp(start, nowTarget, time);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="向量指向转四元数">向量指向转四元数</h4><p><font color=green>Quaternino.LookRotation(面朝向量)</font></p><ul><li><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mi>o</mi><mi>o</mi><mi>k</mi><mi>R</mi><mi>o</mi><mi>t</mi><mi>a</mi><mi>t</mi><mi>i</mi><mi>o</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">LookRotation</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">L</span><span class="mord mathnormal">oo</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mord mathnormal">o</span><span class="mord mathnormal">t</span><span class="mord mathnormal">a</span><span class="mord mathnormal">t</span><span class="mord mathnormal">i</span><span class="mord mathnormal">o</span><span class="mord mathnormal">n</span></span></span></span>方法将传入的面朝向量转换为对应的四元数角度信息<br><img src="..\img\Unity\LookRotation演示.png" width="30%" height="30%"></p></li><li><p>举例：当<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span>面朝向想改变时，只需要把<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span>之间的向量<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mrow><mi>A</mi><mi>B</mi></mrow><mo stretchy="true">→</mo></mover></mrow><annotation encoding="application/x-tex">\overrightarrow{AB}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2053em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.2053em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span><span class="svg-align" style="top:-3.6833em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="height:0.522em;min-width:0.888em;"><svg xmlns="http://www.w3.org/2000/svg" width='400em' height='0.522em' viewBox='0 0 400000 522' preserveAspectRatio='xMaxYMin slice'><path d='M0 241v40h399891c-47.3 35.3-84 78-110 128-16.7 32-27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20 11 8 0 13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7 39-84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85-40.5-119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5-12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67 151.7 139 205zm0 0v40h399900v-40z'/></svg></span></span></span></span></span></span></span></span></span>传入该函数，便可以得到目标四元数角度信息，之后将<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span>四元数角度信息改为得到的信息即可转向</p></li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Quaternion q = Quaternion.LookRotation(B.position - A.position);</span><br><span class="line">A.rotation = q;</span><br></pre></td></tr></table></figure><h3 id="四元数计算">四元数计算</h3><h4 id="四元数相乘">四元数相乘</h4><ul><li>两个四元数相乘得到一个<font color=red>新的四元数</font>，代表两个旋转量的叠加</li><li>相当于旋转</li><li><font color=red>注意：旋转相对的坐标系 是物体自身坐标系</font></li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Quaternion q = Quaternion.AngleAxis(<span class="number">20</span>, Vector3.up);</span><br><span class="line"><span class="keyword">this</span>.transform.rotation *= q;</span><br></pre></td></tr></table></figure><h4 id="四元数乘向量">四元数乘向量</h4><ul><li>四元数乘向量<font color=red>返回一个新向量</font></li><li>可以将指定向量旋转对应四元数的旋转量，相当于旋转向量</li><li><font color=red>注意：一定是四元数乘向量 先后顺序不能改变</font></li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Vector3 v = Vector3.forward;</span><br><span class="line">v = Quaternion.AngleAxis(<span class="number">45</span>, Vector3.up) * v;</span><br></pre></td></tr></table></figure><ul><li>实例：比如做弹幕类游戏，现有一个弹幕的方向，则可通过乘四元数旋转得到一圈弹幕的方向</li></ul>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>工具网站</title>
      <link href="/post/92edcf8f.html"/>
      <url>/post/92edcf8f.html</url>
      
        <content type="html"><![CDATA[<h2 id="语法工具">语法工具</h2><h3 id="Markdown语法"><a href="https://wuwufq.blog.csdn.net/article/details/127898890?spm=1001.2101.3001.6661.1&amp;utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-127898890-blog-124603661.pc_relevant_3mothn_strategy_and_data_recovery&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-127898890-blog-124603661.pc_relevant_3mothn_strategy_and_data_recovery&amp;utm_relevant_index=1">Markdown语法</a></h3><h3 id="Latex语法"><a href="https://www.luogu.com.cn/blog/IowaBattleship/latex-gong-shi-tai-quan">Latex语法</a></h3><h2 id="功能性工具">功能性工具</h2><h3 id="在线OCR"><a href="https://uutool.cn/ocr/">在线OCR</a></h3><h3 id="ppt转pdf"><a href="https://tools.pdf24.org/zh/ppt-to-pdf#s=1697960230853">ppt转pdf</a></h3><h3 id="在线音频剪辑"><a href="https://100audio.com/sound/100audio_editor/">在线音频剪辑</a></h3><h2 id="数学工具">数学工具</h2><h3 id="建系工具"><a href="https://www.desmos.com/calculator?lang=zh-CN">建系工具</a></h3><h2 id="美化工具">美化工具</h2><h3 id="文档语法高亮"><a href="http://word.wd1x.com/">文档语法高亮</a></h3><h3 id="代码格式化截图"><a href="https://www.wetools.com/code-snapshot">代码格式化截图</a></h3><h2 id="图片素材">图片素材</h2><h3 id="阿里巴巴矢量图库"><a href="https://www.iconfont.cn/">阿里巴巴矢量图库</a></h3><h3 id="花瓣网"><a href="https://huaban.com/materials">花瓣网</a></h3><h3 id="摄影素材"><a href="https://unsplash.com/">摄影素材</a></h3><h2 id="博客工具">博客工具</h2><h3 id="Butterfly文档"><a href="https://butterfly.js.org/">Butterfly文档</a></h3><h3 id="Butterfly重装日记"><a href="https://blog.anheyu.com/posts/sdxhu.html">Butterfly重装日记</a></h3><h3 id="图床"><a href="https://smms.app/">图床</a></h3>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GMM高斯混合模型</title>
      <link href="/post/6d95358d.html"/>
      <url>/post/6d95358d.html</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h2 id="GMM高斯混合模型原理">GMM高斯混合模型原理</h2><h3 id="混合密度模型">混合密度模型</h3><p>复杂的概率密度函数可以由简单密度函数线性组合构成</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>p</mi><mo stretchy="false">(</mo><mi>x</mi><mi mathvariant="normal">∣</mi><mi>θ</mi><mo stretchy="false">)</mo><mo>=</mo><mrow><munderover><mo>∑</mo><mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow><mi>M</mi></munderover><msub><mi>a</mi><mi>k</mi></msub><msub><mi>p</mi><mi>k</mi></msub><mo stretchy="false">(</mo><mi>x</mi><mi mathvariant="normal">∣</mi><msub><mi>θ</mi><mi>k</mi></msub><mo stretchy="false">)</mo></mrow><mo separator="true">,</mo><mspace width="1em"/><msub><mi>a</mi><mi>k</mi></msub><mo>&gt;</mo><mn>0</mn><mo separator="true">,</mo><mspace width="1em"/><munderover><mo>∑</mo><mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow><mi>M</mi></munderover><msub><mi>a</mi><mi>k</mi></msub><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">p(x|\theta) = {\sum\limits_{k=1}^{M} a_{k}p_{k}(x|\theta_k)},\quad a_{k}&gt;0,\quad \sum\limits_{k=1}^{M} a_{k}=1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">p</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:3.1304em;vertical-align:-1.3021em;"></span><span class="mord"><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8283em;"><span style="top:-1.8479em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">M</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.3021em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mord">∣</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:1em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:3.1304em;vertical-align:-1.3021em;"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:1em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8283em;"><span style="top:-1.8479em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">M</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.3021em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span></span></p><p>GMM 是混合密度模型的一个特例，由多个高斯（正态分布）函数的组合构成</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>p</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><munderover><mo>∑</mo><mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow><mi>M</mi></munderover><msub><mi>a</mi><mi>k</mi></msub><mi>N</mi><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">;</mo><msub><mi>μ</mi><mi>k</mi></msub><mo separator="true">,</mo><msub><mi mathvariant="normal">Σ</mi><mi>k</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">p(x) = \sum\limits_{k=1}^{M} a_{k}N(x;\mu_k,\Sigma_k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">p</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:3.1304em;vertical-align:-1.3021em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8283em;"><span style="top:-1.8479em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">M</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.3021em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">;</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">μ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord">Σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span></p><h4 id="以下3点对于理解GMM模型的预测很重要">以下3点对于理解GMM模型的预测很重要</h4><p><mark>！！！重点敲黑板！！！</mark></p><ul><li>这里的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">p(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">p</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span>是似然函数，完整表达应该是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo stretchy="false">(</mo><mi>x</mi><mi mathvariant="normal">∣</mi><msub><mi>ω</mi><mi>i</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">p(x|\omega_i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">p</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mord">∣</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，这里的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>ω</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">\omega_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>表示是第<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span>类数据，即训练GMM其实对每一类都单独学习一个GMM模型。</li><li>比如：在分类问题中，如10分类问题。<ul><li>首先学习到10个不同的GMM模型（即似然函数公式）；</li><li>通过预测样本带入似然函数公式，得到概率密度值；</li><li>再乘以不同类别的先验概率<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo stretchy="false">(</mo><msub><mi>ω</mi><mi>i</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">p(\omega_i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">p</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，得到10个对应预测样本的后验概率<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo stretchy="false">(</mo><msub><mi>ω</mi><mi>i</mi></msub><mi mathvariant="normal">∣</mi><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">p(\omega_i|x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">p</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">∣</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span>；</li><li>取这10个值里最大的所对应的类别作为这个样本的类别。</li></ul></li><li>这一切预测都是基于贝叶斯公式：</li></ul><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><msub><mi>ω</mi><mi>i</mi></msub><mi mathvariant="normal">∣</mi><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mfrac><mrow><mi>p</mi><mo stretchy="false">(</mo><mi>x</mi><mi mathvariant="normal">∣</mi><msub><mi>ω</mi><mi>i</mi></msub><mo stretchy="false">)</mo><mi>P</mi><mo stretchy="false">(</mo><msub><mi>ω</mi><mi>i</mi></msub><mo stretchy="false">)</mo></mrow><mrow><mi>p</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mfrac></mrow><annotation encoding="application/x-tex">P(\omega_i|x)={\dfrac{p(x|\omega_i)P(\omega_i)}{p(x)}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">∣</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.363em;vertical-align:-0.936em;"></span><span class="mord"><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.427em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mord">∣</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.936em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></span></p><h3 id="GMM的极大似然估计（参数估计）">GMM的极大似然估计（参数估计）</h3><p>GMM 需要估计的参数:</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>θ</mi><mo>=</mo><mo stretchy="false">(</mo><msub><mi>α</mi><mn>1</mn></msub><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><msub><mi>α</mi><mi>M</mi></msub><mo separator="true">,</mo><msub><mi>μ</mi><mn>1</mn></msub><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><msub><mi>μ</mi><mi>M</mi></msub><mo separator="true">,</mo><msub><mi mathvariant="normal">Σ</mi><mn>1</mn></msub><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><msub><mi mathvariant="normal">Σ</mi><mi>M</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\theta=(\alpha_1,\dots,\alpha_M,\mu_1,\dots,\mu_M,\Sigma_1,\dots,\Sigma_M)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0037em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0037em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">M</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">μ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">μ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">M</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord">Σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord">Σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">M</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span></p><p>对数似然函数:</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>l</mi><mo stretchy="false">(</mo><mi>θ</mi><mo stretchy="false">)</mo><mo>=</mo><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><mi>l</mi><mi>n</mi><mrow><mo fence="true">[</mo><munderover><mo>∑</mo><mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow><mi>M</mi></munderover><msub><mi>a</mi><mi>k</mi></msub><mi>N</mi><mo stretchy="false">(</mo><msub><mi>x</mi><mi>i</mi></msub><mo separator="true">;</mo><msub><mi>μ</mi><mi>k</mi></msub><mo separator="true">,</mo><msub><mi mathvariant="normal">Σ</mi><mi>k</mi></msub><mo stretchy="false">)</mo><mo fence="true">]</mo></mrow></mrow><annotation encoding="application/x-tex">l({\theta})=\sum\limits_{i=1}^nln\left[\sum\limits_{k=1}^M a_{k}N(x_i;\mu_k,\Sigma_k)\right]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:3.1304em;vertical-align:-1.3021em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6514em;"><span style="top:-1.8723em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.2777em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size4">[</span></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8283em;"><span style="top:-1.8479em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">M</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.3021em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">;</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">μ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord">Σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size4">]</span></span></span></span></span></span></span></p><ul><li>极值点方程是复杂的超越方程组，很难直接求解</li><li>常用的 GMM 参数估计方法是 EM 算法</li></ul><p>训练集和待学习参数</p><ul><li>训练数据集:  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>D</mi><mi>X</mi></msub><mo>=</mo><mo stretchy="false">{</mo><msub><mi>X</mi><mn>1</mn></msub><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><msub><mi>X</mi><mi>n</mi></msub><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">D_X = \{X_1,\dots,X_n\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.07847em;">X</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">}</span></span></span></span></li><li>学习参数: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>θ</mi><mo>=</mo><mo stretchy="false">{</mo><msub><mi>α</mi><mi>k</mi></msub><mo separator="true">,</mo><msub><mi>μ</mi><mi>k</mi></msub><mo separator="true">,</mo><msub><mi mathvariant="normal">Σ</mi><mi>k</mi></msub><msub><mo stretchy="false">}</mo><mrow><mi>k</mi><mo>=</mo><mn>1</mn><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><mi>M</mi></mrow></msub></mrow><annotation encoding="application/x-tex">\theta=\{\alpha_k,\mu_k,\Sigma_k\}_{k=1,\dots,M}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"></span><span class="mopen">{</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0037em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">μ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord">Σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose"><span class="mclose">}</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mrel mtight">=</span><span class="mord mtight">1</span><span class="mpunct mtight">,</span><span class="minner mtight">…</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.10903em;">M</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span></li></ul><p>存在的问题</p><ul><li>只有样本 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">x_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> ，但不知道是由哪一个成份高斯产生的</li><li>令 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>y</mi><mi>i</mi></msub><mo>=</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">y_i=k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span>表示 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">x_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>是由第<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span>个成份高斯产生，构造集合：</li></ul><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>D</mi><mi>Y</mi></msub><mo>=</mo><mo stretchy="false">{</mo><msub><mi>y</mi><mn>1</mn></msub><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><msub><mi>y</mi><mi>n</mi></msub><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">D_Y=\{y_1,\dots,y_n\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.22222em;">Y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">}</span></span></span></span></span></p><ul><li>完整的数据集 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi><mo>=</mo><msub><mi>D</mi><mi>X</mi></msub><mo>∪</mo><msub><mi>D</mi><mi>Y</mi></msub></mrow><annotation encoding="application/x-tex">D=D_X\cup D_Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.07847em;">X</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∪</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.22222em;">Y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>D</mi><mi>Y</mi></msub></mrow><annotation encoding="application/x-tex">D_Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.22222em;">Y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>为缺失的数据</li></ul><h2 id="EM算法">EM算法</h2><ul><li>理解要点<br><mark>！！！重点敲黑板！！！</mark><br>对于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>D</mi><mi>Y</mi></msub><mo>=</mo><mo stretchy="false">{</mo><msub><mi>y</mi><mn>1</mn></msub><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><msub><mi>y</mi><mi>n</mi></msub><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">D_Y=\{y_1,\dots,y_n\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.22222em;">Y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">}</span></span></span></span>,相对于武断的将每个训练样本确定为某个高斯产生的，更好的做法是计算每个样本由每个高斯产生的概率，后文的代码实现也是基于这一点的，其中<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mi>d</mi><mi>f</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">pdfs</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span><span class="mord mathnormal" style="margin-right:0.10764em;">df</span><span class="mord mathnormal">s</span></span></span></span>为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo>∗</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">m*k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4653em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span>维矩阵，每行为该样本由不同高斯产生的概率，共有m个样本。</li></ul><h3 id="E步（Expectation）">E步（Expectation）</h3><ul><li>隐变量的概率估计</li></ul><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable width="100%"><mtr><mtd width="50%"></mtd><mtd><mrow><mi>P</mi><mo stretchy="false">(</mo><msub><mi>y</mi><mi>i</mi></msub><mo>=</mo><mi>k</mi><mi mathvariant="normal">∣</mi><msub><mi>x</mi><mi>i</mi></msub><mo stretchy="false">)</mo><mo>=</mo><mfrac><mrow><mi>P</mi><mo stretchy="false">(</mo><msub><mi>y</mi><mi>i</mi></msub><mo>=</mo><mi>k</mi><mo stretchy="false">)</mo><mi>P</mi><mo stretchy="false">(</mo><msub><mi>x</mi><mi>i</mi></msub><mi mathvariant="normal">∣</mi><msub><mi>y</mi><mi>i</mi></msub><mo>=</mo><mi>k</mi><mo stretchy="false">)</mo></mrow><mrow><mi>P</mi><mo stretchy="false">(</mo><msub><mi>x</mi><mi>i</mi></msub><mo stretchy="false">)</mo></mrow></mfrac><mo>=</mo><mfrac><mrow><msub><mi>a</mi><mi>k</mi></msub><mi>N</mi><mo stretchy="false">(</mo><msub><mi>x</mi><mi>i</mi></msub><mo separator="true">;</mo><msub><mi>μ</mi><mi>k</mi></msub><mo separator="true">,</mo><msub><mi mathvariant="normal">Σ</mi><mi>k</mi></msub><mo stretchy="false">)</mo></mrow><mrow><munderover><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><mi>M</mi></munderover><msub><mi>a</mi><mi>j</mi></msub><mi>N</mi><mo stretchy="false">(</mo><msub><mi>x</mi><mi>i</mi></msub><mo separator="true">;</mo><msub><mi>μ</mi><mi>j</mi></msub><mo separator="true">,</mo><msub><mi mathvariant="normal">Σ</mi><mi>j</mi></msub><mo stretchy="false">)</mo></mrow></mfrac></mrow></mtd><mtd width="50%"></mtd><mtd><mtext>(1)</mtext></mtd></mtr></mtable><annotation encoding="application/x-tex">P(y_i=k|x_i)=\dfrac{P(y_i=k)P(x_i|y_i=k)}{P(x_i)}=\dfrac{a_{k}N(x_i;\mu_k,\Sigma_k)}{\sum\limits_{j=1}^M a_{j}N(x_i;\mu_j,\Sigma_j)} \tag{1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mord">∣</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.363em;vertical-align:-0.936em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.427em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">)</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">∣</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.936em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:3.9591em;vertical-align:-2.5321em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.427em;"><span style="top:-2.11em;"><span class="pstrut" style="height:3.5283em;"></span><span class="mord"><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.5283em;"><span style="top:-2.1223em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span><span class="mop op-symbol small-op">∑</span></span></span><span style="top:-3.95em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">M</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.1138em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">;</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">μ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord">Σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span><span style="top:-3.7583em;"><span class="pstrut" style="height:3.5283em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-4.2053em;"><span class="pstrut" style="height:3.5283em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">;</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">μ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord">Σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.5321em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span><span class="tag"><span class="strut" style="height:3.9591em;vertical-align:-2.5321em;"></span><span class="mord text"><span class="mord">(</span><span class="mord"><span class="mord">1</span></span><span class="mord">)</span></span></span></span></span></span></p><h3 id="M步（Maximize）">M步（Maximize）</h3><ul><li>每个高斯分布参数也需要由所有样本参与估计，同时需要</li><li>考虑样本由不同高斯产生的概率</li></ul><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable width="100%"><mtr><mtd width="50%"></mtd><mtd><mrow><msub><mover accent="true"><mi>a</mi><mo>^</mo></mover><mi>k</mi></msub><mo>=</mo><mfrac><mn>1</mn><mi>n</mi></mfrac><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><mi>P</mi><mo stretchy="false">(</mo><msub><mi>y</mi><mi>i</mi></msub><mo>=</mo><mi>k</mi><mo stretchy="false">)</mo></mrow></mtd><mtd width="50%"></mtd><mtd><mtext>(2)</mtext></mtd></mtr></mtable><annotation encoding="application/x-tex">\hat{a}_k=\dfrac{1}{n}\sum\limits_{i=1}^nP(y_i=k) \tag{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6944em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal">a</span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.25em;"><span class="mord">^</span></span></span></span></span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.9291em;vertical-align:-1.2777em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3214em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">n</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6514em;"><span style="top:-1.8723em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.2777em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span><span class="tag"><span class="strut" style="height:2.9291em;vertical-align:-1.2777em;"></span><span class="mord text"><span class="mord">(</span><span class="mord"><span class="mord">2</span></span><span class="mord">)</span></span></span></span></span></span></p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable width="100%"><mtr><mtd width="50%"></mtd><mtd><mrow><msub><mover accent="true"><mi>μ</mi><mo>^</mo></mover><mi>k</mi></msub><mo>=</mo><mfrac><mrow><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><mi>P</mi><mo stretchy="false">(</mo><msub><mi>y</mi><mi>i</mi></msub><mo>=</mo><mi>k</mi><mo stretchy="false">)</mo><msub><mi>x</mi><mi>i</mi></msub></mrow><mrow><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><mi>P</mi><mo stretchy="false">(</mo><msub><mi>y</mi><mi>i</mi></msub><mo>=</mo><mi>k</mi><mo stretchy="false">)</mo></mrow></mfrac></mrow></mtd><mtd width="50%"></mtd><mtd><mtext>(3)</mtext></mtd></mtr></mtable><annotation encoding="application/x-tex">\hat{\mu}_k=\dfrac{\sum\limits_{i=1}^nP(y_i=k)x_i}{\sum\limits_{i=1}^nP(y_i=k)} \tag{3}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6944em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal">μ</span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.2222em;"><span class="mord">^</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1944em;"><span></span></span></span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:4.9381em;vertical-align:-2.2191em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.7191em;"><span style="top:-2.11em;"><span class="pstrut" style="height:3.3514em;"></span><span class="mord"><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3514em;"><span style="top:-2.1223em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span><span class="mop op-symbol small-op">∑</span></span></span><span style="top:-3.95em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9777em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span><span style="top:-3.5814em;"><span class="pstrut" style="height:3.3514em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-4.7191em;"><span class="pstrut" style="height:3.3514em;"></span><span class="mord"><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3514em;"><span style="top:-2.1223em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span><span class="mop op-symbol small-op">∑</span></span></span><span style="top:-3.95em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9777em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">)</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.2191em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span><span class="tag"><span class="strut" style="height:4.9381em;vertical-align:-2.2191em;"></span><span class="mord text"><span class="mord">(</span><span class="mord"><span class="mord">3</span></span><span class="mord">)</span></span></span></span></span></span></p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable width="100%"><mtr><mtd width="50%"></mtd><mtd><mrow><msub><mover accent="true"><mi mathvariant="normal">Σ</mi><mo>^</mo></mover><mi>k</mi></msub><mo>=</mo><mfrac><mrow><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><mi>P</mi><mo stretchy="false">(</mo><msub><mi>y</mi><mi>i</mi></msub><mo>=</mo><mi>k</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><msub><mi>x</mi><mi>i</mi></msub><mo>−</mo><msub><mover accent="true"><mi>μ</mi><mo>^</mo></mover><mi>k</mi></msub><mo stretchy="false">)</mo><mo stretchy="false">(</mo><msub><mi>x</mi><mi>i</mi></msub><mo>−</mo><msub><mover accent="true"><mi>μ</mi><mo>^</mo></mover><mi>k</mi></msub><msup><mo stretchy="false">)</mo><mi>t</mi></msup></mrow><mrow><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><mi>P</mi><mo stretchy="false">(</mo><msub><mi>y</mi><mi>i</mi></msub><mo>=</mo><mi>k</mi><mo stretchy="false">)</mo></mrow></mfrac></mrow></mtd><mtd width="50%"></mtd><mtd><mtext>(4)</mtext></mtd></mtr></mtable><annotation encoding="application/x-tex">\hat{\Sigma}_k=\dfrac{\sum\limits_{i=1}^nP(y_i=k)(x_i-\hat{\mu}_k)(x_i-\hat{\mu}_k)^t}{\sum\limits_{i=1}^nP(y_i=k)} \tag{4}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0968em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9468em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord">Σ</span></span><span style="top:-3.2523em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.25em;"><span class="mord">^</span></span></span></span></span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:4.9381em;vertical-align:-2.2191em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.7191em;"><span style="top:-2.11em;"><span class="pstrut" style="height:3.3514em;"></span><span class="mord"><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3514em;"><span style="top:-2.1223em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span><span class="mop op-symbol small-op">∑</span></span></span><span style="top:-3.95em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9777em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span><span style="top:-3.5814em;"><span class="pstrut" style="height:3.3514em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-4.7191em;"><span class="pstrut" style="height:3.3514em;"></span><span class="mord"><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3514em;"><span style="top:-2.1223em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span><span class="mop op-symbol small-op">∑</span></span></span><span style="top:-3.95em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9777em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">)</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6944em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal">μ</span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.2222em;"><span class="mord">^</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1944em;"><span></span></span></span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6944em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal">μ</span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.2222em;"><span class="mord">^</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1944em;"><span></span></span></span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7936em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.2191em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span><span class="tag"><span class="strut" style="height:4.9381em;vertical-align:-2.2191em;"></span><span class="mord text"><span class="mord">(</span><span class="mord"><span class="mord">4</span></span><span class="mord">)</span></span></span></span></span></span></p><h2 id="算法">算法</h2><hr><p>Input: 训练集<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>D</mi><mi>X</mi></msub><mo>=</mo><mo stretchy="false">{</mo><msub><mi>X</mi><mn>1</mn></msub><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><msub><mi>X</mi><mi>n</mi></msub><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">D_X = \{X_1,\dots,X_n\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.07847em;">X</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">}</span></span></span></span>，高斯数<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span><br>Output: GMM的模型参数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>θ</mi></mrow><annotation encoding="application/x-tex">\theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span></span></span></span></p><ol><li>随机初始化<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>θ</mi></mrow><annotation encoding="application/x-tex">\theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span></span></span></span>;</li><li>repeat<br>E步：公式(1)估计样本由不同高斯产生的概率；<br>M步：公式(2-4)重新估计模型的参数<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>θ</mi></mrow><annotation encoding="application/x-tex">\theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span></span></span></span>；</li><li>until 达到收敛精度</li></ol><hr><p>类比KMeans算法：</p><ul><li>E步是在已知质心位置的条件下，把各点聚类到最近的质心；</li><li>M步是根据类内各点，调整质心位置。</li></ul><h2 id="实验及代码">实验及代码</h2><h3 id="实验内容">实验内容</h3><ol><li>使用Python编程实现GMM算法：要求独立完成算法编程，禁止调用已有函数库或工具箱中的函数；</li><li>使用仿真数据测试程序的正确性：<ol><li>两类2维各1000个训练样本；</li><li>每个类别的样本分别采样自包含2个分量的高斯混合模型，分别使用两个类别的训练样本学习模型化每个类别条件概率密度的GMM模型参数，并与模型的真实值比较；</li><li>假设两个类别的先验概率相等，使用学习到的模型参数分类测试样本数据，统计分类的正确率</li></ol></li><li>MNIST数据集测试：<ol><li>MNIST-Train-Samples.csv中包含30000个17维特征手写数字样本训练，MNIST-Train-Labels.csv中包含训练样本的标签；</li><li>分别使用每个数字的样本集学习该类别的GMM模型参数；</li><li>使用10个类别GMM模型构成的分类器，分类MNIST-Test-Samples.csv中的10000个样本，与MNIST-Test-Labels.csv的类别标记比对，计算识别的正确率；</li><li>尝试设置不同的GMM模型超参数—高斯数，测试不同高斯数的GMM分类器的识别正确率；</li></ol></li></ol><h3 id="程序代码">程序代码</h3><h4 id="导入库并制作工具函数">导入库并制作工具函数</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> matplotlib.patches <span class="keyword">import</span> Ellipse</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> warnings</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">import</span> copy</span><br><span class="line">warnings.filterwarnings(<span class="string">&quot;ignore&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制椭圆参考代码</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">plot_cov_ellipse</span>(<span class="params">cov, pos, nstd=<span class="number">2</span>, ax=<span class="literal">None</span></span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">eigsorted</span>(<span class="params">cov</span>):</span><br><span class="line">        vals, vecs = np.linalg.eigh(cov)</span><br><span class="line">        order = vals.argsort()[::-<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> vals[order], vecs[:, order]</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> ax <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        ax = plt.gca()</span><br><span class="line"> </span><br><span class="line">    vals, vecs = eigsorted(cov)</span><br><span class="line">    theta = np.degrees(np.arctan2(*vecs[:, <span class="number">0</span>][::-<span class="number">1</span>]))</span><br><span class="line"> </span><br><span class="line">    <span class="comment"># Width and height are &quot;full&quot; widths, not radius</span></span><br><span class="line">    width, height = <span class="number">2</span> * nstd * np.sqrt(vals)</span><br><span class="line">    ellip = Ellipse(xy=pos, width=width, height=height, facecolor=<span class="string">&#x27;#c8e0e4&#x27;</span>, angle=theta)</span><br><span class="line"> </span><br><span class="line">    ax.add_artist(ellip)</span><br><span class="line">    <span class="keyword">return</span> ellip</span><br><span class="line"><span class="comment"># 绘图函数 在二维特征时可用</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">plot</span>(<span class="params">data, mu, covariance, class_label</span>):</span><br><span class="line">    plt.scatter(data[:, <span class="number">0</span>], data[:, <span class="number">1</span>], c=class_label)</span><br><span class="line">    n_components = <span class="built_in">len</span>(mu)</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n_components):</span><br><span class="line">        plot_cov_ellipse(covariance[j], mu[j])</span><br><span class="line">    plt.show()</span><br><span class="line"><span class="comment"># 定义高斯函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Gaussian</span>(<span class="params">x, mu, covariance</span>):</span><br><span class="line">    ret = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> x:</span><br><span class="line">        X, mu, covariance = np.array(i), np.array(mu), np.array(covariance)</span><br><span class="line">        ret.append( np.exp(-<span class="number">0.5</span> * (np.dot(np.dot((X-mu).T, np.linalg.inv(covariance)), X-mu))) /</span><br><span class="line">                    math.sqrt(np.linalg.det(<span class="number">2.0</span> * math.pi * covariance)))</span><br><span class="line">    <span class="keyword">return</span> np.array(ret)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="GMM面向对象实现">GMM面向对象实现</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># GMM主体</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GMM</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, X, y, n_components, iteration=<span class="number">40</span>, eps=<span class="number">1e-9</span></span>):</span><br><span class="line">        self.X = X</span><br><span class="line">        self.y = y</span><br><span class="line">        self.m, self.n = X.shape</span><br><span class="line">        <span class="comment"># 组数</span></span><br><span class="line">        self.n_components = n_components</span><br><span class="line">        self.iteration = iteration</span><br><span class="line">        self.eps = eps</span><br><span class="line">        <span class="comment"># 高斯混合模型参数</span></span><br><span class="line">        self.alpha = np.ones(n_components) * <span class="number">1</span> / n_components</span><br><span class="line">        self.mu = np.random.random((self.n_components, self.n))</span><br><span class="line">        self.covariance = np.zeros((self.n_components, self.n, self.n))</span><br><span class="line">        <span class="comment"># 1. 随机初始化 mu 为样本随机点</span></span><br><span class="line">        <span class="comment"># mu n_components * 2</span></span><br><span class="line">        row_rand_array = np.arange(X.shape[<span class="number">0</span>])</span><br><span class="line">        np.random.shuffle(row_rand_array)</span><br><span class="line">        self.mu = X[row_rand_array[<span class="number">0</span>:n_components]]</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 2. 初始化 cov alpha</span></span><br><span class="line">        <span class="comment"># 计算每个样本到 初始化中心点 的距离 </span></span><br><span class="line">        distance = np.tile(np.<span class="built_in">sum</span>(X * X, axis=<span class="number">1</span>).reshape((self.m, <span class="number">1</span>)), (<span class="number">1</span>, self.n_components)) + np.tile(np.<span class="built_in">sum</span>(self.mu * self.mu, axis=<span class="number">1</span>).T,(self.m, <span class="number">1</span>)) - <span class="number">2</span> * np.dot(X, self.mu.T)</span><br><span class="line">        <span class="comment"># 初始标签 按照距离分类</span></span><br><span class="line">        orginial_labels = np.argmin(distance, axis=<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(self.n_components):</span><br><span class="line">            temp = X[orginial_labels == i, :]</span><br><span class="line">            self.alpha[i] = temp.shape[<span class="number">0</span>] / self.m</span><br><span class="line">            self.covariance[i, :, :] = np.cov(temp.T)</span><br><span class="line">            </span><br><span class="line">        <span class="comment"># 3. 概率密度 推断样本 𝐱𝑖 由每一个高斯产生的概率</span></span><br><span class="line">        <span class="comment"># m * n_components </span></span><br><span class="line">        <span class="comment"># 第i行 为 样本 𝐱𝑖 由每一个高斯产生的概率</span></span><br><span class="line">        self.pdfs = np.zeros((self.m, self.n_components))</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">Train</span>(<span class="params">self</span>):</span><br><span class="line">        nowIter = <span class="number">0</span></span><br><span class="line">        preLogLikelihood = self.LogLikelihood()</span><br><span class="line">        <span class="keyword">while</span> nowIter &lt; self.iteration:</span><br><span class="line">            <span class="keyword">if</span> nowIter % <span class="number">20</span> == <span class="number">0</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;Iter:&quot;</span>, nowIter)</span><br><span class="line">            self.Expectation()</span><br><span class="line">            self.Maximize()</span><br><span class="line"><span class="comment">#             plot(self.X, self.mu, self.covariance, self.y)</span></span><br><span class="line">            nowIter += <span class="number">1</span></span><br><span class="line">            logLikelihood = self.LogLikelihood()</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">abs</span>(logLikelihood - preLogLikelihood) &lt; self.eps:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            preLogLikelihood = logLikelihood</span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">    <span class="comment"># 根据当前的各个组分 alpha、mu 和 covariance 计算对数似然函数值</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">LogLikelihood</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(self.n_components):</span><br><span class="line">            self.pdfs[:, j] = self.alpha[j] * Gaussian(self.X, self.mu[j], self.covariance[j])</span><br><span class="line">        <span class="keyword">return</span> np.mean(np.log(np.<span class="built_in">sum</span>(self.pdfs, axis=<span class="number">1</span>)))</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">Expectation</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># E步</span></span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(self.n_components):</span><br><span class="line">            self.pdfs[:,k] = self.alpha[k] * Gaussian(self.X, self.mu[k], self.covariance[k])</span><br><span class="line">            self.W = self.pdfs / np.<span class="built_in">sum</span>(self.pdfs,axis=<span class="number">1</span>).reshape(-<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">Maximize</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># M步</span></span><br><span class="line">        self.alpha = np.<span class="built_in">sum</span>(self.W, axis=<span class="number">0</span>) / np.<span class="built_in">sum</span>(self.W)</span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(self.n_components):</span><br><span class="line">            self.mu[k] = np.average(self.X, axis=<span class="number">0</span>, weights=self.W[:, k])</span><br><span class="line">            cov = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(self.m):</span><br><span class="line">                temp = (self.X[i, :] - self.mu[k, :]).reshape(-<span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">                cov += self.W[i, k] * np.dot(temp, temp.T)</span><br><span class="line">            self.covariance[k, :, :] = cov / np.<span class="built_in">sum</span>(self.W[:, k]) </span><br></pre></td></tr></table></figure><h4 id="Emu数据测试">Emu数据测试</h4><p><strong>参数估计</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">train_X = pd.read_csv(<span class="string">r&#x27;Emu-Train-Samples.csv&#x27;</span>, header=<span class="literal">None</span>)</span><br><span class="line">train_Y = pd.read_csv(<span class="string">r&#x27;Emu-Train-Labels.csv&#x27;</span>, header=<span class="literal">None</span>)</span><br><span class="line">train = copy.deepcopy(train_X)</span><br><span class="line">train[<span class="string">&quot;label&quot;</span>] = train_Y</span><br><span class="line">train = train.to_numpy()</span><br><span class="line">train_1_X = np.array([[i[<span class="number">0</span>], i[<span class="number">1</span>]] <span class="keyword">for</span> i <span class="keyword">in</span> train <span class="keyword">if</span> i[<span class="number">2</span>] == <span class="number">0</span>])</span><br><span class="line">train_1_Y = np.array([i[<span class="number">2</span>] <span class="keyword">for</span> i <span class="keyword">in</span> train <span class="keyword">if</span> i[<span class="number">2</span>] == <span class="number">0</span>])</span><br><span class="line">train_2_X = np.array([[i[<span class="number">0</span>], i[<span class="number">1</span>]] <span class="keyword">for</span> i <span class="keyword">in</span> train <span class="keyword">if</span> i[<span class="number">2</span>] == <span class="number">1</span>])</span><br><span class="line">train_2_Y = np.array([i[<span class="number">2</span>] <span class="keyword">for</span> i <span class="keyword">in</span> train <span class="keyword">if</span> i[<span class="number">2</span>] == <span class="number">1</span>])</span><br><span class="line">plt.scatter(train_1_X[:, <span class="number">0</span>], train_1_X[:, <span class="number">1</span>], c=<span class="string">&#x27;blue&#x27;</span>)</span><br><span class="line">plt.scatter(train_2_X[:, <span class="number">0</span>], train_2_X[:, <span class="number">1</span>], c=<span class="string">&#x27;green&#x27;</span>)</span><br><span class="line"></span><br><span class="line">myGMM1 = GMM(train_1_X, train_1_Y, <span class="number">2</span>)</span><br><span class="line">myGMM1.Train()</span><br><span class="line">myGMM2 = GMM(train_2_X, train_2_Y, <span class="number">2</span>)</span><br><span class="line">myGMM2.Train()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Class_1:&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;mu:&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(myGMM1.mu)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;alpha:&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(myGMM1.alpha)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;covariance:&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(myGMM1.covariance)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Class_2:&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;mu:&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(myGMM2.mu)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;alpha:&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(myGMM2.alpha)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;covariance:&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(myGMM2.covariance)</span><br></pre></td></tr></table></figure><p><strong>预测</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">test_X = pd.read_csv(<span class="string">r&#x27;Emu-Test-Samples.csv&#x27;</span>, header=<span class="literal">None</span>).to_numpy()</span><br><span class="line">test_Y = pd.read_csv(<span class="string">r&#x27;Emu-Test-Labels.csv&#x27;</span>, header=<span class="literal">None</span>).to_numpy().reshape(-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Likelihood</span>(<span class="params">X, alpha, mu, covariance, n_components</span>):</span><br><span class="line">    pdfs = np.zeros((<span class="built_in">len</span>(X), n_components))</span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(n_components):</span><br><span class="line">        pdfs[:, k] = alpha[k] * Gaussian(X, mu[k], covariance[k])</span><br><span class="line">    <span class="keyword">return</span> np.<span class="built_in">sum</span>(pdfs, axis=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">pdfs_1 = Likelihood(test_X, myGMM1.alpha, myGMM1.mu, myGMM1.covariance, <span class="built_in">len</span>(myGMM1.alpha))</span><br><span class="line">pdfs_2 = Likelihood(test_X, myGMM2.alpha, myGMM2.mu, myGMM2.covariance, <span class="built_in">len</span>(myGMM2.alpha))</span><br><span class="line"></span><br><span class="line">predict = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(test_X)):</span><br><span class="line">    <span class="keyword">if</span>(pdfs_1[i] &gt; pdfs_2[i]):</span><br><span class="line">        predict.append(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        predict.append(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">accuracy = <span class="built_in">sum</span>(predict == test_Y) / <span class="built_in">len</span>(predict)</span><br><span class="line"><span class="built_in">print</span>(accuracy)</span><br></pre></td></tr></table></figure><h4 id="MNIST数据集测试">MNIST数据集测试</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">train_mnist_X = pd.read_csv(<span class="string">r&#x27;MNIST-Train-Samples.csv&#x27;</span>, header=<span class="literal">None</span>)</span><br><span class="line">train_mnist_Y = pd.read_csv(<span class="string">r&#x27;MNIST-Train-Labels.csv&#x27;</span>, header=<span class="literal">None</span>)</span><br><span class="line">test_mnist_X = pd.read_csv(<span class="string">r&#x27;MNIST-Test-Samples.csv&#x27;</span>, header=<span class="literal">None</span>)</span><br><span class="line">test_mnist_Y = pd.read_csv(<span class="string">r&#x27;MNIST-Test-Labels.csv&#x27;</span>, header=<span class="literal">None</span>)</span><br><span class="line">train_mnist = train_mnist_X</span><br><span class="line">train_mnist[<span class="string">&quot;label&quot;</span>] = train_mnist_Y</span><br><span class="line">train_mnist = train_mnist.to_numpy()</span><br><span class="line">test_mnist_X = test_mnist_X.to_numpy()</span><br><span class="line">test_mnist_Y = test_mnist_Y.to_numpy().reshape(-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">GmmOfMnist</span>(<span class="params">number</span>):</span><br><span class="line">    alphas = []</span><br><span class="line">    mus = []</span><br><span class="line">    covariances = []</span><br><span class="line">    pdfs = []</span><br><span class="line"></span><br><span class="line"><span class="comment">#     print(&quot;Train Begin!&quot;)</span></span><br><span class="line">    <span class="keyword">for</span> index <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">10</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;GMM&quot;</span>, number,<span class="string">&quot; &quot;</span>, <span class="string">&quot;class&quot;</span>, index)</span><br><span class="line">        nowTrain_X = np.array([i[:-<span class="number">1</span>] <span class="keyword">for</span> i <span class="keyword">in</span> train_mnist <span class="keyword">if</span> i[-<span class="number">1</span>] == index])</span><br><span class="line"><span class="comment">#         print(np.shape(nowTrain_X))</span></span><br><span class="line">        nowTrain_Y = [index] * <span class="built_in">len</span>(nowTrain_X)</span><br><span class="line">        nowGMM = GMM(nowTrain_X, nowTrain_Y, number)</span><br><span class="line">        nowGMM.Train()</span><br><span class="line">        alphas.append(nowGMM.alpha)</span><br><span class="line">        mus.append(nowGMM.mu)</span><br><span class="line">        covariances.append(nowGMM.covariance)</span><br><span class="line">        </span><br><span class="line"><span class="comment">#     print(&quot;Test Begin!&quot;)</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">10</span>):  </span><br><span class="line">        pdfs.append(Likelihood(test_mnist_X, alphas[i], mus[i], covariances[i], <span class="built_in">len</span>(alphas[i])))</span><br><span class="line">    result = np.argmax(pdfs, axis = <span class="number">0</span>)</span><br><span class="line">    accuracy_num = <span class="built_in">sum</span>(result == test_mnist_Y) </span><br><span class="line">    accuracy = accuracy_num / <span class="built_in">len</span>(result)</span><br><span class="line">    <span class="keyword">return</span> accuracy_num, accuracy</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, <span class="number">6</span>):</span><br><span class="line">    accuracy_num, accuracy = GmmOfMnist(i)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;GMM number:&quot;</span>, i)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;正确识别数: &quot;</span>, accuracy_num)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;正确识别率: &quot;</span>, accuracy)</span><br></pre></td></tr></table></figure><h2 id="遇到的问题及解决方法">遇到的问题及解决方法</h2><ul><li>高斯均值初始化问题：<br>在前几轮训练中有几次收敛到局部最优解，即有个别高斯模型重叠覆盖了同一个训练样本，或者一个高斯完全覆盖了另一个高斯的样本范围。这是由于初始化不够好导致的，起初选用的是固定选点，后续使用的是随机样本选点，更好的做法应该是使用Kmeans聚类选择初始化点。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客常用操作</title>
      <link href="/post/83d7c48b.html"/>
      <url>/post/83d7c48b.html</url>
      
        <content type="html"><![CDATA[<p>记录博客常用操作</p><span id="more"></span><h2 id="一键三连-部署">一键三连 + 部署</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hexo cl</span><br><span class="line">hexo g</span><br><span class="line">hexo s</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><h2 id="创建博客">创建博客</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo new post &quot;博客名&quot;</span><br><span class="line">hexo n &quot;博客名&quot;</span><br></pre></td></tr></table></figure><ul><li>文章标题可以在对应 md 文件里改，新建时标题可以写的简单些；</li><li>文件属性：<br>| - | Setting | Description | Default   |<br>|:-:|:-------:|:-----------:|:---------:|<br>| 1 | layout  |   Layout    | post或page|<br>| 2 | title   |  文章的标题  |             |<br>| 3 | date    |  创建日期    |文件的创建日期|<br>| 4 | updated |  修改日期    |文件的修改日期|<br>| 5 | comments| 是否开启评论 | true |<br>| 6 | tags    | 标签        |   |<br>| 7 |categories| 分类       |   |<br>| 8 | permalink| url中的名字| 文件名|</li></ul><h2 id="刷新缓存">刷新缓存</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo cl</span><br></pre></td></tr></table></figure><ul><li>该命令用于清除缓存文件 <em><strong>db.json</strong></em> 和已生成的静态文件 <em><strong>public</strong></em></li><li>在更换主题后，如果发现站点更改不生效，可以运行该命令;</li><li>网站显示异常时可以执行这条命令试试;</li></ul><h2 id="生成网站静态文件">生成网站静态文件</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure><ul><li>是 hexo generate 的缩写;</li><li>生成网站静态文件到默认设置的 public 文件夹;</li><li>如果使用自动部署，不需要先执行该命令；</li></ul><h2 id="启动本地服务器">启动本地服务器</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure><ul><li>用于预览主题。默认地址： <em><strong><a href="http://localhost:4000/">http://localhost:4000/</a></strong></em> ；</li><li>预览的同时可以在md中修改文章内容或主题代码，保存后刷新页面即可；</li><li>对 <em><strong>_config.yml</strong></em> 的修改，需要重启本地服务器后才能预览效果。</li></ul><h2 id="部署到github">部署到github</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure><ul><li>是 <em><strong>hexo deploy</strong></em> 的缩写</li><li>自动生成网站静态文件，并部署到设定的仓库</li></ul><h2 id="草稿">草稿</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new draft &quot;new draft&quot;</span><br></pre></td></tr></table></figure><ul><li>会在source/_drafts目录下生成一个 <em><strong><a href="http://new-draft.md">new-draft.md</a></strong></em>文件。但是这个文件不被显示在页面上，链接也访问不到。也就是说如果你想把某一篇文章移除显示，又不舍得删除，可以把它移动到 <em><strong>_drafts</strong></em> 目录之中。</li><li>下面这条命令可以把草稿变成文章，或者页面：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo publish [layout] &lt;filename&gt;</span><br></pre></td></tr></table></figure><blockquote><p>以上命令使用基于 Hexo 3.1.1 版本；<br>更多命令用法请查询 <a href="https://hexo.io/zh-cn/docs/commands.html">官方文档</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>创建博客踩坑记录</title>
      <link href="/post/b93631e0.html"/>
      <url>/post/b93631e0.html</url>
      
        <content type="html"><![CDATA[<p>记录创建博客时的报错</p><span id="more"></span><h2 id="生成SSH密钥保存位置">生成SSH密钥保存位置</h2><ul><li>错误：将 <strong>“.ssh/id_rsa”</strong> 存入D盘下的文件夹中</li><li>解决：应将其存入 <strong>“C/Users/”</strong> 文件夹中</li></ul><h2 id="运行-“ssh-T-git-github-com”-时报错">运行 “<code>ssh -T git@github.com</code>” 时报错</h2><ul><li>错误：Permission denied (publickey). fatal: Could not read from remote repository.</li><li>解决：将得到的密钥添加到github中</li></ul><h2 id="运行-“hexo-init”-初始化hexo时报错">运行 “<code>hexo init</code>” 初始化hexo时报错</h2><ul><li>错误1：三行 Info 中第二行报错：</li><li>解决： 一般是github访问问题，建议使用加速器</li><li>错误2：三行 Info 中第三行报错：<br>Failed to install dependencies. Please run ‘npm install’ manually!。且 执行&quot;npm install&quot;失败</li><li>解决： 这是因为没用使用管理员模式打开 <em><strong>git bash</strong></em> 建议在 修改 <em><strong>git-bash.exe</strong></em> 默认使用管理员启动</li></ul><h2 id="运行-“hexo-d”-时报错">运行 “<code>hexo d</code>” 时报错</h2><ul><li>错误：ERROR Deployer not found: git</li><li>解决：<ul><li>如果没有安装 <em><strong>hexo-deployer-git</strong></em> 插件 先安装</li></ul>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><ul><li>先在github上创建网站库 再尝试</li></ul></li></ul><h2 id="打开创建好的网站时报错404">打开创建好的网站时报错404</h2><ul><li>解决：作者起初使用了与github用户名不同的名字作为库名即网站名，出现404，再修改为与github用户名相同后，且修改 <em><strong>_config.yml</strong></em> 文档相关信息后成功打开</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 踩坑 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title></title>
      <link href="/manifest.json"/>
      <url>/manifest.json</url>
      
        <content type="html"><![CDATA[{"name":"Escapeey`Blog","short_name":"Escapeey","theme_color":"#c8e7e4","background_color":"#3b70fc","display":"standalone","scope":"/","start_url":"/","icons":[{"src":"/img/siteicon/16.png","sizes":"16x16","type":"image/png"},{"src":"/img/siteicon/32.png","sizes":"32x32","type":"image/png"},{"src":"/img/siteicon/48.png","sizes":"48x48","type":"image/png"},{"src":"/img/siteicon/64.png","sizes":"64x64","type":"image/png"},{"src":"/img/siteicon/128.png","sizes":"128x128","type":"image/png"},{"src":"/img/siteicon/144.png","sizes":"144x144","type":"image/png"},{"src":"/img/siteicon/512.png","sizes":"512x512","type":"image/png"}],"splash_pages":null}]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>categories</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/css/custom.css"/>
      <url>/css/custom.css</url>
      
        <content type="html"><![CDATA[/* @font-face {  font-family: Candyhome;  src: url(https://npm.elemecdn.com/anzhiyu-blog@1.1.6/fonts/Candyhome.ttf);  font-display: swap;  font-weight: lighter;} */@font-face {  font-family: ZhuZiAYuanJWD;  src: url(https://npm.elemecdn.com/anzhiyu-blog@1.1.6/fonts/ZhuZiAWan.woff2);  font-display: swap;  font-weight: lighter;}div#menus {  font-family: "ZhuZiAYuanJWD";}h1#site-title {  font-family: ZhuZiAYuanJWD;  font-size: 3em !important;}a.article-title,a.blog-slider__title,a.categoryBar-list-link,h1.post-title {  font-family: ZhuZiAYuanJWD;}.iconfont {  font-family: "iconfont" !important;  font-size: 3em;  /* 可以定义图标大小 */  font-style: normal;  -webkit-font-smoothing: antialiased;  -moz-osx-font-smoothing: grayscale;}/* 时间轴生肖icon */svg.icon {  /* 这里定义svg.icon，避免和Butterfly自带的note标签冲突 */  width: 1em;  height: 1em;  /* width和height定义图标的默认宽度和高度*/  vertical-align: -0.15em;  fill: currentColor;  overflow: hidden;}.icon-zhongbiao::before {  color: #f7c768;}/* bilibli番剧插件 */#article-container .bangumi-tab.bangumi-active {  background: var(--anzhiyu-theme);  color: var(--anzhiyu-ahoverbg);  border-radius: 10px;}a.bangumi-tab:hover {  text-decoration: none !important;}.bangumi-button:hover {  background: var(--anzhiyu-theme) !important;  border-radius: 10px !important;  color: var(--anzhiyu-ahoverbg) !important;}a.bangumi-button.bangumi-nextpage:hover {  text-decoration: none !important;}.bangumi-button {  padding: 5px 10px !important;}a.bangumi-tab {  padding: 5px 10px !important;}svg.icon.faa-tada {  font-size: 1.1em;}.bangumi-info-item {  border-right: 1px solid #f2b94b;}.bangumi-info-item span {  color: #f2b94b;}.bangumi-info-item em {  color: #f2b94b;}/* 解决artitalk的图标问题 */#uploadSource > svg {  width: 1.19em;  height: 1.5em;}/*top-img黑色透明玻璃效果移除，不建议加，除非你执着于完全一图流或者背景图对比色明显 */#page-header:not(.not-top-img):before {  background-color: transparent !important;}/* 首页文章卡片 */#recent-posts > .recent-post-item {  background: rgba(255, 255, 255, 0.9);}/* 首页侧栏卡片 */#aside-content .card-widget {  background: rgba(255, 255, 255, 0.9);}/* 文章页面正文背景 */div#post {  background: rgba(255, 255, 255, 0.9);}/* 分页页面 */div#page {  background: rgba(255, 255, 255, 0.9);}/* 归档页面 */div#archive {  background: rgba(255, 255, 255, 0.9);}/* 标签页面 */div#tag {  background: rgba(255, 255, 255, 0.9);}/* 分类页面 */div#category {  background: rgba(255, 255, 255, 0.9);}/*夜间模式伪类遮罩层透明*/[data-theme="dark"] #recent-posts > .recent-post-item {  background: #121212;}[data-theme="dark"] .card-widget {  background: #121212 !important;}[data-theme="dark"] div#post {  background: #121212 !important;}[data-theme="dark"] div#tag {  background: #121212 !important;}[data-theme="dark"] div#archive {  background: #121212 !important;}[data-theme="dark"] div#page {  background: #121212 !important;}[data-theme="dark"] div#category {  background: #121212 !important;}[data-theme="dark"] div#category {  background: transparent !important;}/* 页脚透明 *//* #footer {  background: transparent !important;} *//* 头图透明 *//* #page-header {  background: transparent !important;} */#rightside > div > button {  border-radius: 5px;}/* 滚动条 */::-webkit-scrollbar {  width: 10px;  height: 10px;}::-webkit-scrollbar-thumb {  background-color: #3b70fc;  border-radius: 2em;}::-webkit-scrollbar-corner {  background-color: transparent;}::-moz-selection {  color: #fff;  background-color: #3b70fc;}/* 音乐播放器 *//* .aplayer .aplayer-lrc {  display: none !important;} */.aplayer.aplayer-fixed.aplayer-narrow .aplayer-body {  left: -66px !important;  transition: all 0.3s;  /* 默认情况下缩进左侧66px，只留一点箭头部分 */}.aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover {  left: 0 !important;  transition: all 0.3s;  /* 鼠标悬停是左侧缩进归零，完全显示按钮 */}.aplayer.aplayer-fixed {  z-index: 999999 !important;}/* 评论框  */.vwrap {  box-shadow: 2px 2px 5px #bbb;  background: rgba(255, 255, 255, 0.3);  border-radius: 8px;  padding: 30px;  margin: 30px 0px 30px 0px;}/* 设置评论框 */.vcard {  box-shadow: 2px 2px 5px #bbb;  background: rgba(255, 255, 255, 0.3);  border-radius: 8px;  padding: 30px;  margin: 30px 0px 0px 0px;}/* md网站下划线 */#article-container a:hover {  text-decoration: none !important;}#article-container #hpp_talk p img {  display: inline;}/* 404页面 */#error-wrap {  position: absolute;  top: 40%;  right: 0;  left: 0;  margin: 0 auto;  padding: 0 1rem;  max-width: 1000px;  transform: translate(0, -50%);}#error-wrap .error-content {  display: flex;  flex-direction: row;  justify-content: center;  align-items: center;  margin: 0 1rem;  height: 18rem;  border-radius: 8px;  background: var(--card-bg);  box-shadow: var(--card-box-shadow);  transition: all 0.3s;}#error-wrap .error-content .error-img {  box-flex: 1;  flex: 1;  height: 100%;  border-top-left-radius: 8px;  border-bottom-left-radius: 8px;  background-color: #3b70fc;  background-position: center;  background-size: cover;}#error-wrap .error-content .error-info {  box-flex: 1;  flex: 1;  padding: 0.5rem;  text-align: center;  font-size: 14px;  font-family: Titillium Web, "PingFang SC", "Hiragino Sans GB", "Microsoft JhengHei", "Microsoft YaHei", sans-serif;}#error-wrap .error-content .error-info .error_title {  margin-top: -4rem;  font-size: 9em;}#error-wrap .error-content .error-info .error_subtitle {  margin-top: -3.5rem;  word-break: break-word;  font-size: 1.6em;}#error-wrap .error-content .error-info a {  display: inline-block;  margin-top: 0.5rem;  padding: 0.3rem 1.5rem;  background: var(--btn-bg);  color: var(--btn-color);}#body-wrap.error .aside-list {  display: flex;  flex-direction: row;  flex-wrap: nowrap;  bottom: 0px;  position: absolute;  padding: 1rem;  width: 100%;  overflow: scroll;}#body-wrap.error .aside-list .aside-list-group {  display: flex;  flex-direction: row;  flex-wrap: nowrap;  max-width: 1200px;  margin: 0 auto;}#body-wrap.error .aside-list .aside-list-item {  padding: 0.5rem;}#body-wrap.error .aside-list .aside-list-item img {  width: 100%;  object-fit: cover;  border-radius: 12px;}#body-wrap.error .aside-list .aside-list-item .thumbnail {  overflow: hidden;  width: 230px;  height: 143px;  background: var(--anzhiyu-card-bg);  display: flex;}#body-wrap.error .aside-list .aside-list-item .content .title {  -webkit-line-clamp: 2;  overflow: hidden;  display: -webkit-box;  -webkit-box-orient: vertical;  line-height: 1.5;  justify-content: center;  align-items: flex-end;  align-content: center;  padding-top: 0.5rem;  color: white;}#body-wrap.error .aside-list .aside-list-item .content time {  display: none;}/* 代码框主题 */#article-container figure.highlight {  border-radius: 10px;}]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>link</title>
      <link href="/link/index.html"/>
      <url>/link/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>tags</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/js/runtime/runtime%20min.js"/>
      <url>/js/runtime/runtime%20min.js</url>
      
        <content type="html"><![CDATA[var now=new Date;function createtime(){var grt=new Date("18/10/2023 00:18:00");now.setTime(now.getTime()+250);var days=(now-grt)/1e3/60/60/24,dnum=Math.floor(days),hours=(now-grt)/1e3/60/60-24*dnum,hnum=Math.floor(hours);1==String(hnum).length&&(hnum="0"+hnum);var minutes=(now-grt)/1e3/60-1440*dnum-60*hnum,mnum=Math.floor(minutes);1==String(mnum).length&&(mnum="0"+mnum);var seconds=(now-grt)/1e3-86400*dnum-3600*hnum-60*mnum,snum=Math.round(seconds);1==String(snum).length&&(snum="0"+snum);let currentTimeHtml=""}setInterval(()=>{createtime()},250);]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/js/runtime/runtime.js"/>
      <url>/js/runtime/runtime.js</url>
      
        <content type="html"><![CDATA[var now = new Date();function createtime() {  var grt = new Date("18/10/2023 00:18:00");  now.setTime(now.getTime() + 250);  var days = (now - grt) / 1e3 / 60 / 60 / 24,    dnum = Math.floor(days),    hours = (now - grt) / 1e3 / 60 / 60 - 24 * dnum,    hnum = Math.floor(hours);  1 == String(hnum).length && (hnum = "0" + hnum);  var minutes = (now - grt) / 1e3 / 60 - 1440 * dnum - 60 * hnum,    mnum = Math.floor(minutes);  1 == String(mnum).length && (mnum = "0" + mnum);  var seconds = (now - grt) / 1e3 - 86400 * dnum - 3600 * hnum - 60 * mnum,    snum = Math.round(seconds);  1 == String(snum).length && (snum = "0" + snum);  let currentTimeHtml = "";//   (currentTimeHtml =    // hnum < 18 && hnum >= 9    //   ? `<img class='boardsign' src='https://npm.elemecdn.com/anzhiyu-blog@2.0.4/img/badge/安知鱼-上班摸鱼中.svg' title='距离月入25k也就还差一个大佬带我~'><span class='textTip'> <br> 本站居然运行了 ${dnum} 天</span><span id='runtime'> ${hnum} 小时 ${mnum} 分 ${snum} 秒 </span> <i class='fas fa-heartbeat' style='color:red'></i>`    //   : `<img class='boardsign' src='https://npm.elemecdn.com/anzhiyu-blog@2.0.4/img/badge/安知鱼-下班啦.svg' title='下班了就该开开心心的玩耍，嘿嘿~'><span class='textTip'> <br> 本站居然运行了 ${dnum} 天</span><span id='runtime'> ${hnum} 小时 ${mnum} 分 ${snum} 秒 </span> <i class='fas fa-heartbeat' style='color:red'></i>`),    // document.getElementById("workboard") && (document.getElementById("workboard").innerHTML = currentTimeHtml);}setInterval(() => {  createtime();}, 250);]]></content>
      
    </entry>
    
    
  
</search>
