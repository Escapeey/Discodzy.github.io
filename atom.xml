<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Escapeey`Blog</title>
  
  <subtitle>岂能尽如人意，但求无愧我心。</subtitle>
  <link href="https://escapeey.cn/atom.xml" rel="self"/>
  
  <link href="https://escapeey.cn/"/>
  <updated>2024-12-14T06:24:07.529Z</updated>
  <id>https://escapeey.cn/</id>
  
  <author>
    <name>Escapeey</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>《被讨厌的勇气》</title>
    <link href="https://escapeey.cn/post/bc644448.html"/>
    <id>https://escapeey.cn/post/bc644448.html</id>
    <published>2024-11-24T23:12:23.000Z</published>
    <updated>2024-12-14T06:24:07.529Z</updated>
    
    <content type="html"><![CDATA[<p>“世界极其简单，人生也一样。”</p><hr><h1>摘要</h1><p><strong>《被讨厌的勇气》</strong> 的逻辑起点是个体自由，最终指向共同体幸福。</p><ul><li>通过<strong>否定创伤论</strong>，人获得对生命的掌控；</li><li>通过<strong>分离课题</strong>，人学会处理人际关系；</li><li>通过<strong>共同体感觉</strong>，人找到幸福的归宿；</li><li>通过<strong>活在当下</strong>，人实现生命的意义；</li></ul><p>而这一切都需要一份“被讨厌”的勇气，即<strong>接纳真实的自己</strong>并<strong>主动面对人生课题</strong>。</p><h1>脉络梳理</h1><h2 id="第一部分：否定创伤——“人并不是被过去所决定的”">第一部分：否定创伤——“人并不是被过去所决定的”</h2><ul><li><p><strong>核心思想</strong>：人的行为并非由过去的经历决定，而是由自己“赋予”过去经历的意义决定。</p></li><li><p><strong>逻辑主线</strong>：</p><ul><li><strong>创伤决定论的否定</strong>：反对弗洛伊德的“原因论”，认为创伤无法决定未来的行动。</li><li><strong>目的论的提出</strong>：行为的发生源于达成特定目的的需要。例如，一个人内向是因为他以此逃避人际关系。</li><li><strong>意义的选择</strong>：人拥有改变自己故事叙述的自由，过去无法束缚未来。</li></ul></li><li><p><strong>方法论</strong>：</p><ul><li>停止将问题归因于过去，如“因为我的家庭/经历，所以我失败”。</li><li>重新思考经历中积极的部分，为它赋予新的意义。</li><li>相信自己有能力改变当下与未来，不受过去的束缚。</li></ul></li></ul><hr><h2 id="第二部分：所有烦恼都来自人际关系">第二部分：所有烦恼都来自人际关系</h2><ul><li><p><strong>核心思想</strong>：人生的主要课题是人际关系，而所有烦恼的本质都源于人际关系中的冲突。</p></li><li><p><strong>逻辑主线</strong>：</p><ul><li><strong>人际关系的课题</strong>：阿德勒提出“<strong>人生课题</strong>三分法”：工作、交友、爱。这些都涉及如何与他人相处。</li><li><strong>人际冲突的来源</strong>：归因于过于在意他人的评价或试图掌控他人。</li><li><strong>课题分离</strong>：提出“课题分离”概念，将自己的问题与他人的问题区分开，不干涉他人的课题。</li></ul></li><li><p><strong>方法论</strong>：</p><ul><li>判断问题属于“谁的课题”（如：他人是否喜欢你，是他人的课题）。</li><li>专注解决自己的课题，不干涉或过度在意他人的课题。</li><li>明确边界：不操控他人，也不允许他人操控自己。</li></ul></li></ul><hr><h2 id="第三部分：让自己被讨厌">第三部分：让自己被讨厌</h2><ul><li><p><strong>核心思想</strong>：为了实现真正的自由，需要接纳被他人讨厌的可能性。</p></li><li><p><strong>逻辑主线</strong>：</p><ul><li><strong>寻求认可的困境</strong>：过度追求被他人喜欢会丧失自我。</li><li><strong>勇气的含义</strong>：有勇气做真实的自己，而不是为了迎合他人而改变。</li><li><strong>幸福的前提</strong>：幸福来源于与人“平等”的关系，而非控制或依赖。</li></ul></li><li><p><strong>方法论</strong>：</p><ul><li>不再以取悦他人为目标，而是努力成为最真实的自己。</li><li>理解“被讨厌”并不意味着你的价值降低，而是正常的人际现象。</li><li>与他人建立平等关系：不高高在上，也不低人一等。</li></ul></li></ul><hr><h2 id="第四部分：追求共同体感觉">第四部分：追求共同体感觉</h2><ul><li><p><strong>核心思想</strong>：真正的幸福来源于对“共同体感觉”的追求，即关心他人、融入社会。</p></li><li><p><strong>逻辑主线</strong>：</p><ul><li><strong>共同体的定义</strong>：不仅包括家庭、朋友，还包括全人类乃至整个宇宙。</li><li><strong>超越自我</strong>：幸福并非独自追求个人成就，而是通过贡献与他人建立联结。</li><li><strong>意义的实现</strong>：当个人感到自己对共同体有贡献时，就会体验到充实感和幸福感。</li></ul></li><li><p><strong>方法论</strong>：</p><ul><li>扩大共同体范围，从亲密关系到社会，再到全人类甚至自然界。</li><li>在工作、生活中寻找自己的贡献点，即“我能为他人和社会做什么”。</li><li>学会与他人合作，而不是将人生看作孤军奋战或竞争场。</li></ul></li></ul><hr><h2 id="第五部分：活在当下">第五部分：活在当下</h2><ul><li><p><strong>核心思想</strong>：生命的意义存在于此时此刻，关注现在比纠结过去或担忧未来更重要。</p></li><li><p><strong>逻辑主线</strong>：</p><ul><li><strong>活在当下的实践</strong>：把握当下行动，避免被对过去的后悔和对未来的恐惧牵制。</li><li><strong>生活的意义</strong>：人生的价值不在于结果，而在于每一瞬间的选择和行动。</li><li><strong>行动中的幸福</strong>：通过积极参与和行动体验幸福感，而非等待外界赋予意义。</li></ul></li><li><p><strong>方法论</strong>：</p><ul><li>不为过去的错误后悔，也不为未来的不确定性担忧，专注于当下可控的事情。</li><li>把目标拆解为眼下可以实现的小步骤，每天做出具体的努力。</li><li>相信幸福是行动的副产品，而非外界强加的状态。</li></ul></li></ul><hr><h1>读后记</h1><blockquote><p><strong>我人生的转折点</strong>，始于高中毕业的那个夏天。作为一个从小被视为“好孩子”的我，满足周围人的期待曾是至关重要的事——甚至可以说，这构成了我自我价值和自信的主要来源。然而，高考的失利犹如晴天霹雳，把这一切击得粉碎。<br>那段时期，我陷入深深的自我怀疑：如果没有优异的成绩，我还能有什么价值？我又该如何面对那些对我充满期待的父母、老师和朋友？失落、迷茫的情绪不断翻涌，我一度考虑复读，但对高考的恐惧让我踌躇不前。我消沉了很久，可“坐以待毙”从来不是我的人生信条。于是，我开始了一场寻找自我的旅程。<br>回望过去才发现，我的自信从来都不是由内而生，而是依赖于外在的认可——他人的肯定、成绩的优越感，甚至那种看似稳固的自信，实则不过是掩盖自卑的一层外壳。或许，越是依赖外界的人，内心反而越是脆弱。当这层外壳失去后，我不得不直面深藏的自卑感，那是一种彻底的失落与无助。<br>进入大学后，我开始思考，是否存在一种无需他人认可的生活方式？一种能由内而外真正认可自己的途径？在这个过程中，我接触到了《被讨厌的勇气》。<br>这本书犹如一碗苦涩的中药，哲人犀利而坚定的言语常常刺痛我的内心。“<strong>人并不是被过去所决定的</strong>”，这一观点颠覆了我的思维方式。曾经，我将高考失利视为人生价值的分水岭，仿佛未来的道路因此被彻底封死。否定创伤论让我重新看待过去的经历，它不再是障碍，而成为重新出发的起点。<br>“<strong>课题分离</strong>”的思想为人际关系带来了新的视角。长久以来，行为深受父母、老师甚至朋友的期待驱使，外界评价几乎成为我价值感的唯一来源。书中提出的“课题分离”帮助我明白，每个人都有自己的责任和课题，别人对我的看法是他们的课题，而不是我需要承担的。我开始专注于自己能够掌控的事情，放下对他人评价的执念，人际关系变得更轻松，也更真诚。<br>关于“<strong>共同体感觉</strong>”，书中让我看到了幸福的另一种定义。幸福不在于孤立的成就或与他人的比较，而在于融入共同体后的归属感与贡献感。当视野从自身扩展到他人、社会，乃至整个宇宙，许多烦恼变得微不足道，取而代之的是与他人联结后的满足感。<br>“活在当下”的理念让我不再纠结于无法改变的过去，也不再恐惧未知的未来。将精力投入到当前的每一天，做好力所能及的事情，踏实感也随之而来。<br>在接受<strong>目的论</strong>这种世界观后，我感觉轻松了很多，同时又沉重了很多。轻松，使因为决定不再纠缠过去，不再被过去种种烦扰。沉重则是因为，<strong>责任就百分百扣在了自己身上</strong>。然而，神奇的是，内心的力量也应运而生。<br>阿德勒的心理学，把自我从过去、人际关系和未来中解放出来。可是越狱成功以后呢？以前我们裹足不前，可以怪父母怨社会，而阿德勒却完全把人生责任和选择的权力交给了我们自己。当我们从这些束缚中解脱出来后，却会发现，我们其实一直都很自由，真正让我们裹足不前的，原来正是我们自己。正如本书的名字《被讨厌的勇气》​，承担这种自由和责任，需要无畏的勇气。这种<strong>勇气</strong>，是阿德勒心理学的关键词，也是我们人生问题的最终解药。<br>最后，引用阿德勒大师的话&quot;<strong>必须有人开始，即使别人不合作，那也与你无关。我的意见就是这样。应该有你开始，不用去考虑别人是否合作</strong>&quot;。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;“世界极其简单，人生也一样。”&lt;/p&gt;
&lt;hr&gt;
&lt;h1&gt;摘要&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;《被讨厌的勇气》&lt;/strong&gt; 的逻辑起点是个体自由，最终指向共同体幸福。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;通过&lt;strong&gt;否定创伤论&lt;/strong&gt;，人获得对生命的掌控；&lt;</summary>
      
    
    
    
    <category term="读书笔记" scheme="https://escapeey.cn/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="读书笔记" scheme="https://escapeey.cn/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>锂电池行业概述</title>
    <link href="https://escapeey.cn/post/7416a4f2.html"/>
    <id>https://escapeey.cn/post/7416a4f2.html</id>
    <published>2024-11-09T18:56:12.000Z</published>
    <updated>2024-12-14T06:24:07.529Z</updated>
    
    <content type="html"><![CDATA[<p>冬天到了，为什么电池充电时间变久了，充的电不耐用了？</p><hr><ul><li>参考视频: <a href="https://www.bilibili.com/video/BV15wHKepEEF/?spm_id_from=333.1007">锂电池行业快速通关</a></li></ul><h1>电池基本原理</h1><p>电池的基本工作原理是将化学能转化为电能。其工作过程可以通过以下几个步骤进行简述：</p><ol><li><strong>化学反应</strong>：电池内部发生化学反应，负极失去电子（氧化反应），正极得到电子（还原反应）。</li><li><strong>电流流动</strong>：电子从负极流向正极，形成电流，供应外部电路所需的电能。</li><li><strong>充放电过程</strong>：<ul><li>放电时，负极释放电子，电流流向正极。</li><li>充电时，电池被电源电流反向充电，电子从正极流向负极。</li></ul></li></ol><h2 id="电池的主要组成部分：">电池的主要组成部分：</h2><ul><li><strong>负极</strong>：失去电子的部分。</li><li><strong>正极</strong>：得到电子的部分。</li><li><strong>电解液</strong>：允许锂离子（或其他离子）在两极之间流动。</li></ul><hr><h1>材料选择</h1><p>电池材料选择是确保电池性能和安全的关键因素。选择合适的材料需要考虑以下几个特性：</p><ul><li><strong>足够的电量</strong>：电池应能存储和释放足够的电能。</li><li><strong>轻便性</strong>：尤其对于移动设备和电动汽车，轻便的材料是必要的。</li><li><strong>安全性</strong>：材料应具有良好的热稳定性和化学稳定性，防止发生过热或短路。</li><li><strong>长寿命</strong>：材料的化学稳定性必须保证电池的长时间循环使用。</li><li><strong>材料常见</strong>：制造电池所需的材料在自然界中普遍存在<br>锂电池材料的一个关键原因是锂的原子结构：</li><li>锂是周期表中质量最轻的金属，外层电子容易失去，使其成为理想的电池材料。</li></ul><hr><h1>正极材料</h1><p>这种材料要在失去锂离子后还能形成稳定的化合价，保证电池的安全与稳定，所以锂不能单独存在，必须与其他物质以一种化合物的形式共存。</p><p>正极材料是锂电池中能量存储的主要材料。常见的正极材料包括：</p><table><thead><tr><th>材料</th><th>特性</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td><strong>磷酸铁锂(<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mi>i</mi><mi>F</mi><mi>e</mi><mi>P</mi><msub><mi>O</mi><mn>4</mn></msub></mrow><annotation encoding="application/x-tex">LiFePO_4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord mathnormal">L</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>)</strong></td><td>能量密度适中，热稳定性好，安全性高。</td><td>高热稳定性，安全性高，成本低。</td><td>能量密度相对较低，续航较短。</td></tr><tr><td><strong>三元材料</strong></td><td>含锰、镍、钴三种金属的化合物，能量密度高。</td><td>能量密度高，适合高续航应用。</td><td>材料成本高，热稳定性较差。</td></tr><tr><td><strong>镍酸锂</strong></td><td>高能量密度，适用于高性能应用。</td><td>高能量密度，续航能力强。</td><td>成本高，供应链紧张，矿产资源集中。</td></tr><tr><td><strong>钴酸锂</strong></td><td>稳定的电化学性能，历史较长。</td><td>高能量密度，续航能力强；商业化较早，技术成熟。</td><td>成本高，钴资源的供应问题。</td></tr></tbody></table><img src="..\..\img\IndustryEntry/锂电池-锂离子电池产量结构图.png" width="100%" height="100%" align="middle"><ul><li>统计时间: 2023-06</li></ul><img src="..\..\img\IndustryEntry/锂电池-电池成本.png" width="100%" height="100%" align="middle"><img src="..\..\img\IndustryEntry/锂电池-性能.png" width="100%" height="100%" align="middle"><ul><li><strong>磷酸铁锂</strong>：是目前应用最广泛的材料之一，特别是在新能源汽车中。其热稳定性好，能防止电池过热引发火灾或爆炸。</li><li><strong>三元材料</strong>：由镍、钴、锰三种金属混合组成，其能量密度高，是现代高续航电池的首选材料。</li></ul><h2 id="磷酸铁锂">磷酸铁锂</h2><ul><li>在失去锂离子时 物质的晶体结构未发生改变，呈现橄榄石结构，不会坍塌或变形，可以让其在充放电时维持良好的<strong>热稳定性</strong>和<strong>循环性能</strong>，从而保证使用安全和寿命</li><li>磷和铁分布广泛，简单易得</li></ul><img src="..\..\img\IndustryEntry/锂电池-磷酸铁锂结构图.png" width="100%" height="100%" align="middle"><h2 id="三元材料">三元材料</h2><ul><li>指含有<strong>锰(Mn)</strong>、<strong>钴(Co)</strong>、**镍(Ni)**三种材料的材料</li></ul><table><thead><tr><th>材料</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td><strong>钴酸锂</strong></td><td>能量密度高，续航时间长</td><td>成本极高，限制了商业化发展</td></tr><tr><td><strong>锰酸锂</strong></td><td>热稳定性好</td><td>能量密度低，使用寿命有限</td></tr><tr><td><strong>镍酸锂</strong></td><td>能量密度高</td><td>极易发生晶体结构变化</td></tr></tbody></table><ul><li><p>都有缺点，取长补短</p><ul><li><strong>钴</strong>稳定晶体结构、提升循环性能</li><li><strong>镍</strong>作为活性金属，提供较大能量密度</li><li><strong>锰</strong>作为非活性金属，稳定材料内部反应、降低生产成本</li></ul></li><li><p>由于镍提供较大的能量密度，所以三元锂电池的发展是<strong>低镍到高镍</strong>的发展</p></li><li><p>比例分配</p><ul><li>NCM333<ul><li>钴成本较高，提升了生产成本</li></ul></li><li>NCM523<ul><li>中镍电池，提供更长的续航时间</li></ul></li><li>NCM811<ul><li>高镍电池</li></ul></li></ul></li></ul><hr><h1>负极材料</h1><p>负极材料用于储存从正极迁移过来的锂离子。常用的负极材料有石墨、硅基材料等。</p><table><thead><tr><th>材料</th><th>特性</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td><strong>石墨</strong></td><td>具有层状结构，锂离子能嵌入石墨层中。</td><td>良好的导电性，较低的成本。</td><td>能量密度较低，限制了充电容量。</td></tr><tr><td><strong>硅基材料</strong></td><td>硅的能量密度高，能储存更多锂离子。</td><td>能量密度是石墨的10倍。</td><td>体积膨胀大，影响安全性和循环寿命。</td></tr></tbody></table><ul><li><strong>石墨</strong>：石墨的层状结构使其能有效地存储锂离子，常用于普通电子设备和中低端的电动汽车电池中。</li><li><strong>硅基材料</strong>：相比石墨，硅基材料具有更高的能量密度，但在充放电过程中会发生膨胀，影响电池的循环寿命和安全性。</li></ul><h2 id="石墨">石墨</h2><ul><li><p>分为<strong>天然石墨</strong>和<strong>人造石墨</strong><br>|材料 | 优点 | 缺点 | 用途 |<br>|<strong>天然石墨</strong>| 便宜量大 | 颗粒大小不一、循环性能较差| 常用于小型电池 |<br>|<strong>人造石墨</strong>| 颗粒大小均衡、循环性能较好 | 价格稍贵 | 用于新能源汽车、中高端电子设备 |</p></li><li><p>缺点：六个碳原子存储一个锂离子，导致锂离子的能量密度比较低<br><img src="..\..\img\IndustryEntry/锂电池-石墨存储锂离子结构图.png" width="100%" height="100%" align="middle"></p></li></ul><h2 id="硅基材料">硅基材料</h2><ul><li>能量密度是石墨的近10倍</li><li>在充放电过程中会发生膨胀，影响电池的循环寿命和安全性<br><img src="..\..\img\IndustryEntry/锂电池-硅负极使用中体积明显变化示意图.png" width="100%" height="100%" align="middle"></li></ul><hr><h1>隔膜</h1><p>隔膜是用于分隔正负极、避免电池短路的薄膜材料。它应具备以下特点：</p><ul><li><strong>良好的离子导电性</strong>：保证锂离子能顺利通过。</li><li><strong>高机械强度</strong>：防止在高温和充放电过程中变形。</li><li><strong>薄且具有低内阻</strong>：减少电池的能量损失。</li></ul><p>主要材料包括<strong>聚乙烯（PE）<strong>和</strong>聚丙烯（PP）</strong>。隔膜的生产工艺有<strong>干法生产</strong>和<strong>湿法生产</strong>，各有优缺点。</p><table><thead><tr><th>工艺</th><th>特性</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td><strong>干法生产</strong></td><td>利用机械拉伸形成膜结构。</td><td>制造成本较低。</td><td>可能导致膜的厚度不均匀，性能不稳定。</td></tr><tr><td><strong>湿法生产</strong></td><td>通过溶液浸渍后成膜，膜的孔隙结构均匀。</td><td>孔隙分布均匀，性能优异。</td><td>工艺复杂，成本较高。</td></tr></tbody></table><img src="..\..\img\IndustryEntry/锂电池-隔膜生产工艺.png" width="100%" height="100%" align="middle"><hr><h1>电解液</h1><p>电解液用于在电池充放电过程中提供锂离子传输通道，通常由<strong>锂盐</strong>和<strong>有机溶剂</strong>组成。</p><table><thead><tr><th>主要成分</th><th>功能</th><th>常见材料</th></tr></thead><tbody><tr><td><strong>溶质(锂盐)</strong></td><td>提供锂离子以支持电池的电荷传递。</td><td>六氟磷酸锂（LiPF6）、四氟硼酸锂（LiBF4）等</td></tr><tr><td><strong>溶剂</strong></td><td>提供锂离子在电解液中的流动性。</td><td>碳酸乙烯酯（EC）、碳酸二甲酯（DMC）等</td></tr></tbody></table><ul><li><p><strong>锂盐</strong>：是电解液的关键成分，能提供锂离子支持电池的充放电过程。</p></li><li><p><strong>溶剂</strong>：溶剂的选择影响锂离子在电解液中的移动速度及电池的性能。</p></li><li><p>还有少量添加剂，可以提升安全性、电导率等</p><ul><li>添加剂的配比是电解液供应商的机密所在</li></ul></li></ul><hr><h1>电池容量</h1><ul><li><p>由于电池内部一直在不间断进行着反应，<strong>锂离子</strong>会不可避免的与电解液中的其他物质发生反应，生产化合物，这些过程是不可逆的，导致锂离子含量会逐渐减少，电池容量也就变少了</p></li><li><p>低温</p><ul><li>电解液的粘度增加，电导率下降，锂离子的迁移速度变慢</li><li>锂离子活性降低，脱嵌能力变差，不能正确插入石墨层之间，反而累积在电池内部，容易形成<strong>锂枝晶</strong>，从而降低可用锂离子含量，甚至还能<strong>刺穿隔膜引发短路</strong></li></ul></li></ul><hr><h1>电池封装</h1><p>电池封装是将<strong>电芯</strong>组合成<strong>模组</strong>，再将模组打包成<strong>电池包</strong>的过程。常见封装方式包括<strong>圆柱形封装</strong>、<strong>方形封装</strong>和<strong>软包封装</strong>。</p><img src="..\..\img\IndustryEntry/锂电池-电池封装.png" width="100%" height="100%" align="middle"><table><thead><tr><th>封装方式</th><th>特性</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td><strong>圆柱形</strong></td><td>电芯呈圆柱形排列，标准化程度高。</td><td>标准统一，生产工艺成熟，稳定性好。</td><td>空间利用率较低，能量密度较小。</td></tr><tr><td><strong>方形</strong></td><td>电芯呈矩形排列。</td><td>空间利用率高，能量密度较大。</td><td>生产效率低，结构较复杂。</td></tr><tr><td><strong>软包</strong></td><td>电芯用铝塑膜封装，重量轻便。</td><td>质量轻，灵活性强。</td><td>极端条件下容易变形，需额外保护层。</td></tr></tbody></table><ul><li>技术革新<ul><li><strong>CTP</strong>(Cell to Pack): 将电芯直接集成到电池包内，省去模组与一部分结构件，提高了空间利用率</li><li><strong>CTC</strong>(Cell to Chassis): 将电芯、电控系统集成到地盘，实现车身与底盘的一体化设计</li></ul></li></ul><hr><h1>中国锂电池发展</h1><ul><li><p>锂电池上下游产业链<br><img src="..\..\img\IndustryEntry/锂电池-锂电池上下游产业链.png" width="100%" height="100%" align="middle"></p></li><li><p>2023年市场占有率<br><img src="..\..\img\IndustryEntry/锂电池-2023年市场占有率.png" width="100%" height="100%" align="middle"></p></li><li><p>锂电池发展历程:<br><a href="https://www.bilibili.com/video/BV15wHKepEEF/?spm_id_from=333.1007">锂电池行业快速通关</a> 16:24</p></li><li><p>中国锂电池行业的崛起经历了多年的技术积累和市场竞争。以下是中国锂电池行业的重要发展里程碑：</p><ul><li><strong>2001年</strong>：中国加入WTO后，锂电池行业迅速发展，开始国产化。</li><li><strong>2008年</strong>：我国成功突破隔膜技术，实现材料国产化。</li><li><strong>2010年</strong>：比亚迪推出自有磷酸铁锂电池，开始进入新能源汽车市场。</li><li><strong>2016年</strong>：宁德时代成为全球动力锂电池销售冠军。</li><li><strong>2021年</strong>：磷酸铁锂电池市场份额回升，超过三元锂电池。</li><li><strong>2024年</strong>：中国锂电池厂商通过投资建厂、技术创新等方式，逐步扩展国际市场</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;冬天到了，为什么电池充电时间变久了，充的电不耐用了？&lt;/p&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;参考视频: &lt;a href=&quot;https://www.bilibili.com/video/BV15wHKepEEF/?spm_id_from=333.1007&quot;&gt;锂电池行业快速通关&lt;</summary>
      
    
    
    
    <category term="行业通关" scheme="https://escapeey.cn/categories/%E8%A1%8C%E4%B8%9A%E9%80%9A%E5%85%B3/"/>
    
    
    <category term="行业通关" scheme="https://escapeey.cn/tags/%E8%A1%8C%E4%B8%9A%E9%80%9A%E5%85%B3/"/>
    
  </entry>
  
  <entry>
    <title>SD相关推荐</title>
    <link href="https://escapeey.cn/post/49df12fd.html"/>
    <id>https://escapeey.cn/post/49df12fd.html</id>
    <published>2024-11-04T16:02:38.000Z</published>
    <updated>2024-12-14T06:24:07.527Z</updated>
    
    <content type="html"><![CDATA[<h1>大模型</h1><ul><li>TMND-Mix 二次元-细节惊人</li></ul><h1>扩展插件</h1><h2 id="ADetailer-S">ADetailer (<strong>S</strong>)</h2><ul><li>自动识别面部等重点区域进行强调</li><li>模型目录: <code>根目录\models\adetailer</code></li><li>提供针对脸部的提示词窗口<ul><li><code>detailed face, close-up, portrait</code></li></ul></li><li>识别不到脸, 就尽量下降检测阈值</li><li>能感知到大概明确偏向哪边就用下面的X、Y轴偏移来进行调整</li><li>支持单独对面部的 <code>ControlNet</code>(推荐使用inPaint模型)</li></ul><h2 id="Tiled-Diffusion">Tiled Diffusion</h2><ul><li>由<code>TiledDiffusion</code>和<code>TiledVAE</code>组成</li><li><code>TiledDiffusion</code>负责扩散生成图像</li><li><code>TiledVAE</code>负责编码与解码(将图像打入/捞出潜空间)</li></ul><h3 id="参数">参数</h3><ul><li>方案: 用<code>MultiDiffusion</code></li><li>重绘幅度: 低一点(建议0.3)</li><li>放大设置：<br><img src="..\..\img\SD\TiledDiffusion放大方案一.png" width="100%" height="100%" align="middle"><br><img src="..\..\img\SD\TiledDiffusion放大方案二.png" width="100%" height="100%" align="middle"></li></ul><h3 id="Tiled-VAE">Tiled VAE</h3><ul><li>是降低显存的关键</li><li>一般<strong>维持默认参数不变</strong></li><li>只有在两种情况下改参数：<ul><li><strong>爆显存</strong>: 降低编码器分块大小</li><li>当使用的Tile太小且图片变得<strong>灰暗不清晰</strong>时: 启用<code>快速编码器颜色修复</code></li></ul></li></ul><h3 id="Tiled-Diffusion-2">Tiled Diffusion</h3><ul><li>实现大尺寸下&quot;体面&quot;重绘并还原细节<br><img src="..\..\img\SD\TiledDiffusion块设置.png" width="100%" height="100%" align="middle"></li></ul><h3 id="放大实践">放大实践</h3><p><a href="https://www.bilibili.com/video/BV1Su4y1d7Dp/?spm_id_from=333.788">6K超高清分辨率放大实践</a></p><h1>embeddings</h1><h1>LoRA</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;大模型&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;TMND-Mix 二次元-细节惊人&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;扩展插件&lt;/h1&gt;
&lt;h2 id=&quot;ADetailer-S&quot;&gt;ADetailer (&lt;strong&gt;S&lt;/strong&gt;)&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;自动识别面部等重点</summary>
      
    
    
    
    <category term="AI绘画" scheme="https://escapeey.cn/categories/AI%E7%BB%98%E7%94%BB/"/>
    
    
    <category term="AI绘画" scheme="https://escapeey.cn/tags/AI%E7%BB%98%E7%94%BB/"/>
    
  </entry>
  
  <entry>
    <title>SD学习</title>
    <link href="https://escapeey.cn/post/e5cb238c.html"/>
    <id>https://escapeey.cn/post/e5cb238c.html</id>
    <published>2024-11-02T18:13:10.000Z</published>
    <updated>2024-12-14T06:24:07.527Z</updated>
    
    <content type="html"><![CDATA[<p><strong>参考课程</strong>: <a href="https://space.bilibili.com/1814756990/channel/collectiondetail?sid=1285674">SD绘画</a><br><strong>提示词+参数+模型</strong></p><h1>提示词</h1><ul><li>tips: <strong>多多益善</strong></li><li>提示词工具网站<br><a href="http://www.atoolbox.net/Tool.php?Id=1101">提示词工具箱</a></li><li>提示词格式<ul><li>词组为单位</li><li>分隔符: &quot;, &quot;</li></ul></li></ul><h2 id="内容提示词">内容提示词</h2><h3 id="一些提示词">一些提示词</h3><ul><li>xxx in the background 可以更精确的将东西定义到&quot;背景&quot;的范围里</li><li>depth of field 景深</li></ul><h3 id="人物提示词">人物提示词</h3><ul><li>服装穿搭</li><li>发型发色</li><li>五官特点</li><li>面部表情</li><li>肢体动作</li></ul><h3 id="场景提示词">场景提示词</h3><ul><li>室内、室外(<strong>重要</strong>)<ul><li>indoor / outdoor</li></ul></li><li>大场景<ul><li>forest, city, street</li></ul></li><li>小细节<ul><li>tree, bush, white flower</li></ul></li></ul><h3 id="环境光照">环境光照</h3><ul><li>白天黑夜<ul><li>day / night</li></ul></li><li>特定时段<ul><li>morning, sunset</li></ul></li><li>光环境<ul><li>sunlight, bright, dark</li></ul></li><li>天空<ul><li>blue sky, starry sky</li></ul></li></ul><h3 id="画幅视角">画幅视角</h3><ul><li>距离<ul><li>close-up, distant</li></ul></li><li>人物比例<ul><li>full body, upper body</li></ul></li><li>观察视角<ul><li>from above, view of back</li></ul></li><li>镜头类型<ul><li>wide angle, Sony A7 3</li></ul></li></ul><h2 id="标准化提示词">标准化提示词</h2><h3 id="画质提示词">画质提示词</h3><ul><li>通用高画质<ul><li>best quality, ultra-detailed, masterpiece, hires, 8k</li></ul></li><li>特定高分辨率类型<ul><li>extremely detailed CG unity 8k wallpaper, unreal engine rendered</li></ul></li></ul><h3 id="画风提示词">画风提示词</h3><ul><li>插画风<ul><li>illustration, painting, paintbrush</li></ul></li><li>二次元<ul><li>anime, comic, game CG</li></ul></li><li>写实系<ul><li>photorealistic, realistic, photograph</li></ul></li></ul><h2 id="提示词权重">提示词权重</h2><ul><li>tips:<ul><li>尽量保持权重在<strong>1上下0.5内</strong></li><li>如果想让个别词条很突出，则建议使用多个词条，避免单一词条权重过大</li></ul></li><li>加括号<ul><li>圆括号 <strong>权重*1.1</strong><ul><li>(white flower)</li></ul></li><li>大括号 <strong>权重*1.05</strong><ul><li>{white flower}</li></ul></li><li>方括号 <strong>权重*0.9</strong><ul><li>[white flower]</li></ul></li></ul></li><li>括号加数字权重<ul><li>(white flower:1.5)</li></ul></li></ul><img src="..\..\img\SD\进阶提示词语法.png" width="100%" height="100%" align="middle"><h3 id="反向提示词">反向提示词</h3><p>标准化提示词-抄作业</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSFW, (worst quality:2), (low quality:2), (normal quality:2), lowers, normal quality, ((monochrome)), ((grayscale)), skin spots, acnes, skin blemishes, age spot, (ugly:1.331), (duplicate:1.331), (morbid:1.21), (mutilated:1.21), (tranny:1.331), mutated hands, (poorly drawn hands:1.5), blurry, (bad anatomy:1.21), (bad proportions:1.331), extra limbs, (disfigured:1.331), (missing arms:1.331), (extra legs:1.331), (fused fingers:1.61051), (too many fingers:1.61051), (unclear eyes:1.331), lowers, bad hands, missing fingers, extra digit, bad hands, missing fingers, (((extra arms and legs))),</span><br></pre></td></tr></table></figure><h1>出图参数</h1><ul><li>采样迭代步数(step)<ul><li>一般设为20</li></ul></li><li>采样方法<ul><li>用最下面带有加号的</li><li>模型一般有提示最适合自己的算法</li></ul></li><li>分辨率<ul><li>过大显存不够</li><li>过大容易出现多人、多手(一般模型训练时用的小图片, 分辨率过大会让AI认为是多个图片拼接)<ul><li><strong>避免该问题</strong>：使用低分辨率先绘制，然后用高清修复放大</li></ul></li></ul></li><li>面部修复：勾选上(类似美图P脸)</li><li>平铺：不要勾选</li><li>提示词相关性：类型权重<ul><li>7-12 较安全</li></ul></li><li>生成批次：建议多批次一起</li><li>每批数量：1</li></ul><h1>图生图</h1><p>原理：提取图像特征，并输入到网络中</p><ul><li>tips:<ul><li>一般生成的图片建议和原始图片保持相同的缩放比例</li><li>如果要不同的比例，建议用修图软件裁剪后再导入</li></ul></li></ul><h2 id="参数">参数</h2><ul><li>重绘幅度</li><li>缩放模式<ul><li>直接缩放(放大潜变量)：不建议使用</li></ul></li></ul><h1>模型</h1><h2 id="概述">概述</h2><ul><li>存储地址: <code>根目录\models\Stable-diffusion\</code></li><li>模型类型<ul><li><code>.ckpt</code></li><li><code>.safetensor</code><ul><li>占用空间小</li></ul></li></ul></li></ul><h2 id="风格分类">风格分类</h2><h3 id="二次元">二次元</h3><ul><li>搜索标签：illustration, painting, sketch, drawing, painting, comic, anime, catoon</li><li>推荐:<ul><li>Anything V5</li><li>Counterfeit V2.5<ul><li>精致，类似紫罗兰永恒花园</li></ul></li><li>Dreamlike Diffusion<ul><li>幻想系，超现实</li></ul></li></ul></li></ul><h3 id="真实系">真实系</h3><ul><li>搜索标签：photography, photo, realistic, photorealistic, RAW photo</li><li>推荐:<ul><li>Deliberate</li><li>Realistic Vision</li><li>L.O.F.I</li></ul></li></ul><h3 id="2-5D">2.5D</h3><ul><li>搜索标签：3D, render, chibi, digital art, concept art, {realistic}</li><li>推荐:<ul><li>Never Ending Dream (NED)</li><li>Protogen (Realistic)</li><li>国风3 (GuoFeng3)</li></ul></li></ul><h2 id="VAE">VAE</h2><ul><li>可以理解为AI绘画的一种<strong>调色滤镜</strong></li><li>大多数模型都将其融入大模型内了</li></ul><h2 id="Hypernetwork">Hypernetwork</h2><ul><li>存储地址: <code>根目录\models\hypernetworks\</code></li><li>使用: 在设置里找到 <strong>附加网络</strong> 选项，将对应超网络添加到提示词</li><li>类似lora, 一般用于改变画风, 小区别(类似梵高和莫奈)</li></ul><h2 id="Embeddings">Embeddings</h2><ul><li>存储地址: <code>根目录\embeddings\</code></li><li><strong>WebUI中embeddings不用特别调用，只需要用特定提示词去召唤</strong></li><li>后缀 <strong>.pt</strong></li><li>通常很小</li><li>下载模型时标签为：<strong>textual inversion</strong></li><li>不包含信息, 只是一个标记, 包含特征信息去哪里找, 类似书签</li><li>例子：<ul><li>比如Dva的embeddings 样例中用 <code>corneo_dva</code> 召唤</li><li>可以用特定的embeddings画角色图</li><li>解决画错手的问题(它是在一系列画错的上面学到的，放在负面提示词)<ul><li>Deep Negative (真人模型)</li><li>Easy Negative (二次元)</li></ul></li></ul></li></ul><h2 id="LoRA">LoRA</h2><ul><li>存储地址: <code>根目录\models\Lora</code></li><li>使用: 在提示词框里用 <code>&lt;lora:lora模型名称&gt;</code> 启用</li><li>一般要确定权重</li><li>类似彩页传单，比如要生成佩奇，它直接写明了佩奇是什么，有什么特点，怎么样呈现出佩奇</li><li>一般有一些触发词</li></ul><h2 id="导入方式">导入方式</h2><ul><li>直接放入文件夹中<ul><li>存储地址: <code>根目录\models\Lora</code></li><li>使用<code>&lt;lora:lora模型名称&gt;</code> 启用</li></ul></li><li>使用addtional network选项(额外附加网络 / 扩展模型)<ul><li>一个红色按钮</li></ul></li><li>使用<code>Addtional Network</code>扩展<ul><li>在折叠选单<code>Addtional Networks</code>中添加</li><li>存储地址: <code>根目录\extensions\sd-webui-addtional-networks\models\Lora</code></li><li>可以改为webui默认地址，将两个lora路径统一</li><li>记得勾选启用</li></ul></li></ul><h2 id="使用方法">使用方法</h2><h3 id="人物角色形象">人物角色形象</h3><ul><li>例子：制作赛博coser<ul><li>真实系大模型+lora</li></ul></li><li>有类lora会提供某类特定人物形象展示<ul><li>特定方向上的角色美化</li><li>可以当作调味剂，权重0.2-0.3</li><li>例子：<ul><li>Fashion girl 作者是使用很多个人审美的时尚女性制作的lora</li><li>Asian male 使用亚洲男性</li></ul></li></ul></li></ul><h3 id="画风或风格">画风或风格</h3><ul><li>替代Hypernetwork</li><li>如吉卜力画风lora</li><li>画风类lora比人物类lora影响更大，可以适当降低一点画风类lora的权重</li></ul><h2 id="概念图">概念图</h2><ul><li>Gacha splash LORA (立绘lora)</li><li>Anime Tarot Card Art Style LoRA (塔罗牌)</li><li>zyd232’s Stasis Pod/Chamber (密封舱)</li><li>mugshot lora (档案照片)</li><li>一定要看作者的readme</li></ul><h2 id="服饰">服饰</h2><ul><li><p>权重一定不要太高，如果太高容易没有人只有衣服(这是由训练时只用衣服导致的)</p></li><li><p>绘制特殊、具体的服饰 (比如你就要某个角色穿的衣服)</p></li><li><p>如果你想要强调某一个特质，比如机甲，可以用多个lora叠加强调</p></li><li><p>机甲衣服</p><ul><li>机甲的英文(Mecha)</li><li>推荐的checkpoint：<ul><li>二次元: Cetus-Mix</li><li>真实系: Experience</li></ul></li><li>机甲的lora</li><li>可以加一些提示词：cyberpunk、futuristic</li><li>如果要机甲与人紧密结合：robotic arms/legs、mechanical parts(机械义体)<br><img src="..\..\img\SD\机甲提示词.png" width="100%" height="100%" align="middle"></li></ul></li><li><p>推荐：</p><ul><li>hanfu 汉服</li><li>holographic clothing 镭射服装</li></ul></li></ul><h2 id="物体-特定元素">物体/特定元素</h2><ul><li>产品设计</li><li>可以使用局部重绘的方法将这些物品引入到作品内<ul><li>先画全图(不开LoRA)、再画小的(重绘)(打开LoRA)</li></ul></li><li><a href="https://www.bilibili.com/video/BV1nL411B7XT?spm_id_from=333.788">使用局部重绘引入头盔</a> 22:10</li></ul><h1>高清修复、细节优化、无损放大</h1><h2 id="高清修复-文生图">高清修复(文生图)</h2><ul><li><strong>打回重画，再来一幅</strong></li><li>别名：高分辨率修复、超分辨率(超分)</li><li><strong>tips</strong>:<ul><li>先在低分辨率下反复抽卡，抽到合适的后再固定种子，进行高清修复</li></ul></li></ul><h3 id="参数-2">参数</h3><ul><li>放大倍率</li><li>高清修复采样次数(高清修复需要在生成的图片基础上进行重绘)<ul><li>保持默认0, 表示沿用原始迭代次数</li></ul></li><li>重绘幅度：类似图生图(0.3-0.5)</li><li>重绘算法：<ul><li>无脑选  R-ESRGAN 4x+</li><li>二次元选R-ESRGAN 4x+ Anime6B</li><li>可以用作者推荐的</li></ul></li></ul><h2 id="SD放大">SD放大</h2><p>upscale放大脚本</p><ul><li>为上采样过程</li><li>将图片分成几块分别重绘，并拼在一起, 使用重叠的像素作为缓冲带</li><li>重叠的像素: 为缓冲带</li><li>开启SD放大后, <strong>最终宽高 = (设置的宽高-重叠像素) x 放大倍率</strong></li></ul><h2 id="附加功能放大-无损放大">附加功能放大(无损放大)</h2><ul><li>重绘幅度为0的高清修复</li><li><strong>不涉及再扩散</strong></li><li>类似老照片修复</li></ul><h1>局部重绘</h1><ul><li>使用蒙版</li></ul><h2 id="参数：">参数：</h2><ul><li>蒙版模式:<ul><li>重绘涂黑的 / 重绘未涂黑的</li></ul></li><li>蒙版蒙住的内容：<ul><li>一般用原图</li></ul></li><li>重绘区域:<ul><li>全图: 重绘全图，然后把蒙版部分拼回去(一般用这个)</li><li>仅蒙板: 只重绘蒙版部分(针对性比较强时用这个)</li></ul></li><li>蒙版模糊:<ul><li>类似羽化</li><li>使重绘区域拼接回去时更加自然(保持10以下)</li></ul></li></ul><h2 id="inPaint-Sketch-绘制-局部重绘-手涂蒙版">inPaint Sketch(绘制/局部重绘(手涂蒙版))</h2><ul><li><p>这里用画笔涂的就不是蒙版选区了，是真正的图形内容<br><img src="..\..\img\SD\inPaint_Sketch.png" width="100%" height="100%" align="middle"></p></li><li><p>蒙版透明度: 绘制的颜色印在画面上的显著程度(一般维持默认0,完全不透明)</p></li></ul><h2 id="inPaint-Upload-上传蒙版">inPaint Upload(上传蒙版)</h2><p><a href="https://www.bilibili.com/video/BV1uL411e7Uk/?spm_id_from=333.788">使用PS制作蒙版并上传</a> 12:34</p><h1>扩展插件</h1><ul><li>图库浏览器 image browser</li><li>LLC (Local Latent Couple)<ul><li>将部分区域变得更加精致</li><li>LLUL权重</li></ul></li><li>CutOff<ul><li>解决提示词间的互相干预</li></ul></li></ul><h1>ControlNet</h1><h2 id="基本原理">基本原理</h2><p>类似图生图<br><img src="..\..\img\SD\ControlNet结构.png" width="70%" height="70%" align="middle"></p><h2 id="安装和下载模型">安装和下载模型</h2><ul><li>需要下载模型</li><li>下载模型 <code>.pth</code> 和 对应的 <code>.yaml</code></li><li>模型地址(yaml文件也要放进去): <code>根目录\extensions\sd-webui-controlnet\models</code></li></ul><h2 id="基本使用方法">基本使用方法</h2><ul><li><p>先在ControlNet栏中导入一张图片(目标姿势图片)</p></li><li><p>再选择预处理器(Annotator)</p><ul><li>从图片中提取姿势的叫<code>Openpose</code></li></ul></li><li><p>再选择和当前预处理器匹配的<strong>控制模型</strong></p></li><li><p>PS:</p><ul><li>如果是图生图使用，则如果空着<code>ControlNet</code>栏的图片，则使用原图姿势</li><li>如果导入的是骨骼图，则在预处理器中选<strong>无</strong>, 然后使用生成骨骼图时对应的模型</li></ul></li></ul><h2 id="参数设置-控制效果的强弱">参数设置 (控制效果的强弱)</h2><ul><li><p>低显存模型 (如果cuda out of memory时用, 代价是速度慢一些)</p></li><li><p>Pixel Perfect (推荐选中)</p><ul><li>自动计算预处理器产出图像的最合适分辨率, 避免因为尺寸不合导致的图像模糊变形</li><li>不用手动设置预处理分辨率了</li></ul></li><li><p>Allow Preview 打开小的预处理器窗口</p></li><li><p>可以通过预处理器旁边的 <strong>爆炸</strong> 按钮来生成图片的<strong>骨骼图</strong></p></li><li><p>Control Weight 控制权重 (一般默认1)</p></li><li><p>Starting Control Step 控制ControlNet什么时候(迭代过程)生效</p></li><li><p>Ending Control Step 控制ControlNet什么时候(迭代过程)失效</p></li><li><p>Control Mode 控制ControlNet和提示词哪个更重要 (一般选blance)<br><img src="..\..\img\SD\ControlNet_ControlMode.png" width="70%" height="70%" align="middle"></p></li><li><p>lookback 默认关闭</p></li><li><p>其余一些参数是不同预处理器对应的，一般维持默认即可</p></li></ul><h2 id="ControlNet五大模型">ControlNet五大模型</h2><h3 id="openpose">openpose</h3><ul><li>openpose_face</li><li>openpose_faceonly (适合大头照)</li><li>openpose_hand</li><li>openpose_full (包含所有细节)</li></ul><h3 id="depth">depth</h3><p>用来对场景的还原<br><img src="..\..\img\SD\ControlNet_depth.png" width="70%" height="70%" align="middle"></p><ul><li><p>生成具有空间感的图片</p></li><li><p>可以解决肢体交叉问题, 比如手在头前还是头后 (但人体形状会非常固定)<br><img src="..\..\img\SD\ControlNet_Depth解决肢体交叠问题.png" width="70%" height="70%" align="middle"></p></li></ul><h3 id="canny">canny</h3><ul><li>使用边缘 精准的还原</li><li>如果输入图片是线稿, 用<code>inverse</code>的预处理器交换黑白</li></ul><h3 id="softedge-HED">softedge / HED</h3><ul><li>主要关注轮廓<br><img src="..\..\img\SD\ControlNet_HED和Canny的区别.png" width="70%" height="70%" align="middle"></li></ul><h3 id="scribble-涂鸦乱画">scribble(涂鸦乱画)</h3><ul><li>可以用乌龟图片生成乌龟形太空飞船</li></ul><h2 id="多重ControlNet应用">多重ControlNet应用</h2><ul><li><p>在配置里<code>ControlNet</code>选单中, 通过<code>MultiControlNet(多重ControlNet)</code>来设置最大模型数量</p></li><li><p>经典的组合 OpenPose和depth<br><a href="https://www.bilibili.com/video/BV1Ds4y1e7ZB?spm_id_from=333.788">组合解决手臂挡脸问题</a> 25:15</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;参考课程&lt;/strong&gt;: &lt;a href=&quot;https://space.bilibili.com/1814756990/channel/collectiondetail?sid=1285674&quot;&gt;SD绘画&lt;/a&gt;&lt;br&gt;
&lt;strong&gt;提示词+参数+模</summary>
      
    
    
    
    <category term="AI绘画" scheme="https://escapeey.cn/categories/AI%E7%BB%98%E7%94%BB/"/>
    
    
    <category term="AI绘画" scheme="https://escapeey.cn/tags/AI%E7%BB%98%E7%94%BB/"/>
    
  </entry>
  
  <entry>
    <title>C++-左值右值</title>
    <link href="https://escapeey.cn/post/2138c1e6.html"/>
    <id>https://escapeey.cn/post/2138c1e6.html</id>
    <published>2024-09-01T11:30:38.000Z</published>
    <updated>2024-12-14T06:24:07.526Z</updated>
    
    <content type="html"><![CDATA[<h1>左值和右值概念</h1><p>在C++中，<strong>左值</strong>（lvalue）和<strong>右值</strong>（rvalue）是两个重要的概念，它们描述了表达式中对象的不同属性。理解这些概念有助于理解变量的存储、生命周期、以及如何有效地使用C++的高级功能，如移动语义和右值引用。</p><h3 id="左值（Lvalue）">左值（Lvalue）</h3><ul><li><p><strong>定义</strong>：左值（lvalue，locatable value）是指一个有名字并且可以被取地址的对象或变量。在C++中，左值通常指的是内存中的一个对象，该对象可以持久地存在，并且能够读取或修改其值。</p></li><li><p><strong>特点</strong>：</p><ul><li>可以出现在赋值运算符的左侧或右侧。</li><li>可以通过取地址符 <code>&amp;</code> 获得其地址。</li></ul></li><li><p><strong>示例</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">10</span>;   <span class="comment">// x 是一个左值</span></span><br><span class="line"><span class="type">int</span>* p = &amp;x;  <span class="comment">// x 的地址可以被取出，因此 x 是一个左值</span></span><br></pre></td></tr></table></figure><p>在这个例子中，<code>x</code> 是一个左值，因为它是一个变量，可以通过 <code>&amp;x</code> 获取其地址。</p></li></ul><h3 id="右值（Rvalue）">右值（Rvalue）</h3><ul><li><p><strong>定义</strong>：右值（rvalue，read-only value）是指那些没有明确名字，通常是临时创建并且无法取地址的值。这些值通常在表达式计算后就会消失。</p></li><li><p><strong>特点</strong>：</p><ul><li>只能出现在赋值运算符的右侧。</li><li>无法通过取地址符 <code>&amp;</code> 获得地址。</li></ul></li><li><p><strong>示例</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> y = <span class="number">5</span> + <span class="number">3</span>; <span class="comment">// 5 + 3 是一个右值，y 是左值</span></span><br></pre></td></tr></table></figure><p>在这个例子中，<code>5 + 3</code> 的结果是一个右值，因为它是一个临时值，不存在持久的内存地址。</p></li></ul><h3 id="左值引用（Lvalue-Reference）">左值引用（Lvalue Reference）</h3><ul><li><p><strong>定义</strong>：左值引用是对左值的引用，可以通过它访问和修改所引用的对象。在C++中，左值引用的声明使用 <code>&amp;</code> 符号。</p></li><li><p><strong>特点</strong>：</p><ul><li>只能绑定到左值。</li><li>允许通过引用修改对象的值。</li></ul></li><li><p><strong>示例</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span>&amp; ref = x; <span class="comment">// ref 是 x 的左值引用</span></span><br><span class="line">ref = <span class="number">20</span>;     <span class="comment">// 通过 ref 修改 x 的值</span></span><br></pre></td></tr></table></figure><p>在这个例子中，<code>ref</code> 是一个左值引用，引用了变量 <code>x</code>。修改 <code>ref</code> 的值会直接影响到 <code>x</code>。</p></li></ul><h3 id="右值引用（Rvalue-Reference）">右值引用（Rvalue Reference）</h3><ul><li><p><strong>定义</strong>：右值引用是C++11引入的一种引用类型，允许你绑定到右值。右值引用使用 <code>&amp;&amp;</code> 符号声明，主要用于实现<strong>移动语义</strong>和<strong>完美转发</strong>。</p></li><li><p><strong>特点</strong>：</p><ul><li>只能绑定到右值（临时对象）。</li><li>可以通过右值引用转移资源（如内存、文件句柄）以避免不必要的拷贝，从而提高性能。</li></ul></li><li><p><strong>示例</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>&amp;&amp; rref = <span class="number">5</span>; <span class="comment">// rref 是一个右值引用，绑定到临时值 5</span></span><br><span class="line">rref = <span class="number">10</span>;      <span class="comment">// 可以修改右值引用绑定的临时对象</span></span><br></pre></td></tr></table></figure><p>在这个例子中，<code>rref</code> 是一个右值引用，它绑定到一个临时右值 <code>5</code>。虽然是右值，但通过引用 <code>rref</code> 可以修改这个临时对象的值。</p></li></ul><h3 id="右值引用的应用">右值引用的应用</h3><ul><li><p><strong>移动语义</strong>：右值引用主要用于实现<strong>移动构造函数</strong>和<strong>移动赋值运算符</strong>。这些操作允许在不复制对象内容的情况下转移对象的资源，从而提高程序性能。</p></li><li><p><strong>完美转发</strong>：右值引用与模板结合，可以实现函数参数的<strong>完美转发</strong>，即在保持参数的左值或右值特性的同时，转发到另一个函数。</p></li></ul><h3 id="总结">总结</h3><ul><li><strong>左值</strong>：表示内存中的持久对象，可以取地址，常用于表达式的左侧。</li><li><strong>右值</strong>：表示临时对象或字面值，无法取地址，常用于表达式的右侧。</li><li><strong>左值引用</strong>：只能绑定到左值，允许通过引用修改对象。</li><li><strong>右值引用</strong>：只能绑定到右值，主要用于移动语义和完美转发。</li></ul><p>这两个引用概念让C++程序员能够更灵活地控制对象的生命周期和资源管理，从而编写出更加高效和健壮的代码。</p><h1>完美转发</h1><p>完美转发（Perfect Forwarding）是C++11引入的一个技术，用于在模板函数中将参数“完美”地转发给另一个函数，保持其原有的左值或右值特性。这对于编写泛型代码非常有用，因为它确保了参数在被传递时不会丢失任何信息或特性，比如是否是左值、右值，或常量性。</p><h3 id="问题背景">问题背景</h3><p>在模板编程中，通常会遇到需要将参数传递给另一个函数的情况。如果直接使用普通的传递方式（例如传值或引用），可能会丢失一些信息，如参数是否是右值，或者会导致不必要的拷贝。</p><p>例如，假设我们有以下函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(<span class="type">int</span>&amp; x)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Lvalue reference&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(<span class="type">int</span>&amp;&amp; x)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Rvalue reference&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">forward_to_process</span><span class="params">(T&amp;&amp; arg)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">process</span>(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>forward_to_process</code> 是一个模板函数，用来将参数 <code>arg</code> 转发给 <code>process</code> 函数。但是，如果我们调用 <code>forward_to_process</code> 时传入一个右值，那么 <code>arg</code> 在 <code>process(arg)</code> 中会被当作左值来处理，因为 <code>arg</code> 是一个左值表达式（即使它是用右值引用类型 <code>T&amp;&amp;</code> 绑定的）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">forward_to_process(<span class="number">5</span>); <span class="comment">// 传入右值，但会调用左值引用的 process</span></span><br></pre></td></tr></table></figure><h3 id="完美转发的实现">完美转发的实现</h3><p>为了解决这个问题，C++ 提供了 <code>std::forward</code>，它可以根据模板参数的类型特性来正确地转发参数，保持其原有的左值或右值性质。</p><p>修改后的代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span> <span class="comment">// std::forward</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(<span class="type">int</span>&amp; x)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Lvalue reference&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(<span class="type">int</span>&amp;&amp; x)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Rvalue reference&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">forward_to_process</span><span class="params">(T&amp;&amp; arg)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">process</span>(std::forward&lt;T&gt;(arg)); <span class="comment">// 完美转发</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>std::forward&lt;T&gt;(arg)</code> 会根据 <code>T</code> 的类型和 <code>arg</code> 的值类别来决定如何转发：<ul><li>如果 <code>T</code> 是一个左值引用类型，<code>std::forward</code> 会将 <code>arg</code> 转发为左值。</li><li>如果 <code>T</code> 是一个右值引用类型，<code>std::forward</code> 会将 <code>arg</code> 转发为右值。</li></ul></li></ul><h3 id="使用示例">使用示例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line">forward_to_process(x);  <span class="comment">// 输出: Lvalue reference</span></span><br><span class="line">forward_to_process(<span class="number">5</span>);  <span class="comment">// 输出: Rvalue reference</span></span><br></pre></td></tr></table></figure><ul><li>当我们传递 <code>x</code> 时，由于 <code>x</code> 是一个左值，<code>std::forward&lt;T&gt;(x)</code> 会将其转发为左值引用，因此调用了 <code>process(int&amp;)</code>。</li><li>当我们传递 <code>5</code> 时，<code>5</code> 是一个右值，<code>std::forward&lt;T&gt;(5)</code> 会将其转发为右值引用，因此调用了 <code>process(int&amp;&amp;)</code>。</li></ul><h3 id="完美转发的优点">完美转发的优点</h3><ul><li><p><strong>避免不必要的拷贝</strong>：通过完美转发，可以避免在传递参数时进行不必要的拷贝或移动操作，直接传递原始参数，保留其属性。</p></li><li><p><strong>保持参数类型特性</strong>：完美转发能确保参数的类型特性（如左值或右值、常量性等）不会因为转发而丢失。</p></li><li><p><strong>提高代码的泛型性</strong>：使用完美转发，编写的模板函数能够适应更多的场景，更加通用和灵活。</p></li></ul><h3 id="总结-2">总结</h3><p>完美转发通过结合 <code>std::forward</code> 和右值引用，能够在模板函数中精确地传递参数，保留其原有的值类别和类型特性。这使得模板编程更加高效和灵活，避免了传统参数传递方式可能带来的性能损失和不必要的拷贝。</p><h1>move</h1><p><code>std::move</code> 是C++11引入的一个标准库函数，用于显式地将对象转换为右值引用，从而启用对象的移动语义。这在资源管理和性能优化方面非常重要。</p><h3 id="为什么需要-std-move">为什么需要 <code>std::move</code></h3><p>在C++中，<strong>左值</strong>（lvalue）通常是有名字的、持久存在的对象，而<strong>右值</strong>（rvalue）通常是临时对象或字面值。当函数接受一个右值引用参数时，它表示这个函数可能会“窃取”或“移动”传递给它的对象资源，而不是复制它们。</p><p>例如，如果你有一个大型对象，不想在传递它时复制其内容，那么可以使用右值引用和移动语义来避免不必要的拷贝。</p><h3 id="std-move-的作用"><code>std::move</code> 的作用</h3><p><code>std::move</code> 并不会真的移动对象，而是将对象<strong>显式地转换为右值引用</strong>。这意味着它可以将一个左值（如一个变量）强制转换为右值引用，从而告诉编译器这个对象的资源可以被“移动”而不是复制。</p><h3 id="使用-std-move-的场景">使用 <code>std::move</code> 的场景</h3><p>主要用于以下情况：</p><ol><li><strong>在移动构造函数或移动赋值运算符中</strong>：通过 <code>std::move</code>，你可以将一个对象的资源转移到另一个对象中，而不是复制它们。</li><li><strong>在返回值优化中</strong>：返回局部对象时可以使用 <code>std::move</code>，让编译器更好地优化返回值。</li></ol><h3 id="示例">示例</h3><h4 id="1-使用-std-move-实现移动语义">1. 使用 <code>std::move</code> 实现移动语义</h4><p>假设我们有一个简单的类 <code>MyClass</code>，其中包含一个大数组：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span>  <span class="comment">// 包含 std::move</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; data;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">size_t</span> size) : <span class="built_in">data</span>(size) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Constructed&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移动构造函数</span></span><br><span class="line">    <span class="built_in">MyClass</span>(MyClass&amp;&amp; other) <span class="keyword">noexcept</span> : <span class="built_in">data</span>(std::<span class="built_in">move</span>(other.data)) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Move Constructed&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 禁用复制构造函数</span></span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">const</span> MyClass&amp; other) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    MyClass&amp; <span class="keyword">operator</span>=(MyClass&amp;&amp; other) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;other) &#123;</span><br><span class="line">            data = std::<span class="built_in">move</span>(other.data);</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Move Assigned&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 禁用复制赋值运算符</span></span><br><span class="line">    MyClass&amp; <span class="keyword">operator</span>=(<span class="type">const</span> MyClass&amp; other) = <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">MyClass <span class="title">obj1</span><span class="params">(<span class="number">1000000</span>)</span></span>;          <span class="comment">// 构造 obj1</span></span><br><span class="line">    <span class="function">MyClass <span class="title">obj2</span><span class="params">(std::move(obj1))</span></span>;  <span class="comment">// 移动构造 obj2</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中：</p><ul><li><code>MyClass</code> 有一个移动构造函数，使用 <code>std::move</code> 将 <code>other.data</code> 的内容移动到当前对象中。</li><li>在 <code>main</code> 函数中，<code>obj2</code> 被移动构造。<code>std::move(obj1)</code> 将 <code>obj1</code> 转换为右值引用，因此其资源（即 <code>data</code>）被转移到 <code>obj2</code>，而不再复制 <code>data</code> 的内容。</li></ul><p>输出结果会显示对象是如何被移动构造的，而不是复制：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Constructed</span><br><span class="line">Move Constructed</span><br></pre></td></tr></table></figure><h4 id="2-避免不必要的拷贝">2. 避免不必要的拷贝</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">createVector</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">temp</span><span class="params">(<span class="number">1000</span>, <span class="number">42</span>)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">move</span>(temp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个函数中，<code>std::move(temp)</code> 将 <code>temp</code> 转换为右值引用，因此返回时不需要复制 <code>temp</code> 的内容，而是直接移动其资源。</p><h3 id="总结-3">总结</h3><ul><li><strong><code>std::move</code>的主要功能</strong>：将对象转换为右值引用，以便启用移动语义。</li><li><strong><code>std::move</code>的实际用途</strong>：常用于实现移动构造函数、移动赋值运算符，避免不必要的资源复制。</li><li><strong>注意</strong>：<code>std::move</code> 本质上并不移动对象的资源，而是将其标记为可以被“窃取”或“移动”的资源。</li></ul><p><code>std::move</code> 是实现高效 C++ 代码的重要工具，尤其是在处理大量资源时，如内存、文件句柄等。通过移动语义，程序可以避免不必要的资源开销，提高性能。</p><h1>move问题</h1><h2 id="Q">Q</h2><p>移动对象是什么意思，比如上面的obj1. data移动到obj2后，ob j1中还有原来的data吗?</p><h2 id="A">A</h2><p>当我们谈到“移动对象”时，指的是将一个对象的资源（如内存、文件句柄等）从一个对象转移到另一个对象，而不是复制这些资源。移动语义可以极大地提高程序的性能，特别是在处理大对象或资源密集型对象时。</p><h3 id="移动对象的详细解释">移动对象的详细解释</h3><p>在上面的例子中，<code>MyClass</code> 中的 <code>data</code> 是一个 <code>std::vector&lt;int&gt;</code>，它管理着一个动态分配的内存块（数组）。当我们执行移动操作时，这个内存块的所有权从一个对象转移到另一个对象，而不会实际复制这块内存。</p><h3 id="具体示例：std-move-和-obj1-obj2-的移动过程">具体示例：<code>std::move</code> 和 <code>obj1</code>, <code>obj2</code> 的移动过程</h3><p>考虑这段代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">MyClass <span class="title">obj1</span><span class="params">(<span class="number">1000000</span>)</span></span>;          <span class="comment">// 构造 obj1，obj1.data 包含 1000000 个元素</span></span><br><span class="line"><span class="function">MyClass <span class="title">obj2</span><span class="params">(std::move(obj1))</span></span>;  <span class="comment">// 将 obj1.data 移动到 obj2</span></span><br></pre></td></tr></table></figure><p>这里发生了什么：</p><ol><li><p><strong>创建 <code>obj1</code></strong>:</p><ul><li><code>obj1</code> 被构造时，它的 <code>data</code> 成员变量（一个 <code>std::vector&lt;int&gt;</code>）管理了一块内存，内存中有 <code>1000000</code> 个 <code>int</code> 类型的元素。</li><li>这些元素的值是在 <code>obj1</code> 的 <code>data</code> 中分配和管理的。</li></ul></li><li><p><strong>移动构造 <code>obj2</code></strong>:</p><ul><li>当我们使用 <code>std::move(obj1)</code> 来创建 <code>obj2</code> 时，<code>std::move</code> 将 <code>obj1</code> 转换为一个右值引用，这意味着我们告诉编译器：“我们不再需要 <code>obj1</code> 的资源了，您可以将它们转移到 <code>obj2</code> 中去。”</li><li>在 <code>obj2</code> 的移动构造函数中，<code>obj2.data = std::move(obj1.data);</code> 这个操作实际上只是转移了 <code>obj1.data</code> 中的指针或句柄，而没有复制数据。这意味着 <code>obj2</code> 现在管理着 <code>obj1</code> 原来管理的那块内存。</li><li><strong>重要</strong>：此时，<code>obj1.data</code> 中的指针被置为空，或者被设置为一种“空”状态（如一个空的 <code>std::vector</code>），因为 <code>obj1</code> 不再拥有这块内存的所有权。</li></ul></li></ol><h3 id="obj1-在移动后的状态"><code>obj1</code> 在移动后的状态</h3><ul><li><strong><code>obj1</code>的 <code>data</code></strong>：在移动之后，<code>obj1.data</code> 不再指向原来的那块内存。通常，它会被设置为一个“空”状态（如一个空的 <code>std::vector</code>）。这意味着，<code>obj1</code> 不再拥有任何元素，也不能再使用之前的资源。</li><li><strong><code>obj1</code>的有效性</strong>：<code>obj1</code> 本身仍然是有效的，但它的状态通常是“未定义的”，即不能再正常使用它的资源。特别是你不应该再期望 <code>obj1</code> 的 <code>data</code> 还有原来的数据，因为这些数据已经被移动到 <code>obj2</code> 中。</li></ul><h3 id="具体例子和输出">具体例子和输出</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span> <span class="comment">// std::move</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; data;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">size_t</span> size) : <span class="built_in">data</span>(size) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Constructed with &quot;</span> &lt;&lt; data.<span class="built_in">size</span>() &lt;&lt; <span class="string">&quot; elements.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">MyClass</span>(MyClass&amp;&amp; other) <span class="keyword">noexcept</span> : <span class="built_in">data</span>(std::<span class="built_in">move</span>(other.data)) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Move Constructed&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    MyClass&amp; <span class="keyword">operator</span>=(MyClass&amp;&amp; other) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;other) &#123;</span><br><span class="line">            data = std::<span class="built_in">move</span>(other.data);</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Move Assigned&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">MyClass <span class="title">obj1</span><span class="params">(<span class="number">1000000</span>)</span></span>;          <span class="comment">// 创建 obj1，data 包含 1000000 个元素</span></span><br><span class="line">    <span class="function">MyClass <span class="title">obj2</span><span class="params">(std::move(obj1))</span></span>;  <span class="comment">// 移动构造 obj2</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;obj1 size: &quot;</span> &lt;&lt; obj1.data.<span class="built_in">size</span>() &lt;&lt; std::endl; <span class="comment">// 通常为0</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;obj2 size: &quot;</span> &lt;&lt; obj2.data.<span class="built_in">size</span>() &lt;&lt; std::endl; <span class="comment">// 1000000</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Constructed with 1000000 elements.</span><br><span class="line">Move Constructed</span><br><span class="line">obj1 size: 0</span><br><span class="line">obj2 size: 1000000</span><br></pre></td></tr></table></figure><h3 id="关键点">关键点</h3><ul><li><strong>移动后的 <code>obj1</code></strong>：<code>obj1.data</code> 的大小变为 <code>0</code>，因为它的资源已经被移动到 <code>obj2</code>。<code>obj1</code> 不再拥有原来的数据。</li><li><strong>移动后的 <code>obj2</code></strong>：<code>obj2</code> 完全接管了 <code>obj1</code> 的数据，管理着原来那块内存。</li></ul><h3 id="总结-4">总结</h3><ul><li><strong>移动语义</strong>：通过移动语义，可以将一个对象的资源从一个对象转移到另一个对象，而不是复制这些资源。</li><li><strong>移动后的对象状态</strong>：被移动的对象（如 <code>obj1</code>）通常进入一个“空”或“未定义”状态，不能再正常使用它之前的资源。</li><li><strong>性能优化</strong>：移动语义在避免不必要的复制操作上提供了巨大的性能优势，特别是在处理大对象时。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;左值和右值概念&lt;/h1&gt;
&lt;p&gt;在C++中，&lt;strong&gt;左值&lt;/strong&gt;（lvalue）和&lt;strong&gt;右值&lt;/strong&gt;（rvalue）是两个重要的概念，它们描述了表达式中对象的不同属性。理解这些概念有助于理解变量的存储、生命周期、以及如何有效地使用C+</summary>
      
    
    
    
    <category term="C++" scheme="https://escapeey.cn/categories/C/"/>
    
    
    <category term="C++" scheme="https://escapeey.cn/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++-异步并发</title>
    <link href="https://escapeey.cn/post/36ef8af9.html"/>
    <id>https://escapeey.cn/post/36ef8af9.html</id>
    <published>2024-09-01T11:15:42.000Z</published>
    <updated>2024-12-14T06:24:07.526Z</updated>
    
    <content type="html"><![CDATA[<h1>async</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line"><span class="comment">//cout &lt;&lt; &quot;func &quot; &lt;&lt; i &lt;&lt; endl;</span></span><br><span class="line">ret++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// async 自动在后台开启线程</span></span><br><span class="line">future&lt;<span class="type">int</span>&gt; future_ret = <span class="built_in">async</span>(launch::async, func);</span><br><span class="line">cout &lt;&lt; <span class="built_in">func</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; future_ret.<span class="built_in">get</span>() &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1>packaged_task</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line"><span class="comment">//cout &lt;&lt; &quot;func &quot; &lt;&lt; i &lt;&lt; endl;</span></span><br><span class="line">ret++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// packaged 不会自动在后台开启线程</span></span><br><span class="line"><span class="function">packaged_task&lt;<span class="title">int</span><span class="params">()</span>&gt; <span class="title">task</span><span class="params">(func)</span></span>;</span><br><span class="line">future&lt;<span class="type">int</span>&gt; future_ret = task.<span class="built_in">get_future</span>();</span><br><span class="line"></span><br><span class="line"><span class="function">thread <span class="title">t1</span><span class="params">(move(task))</span></span>;</span><br><span class="line"></span><br><span class="line">t1.<span class="built_in">join</span>();</span><br><span class="line">cout &lt;&lt; future_ret.<span class="built_in">get</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1>promise</h1><h2 id="介绍promise">介绍promise</h2><p><code>std::promise</code> 是 C++ 标准库中的一个类，用于在多线程环境中实现异步操作和线程间的同步。它是 <future> 头文件的一部分，与 std::future 配合使用，提供了一个机制来在线程之间传递结果或异常。</p><h3 id="主要概念">主要概念</h3><ul><li>std::promise：用于设置一个值或异常，这个值或异常会被 std::future 读取。std::promise 可以被看作是生产者，它负责提供值或异常。</li><li>std::future：用于获取 std::promise 设置的值或异常。std::future 可以被看作是消费者，它负责接收和处理值或异常。</li></ul><h3 id="典型用法">典型用法</h3><p>std::promise 和 std::future 的常见使用场景包括：线程之间的结果传递、异步操作的实现、以及与 std::async 结合使用等。</p><h3 id="示例代码">示例代码</h3><p>以下是一个示例，演示了如何使用 std::promise 和 std::future：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;exception&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">compute</span><span class="params">(std::promise&lt;<span class="type">int</span>&gt;&amp;&amp; promise)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 进行计算</span></span><br><span class="line">        <span class="type">int</span> result = <span class="number">42</span>; <span class="comment">// 模拟计算结果</span></span><br><span class="line">        <span class="comment">// 设置值</span></span><br><span class="line">        promise.<span class="built_in">set_value</span>(result);</span><br><span class="line">    &#125; <span class="built_in">catch</span> (...) &#123;</span><br><span class="line">        <span class="comment">// 捕获异常并设置异常</span></span><br><span class="line">        promise.<span class="built_in">set_exception</span>(std::<span class="built_in">current_exception</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建 promise 和 future 对象</span></span><br><span class="line">    std::promise&lt;<span class="type">int</span>&gt; promise;</span><br><span class="line">    std::future&lt;<span class="type">int</span>&gt; future = promise.<span class="built_in">get_future</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建线程，传递 promise</span></span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">(compute, std::move(promise))</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 等待计算结果并获取值</span></span><br><span class="line">        <span class="type">int</span> result = future.<span class="built_in">get</span>();</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Result: &quot;</span> &lt;&lt; result &lt;&lt; std::endl; <span class="comment">// 输出 42</span></span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> std::exception&amp; e) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Exception: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    t.<span class="built_in">join</span>(); <span class="comment">// 等待线程结束</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="promise-的主要操作">promise 的主要操作</h3><ul><li><code>set_value(const T&amp; value)</code>：设置成功的结果。</li><li><code>set_value(T&amp;&amp; value)</code>：设置成功的结果，接受右值。</li><li><code>set_exception(std::exception_ptr e)</code>：设置异常。</li><li><code>set_value_at_thread_exit(const T&amp; value)</code>：设置线程结束时的值（此方法在 C++20 中引入）。</li></ul><h3 id="总结">总结</h3><p><code>std::promise</code> 和 <code>std::future</code> 提供了一种简洁的方式来实现线程间的结果传递和同步。std::promise 用于设置值或异常，std::future 用于获取这些值或异常。它们可以帮助你构建更复杂的异步程序，并提供了一种安全的方式来处理线程间的通信。</p><h2 id="问题一：">问题一：</h2><h3 id="Q">Q</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::future&lt;<span class="type">int</span>&gt; future = promise.<span class="built_in">get_future</span>();</span><br><span class="line"><span class="comment">// 创建线程，传递 promise</span></span><br><span class="line"><span class="function">std::thread <span class="title">t</span><span class="params">(compute, std::move(promise))</span></span>; </span><br></pre></td></tr></table></figure><p>这里移动了promise 那么在主进程中的future 还能关联到promise吗，是不是关联到了移动到 子进程里的promise</p><h3 id="A">A</h3><p>是的，当你将 <code>promise</code> 移动到子线程中时，主线程中的 <code>future</code> 仍然与原来的 <code>promise</code> 关联。这是因为 <code>std::promise</code> 和 <code>std::future</code> 之间的关联关系是在调用 <code>promise.get_future()</code> 时就已经建立的，并且这种关联关系是持久的，不会因为 <code>promise</code> 对象的移动而改变。</p><h4 id="详细解释">详细解释</h4><ol><li><p><strong>关联的建立</strong>：</p><ul><li>当你调用 <code>promise.get_future()</code> 时，<code>std::future&lt;int&gt; future</code> 就与 <code>promise</code> 关联起来了。这意味着 <code>future</code> 会等待 <code>promise</code> 设置一个值或异常。</li></ul></li><li><p><strong><code>promise</code> 的移动</strong>：</p><ul><li><code>std::promise</code> 可以被安全地移动，这是因为 <code>std::promise</code> 内部管理的资源（如与 <code>std::future</code> 的关联状态）并不会因为对象的移动而改变。</li><li>当你调用 <code>std::move(promise)</code> 时，<code>promise</code> 对象的内部状态被转移到新对象中（即子线程中的 <code>promise</code> 参数），而原来的 <code>promise</code> 对象在主线程中就变成了一个空的（无效的）状态。</li></ul></li><li><p><strong><code>future</code> 的有效性</strong>：</p><ul><li>即使 <code>promise</code> 被移动到子线程中，<code>future</code> 依然保持有效。它仍然会等待来自子线程中的 <code>promise</code> 设置的值或异常。</li><li>移动 <code>promise</code> 只是将 <code>promise</code> 的所有权转移到另一个作用域（子线程），但与 <code>future</code> 的关联性保持不变。</li></ul></li><li><p><strong>总结</strong>：</p><ul><li>移动 <code>promise</code> 不会影响 <code>future</code> 的功能，<code>future</code> 依然可以从移动后的 <code>promise</code> 中获取结果或异常。因此，<code>future.get()</code> 在主线程中仍然能够正确地获取子线程中通过移动后的 <code>promise</code> 设置的结果。</li></ul></li></ol><p>换句话说，<code>std::promise</code> 和 <code>std::future</code> 之间的关联关系是基于共享状态的，这种状态是独立于 <code>promise</code> 本身的具体位置或所有权的，所以移动 <code>promise</code> 并不会破坏这个关联。</p><h2 id="问题二">问题二</h2><h3 id="Q-2">Q</h3><p>那么在子线程中promise结束被销毁后主线程的future也就不能用了吧?</p><h3 id="A-2">A</h3><p>是的，在子线程中 <code>promise</code> 被销毁后，主线程中的 <code>future</code> 将无法再从这个 <code>promise</code> 获取到值。这是因为 <code>promise</code> 和 <code>future</code> 共享的状态一旦 <code>promise</code> 对象被销毁而没有设置任何值或异常，主线程中的 <code>future</code> 在访问时会抛出一个 <code>std::future_error</code> 异常。</p><h4 id="详细解释-2">详细解释</h4><ol><li><p><strong><code>promise</code> 和 <code>future</code> 的共享状态</strong>：</p><ul><li><code>std::promise</code> 和 <code>std::future</code> 共享一个内部状态，这个状态用于存储 <code>promise</code> 设置的值或异常。</li><li>当 <code>promise</code> 设置了值（<code>set_value()</code>）或异常（<code>set_exception()</code>）时，<code>future</code> 可以通过 <code>get()</code> 方法访问这个状态。</li></ul></li><li><p><strong><code>promise</code> 的销毁</strong>：</p><ul><li>如果 <code>promise</code> 在没有设置值或异常的情况下被销毁（即 <code>promise</code> 的析构函数被调用），那么 <code>future</code> 共享的状态会被标记为 “无效”。</li><li>在这种情况下，如果主线程中的 <code>future</code> 调用 <code>get()</code> 方法，会抛出 <code>std::future_error</code> 异常，具体来说是 <code>std::future_errc::broken_promise</code>。</li></ul></li><li><p><strong><code>promise</code> 销毁的影响</strong>：</p><ul><li>当 <code>promise</code> 被销毁后，主线程中的 <code>future</code> 就无法再获取到有效的结果。任何试图从这个 <code>future</code> 获取结果的操作都会导致异常。</li></ul></li><li><p><strong>示例代码</strong>：</p></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdexcept&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">compute</span><span class="params">(std::promise&lt;<span class="type">int</span>&gt;&amp;&amp; promise)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 不设置值，直接销毁 promise</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::promise&lt;<span class="type">int</span>&gt; promise;</span><br><span class="line">    std::future&lt;<span class="type">int</span>&gt; future = promise.<span class="built_in">get_future</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">(compute, std::move(promise))</span></span>;</span><br><span class="line"></span><br><span class="line">    t.<span class="built_in">join</span>(); <span class="comment">// 等待线程结束</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">int</span> result = future.<span class="built_in">get</span>(); <span class="comment">// 这里会抛出异常，因为 promise 被销毁</span></span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> std::future_error&amp; e) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Exception: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的示例中，因为子线程中的 <code>promise</code> 被销毁而没有设置值或异常，主线程中的 <code>future.get()</code> 调用将会抛出一个 <code>std::future_error</code> 异常，表示 “broken promise”。</p><h4 id="总结-2">总结</h4><ul><li><code>promise</code> 销毁后，如果没有设置任何值或异常，主线程中的 <code>future</code> 将无法正常工作，并且在访问时会抛出异常。</li><li>这意味着你需要确保 <code>promise</code> 在被销毁之前已经设置了一个值或异常，来保证 <code>future</code> 在主线程中的有效性。</li></ul><h2 id="问题三">问题三</h2><h3 id="Q-3">Q</h3><p>如果设置了值并销毁，为什么future还能拿到，它不是以及销毁了吗?</p><h3 id="A-3">A</h3><p>这是因为 <code>std::promise</code> 和 <code>std::future</code> 之间的共享状态是在堆上分配的，并且是独立于 <code>std::promise</code> 对象本身的生命周期的。</p><h4 id="详细解释-3">详细解释</h4><ol><li><p><strong>共享状态的分离</strong>：</p><ul><li>当你创建一个 <code>std::promise</code> 对象并调用 <code>get_future()</code> 时，<code>std::promise</code> 和 <code>std::future</code> 会共享一个内部状态（<code>shared state</code>），这个状态通常包括存储结果值、异常、以及同步机制的内容。</li><li>这个共享状态是动态分配的（通常在堆上），而不是直接存储在 <code>std::promise</code> 或 <code>std::future</code> 对象中。因此，这个状态的生命周期独立于 <code>std::promise</code> 和 <code>std::future</code> 对象本身。</li></ul></li><li><p><strong><code>promise</code> 的作用</strong>：</p><ul><li><code>std::promise</code> 的主要作用是通过 <code>set_value()</code> 或 <code>set_exception()</code> 来设置共享状态的内容。一旦这个值被设置，<code>promise</code> 对象的任务就基本完成了。</li><li>设置完成后，即使 <code>std::promise</code> 对象被销毁，存储的结果（或异常）仍然存在于共享状态中，<code>std::future</code> 仍然能够访问它。</li></ul></li><li><p><strong><code>future</code> 的行为</strong>：</p><ul><li>当你在主线程中使用 <code>future.get()</code> 时，它从共享状态中检索结果值或异常，而不是直接从 <code>promise</code> 对象中获取。</li><li>因为共享状态在 <code>promise</code> 对象销毁后依然存在，所以 <code>future.get()</code> 可以在 <code>promise</code> 销毁后仍然正常工作。</li></ul></li></ol><h4 id="示例代码-2">示例代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">compute</span><span class="params">(std::promise&lt;<span class="type">int</span>&gt;&amp;&amp; promise)</span> </span>&#123;</span><br><span class="line">    promise.<span class="built_in">set_value</span>(<span class="number">42</span>); <span class="comment">// 设置值</span></span><br><span class="line">    <span class="comment">// promise 对象即将被销毁</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::promise&lt;<span class="type">int</span>&gt; promise;</span><br><span class="line">    std::future&lt;<span class="type">int</span>&gt; future = promise.<span class="built_in">get_future</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">(compute, std::move(promise))</span></span>;</span><br><span class="line"></span><br><span class="line">    t.<span class="built_in">join</span>(); <span class="comment">// 等待线程结束</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 即使 promise 对象已销毁，future 仍能从共享状态中获取值</span></span><br><span class="line">    <span class="type">int</span> result = future.<span class="built_in">get</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Result: &quot;</span> &lt;&lt; result &lt;&lt; std::endl; <span class="comment">// 输出：Result: 42</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结-3">总结</h4><ul><li>当 <code>std::promise</code> 设置了值后，它的内部共享状态将包含这个值，即使 <code>promise</code> 对象本身被销毁，这个值仍然存在于共享状态中。</li><li><code>std::future</code> 在访问结果时，实际是从共享状态中获取数据，而不是直接依赖于 <code>promise</code> 对象的存在。这就是为什么即使 <code>promise</code> 被销毁了，<code>future</code> 仍然能够获取到先前设置的值。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;async&lt;/h1&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;b</summary>
      
    
    
    
    <category term="C++" scheme="https://escapeey.cn/categories/C/"/>
    
    
    <category term="C++" scheme="https://escapeey.cn/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++-线程池</title>
    <link href="https://escapeey.cn/post/41fb03b2.html"/>
    <id>https://escapeey.cn/post/41fb03b2.html</id>
    <published>2024-09-01T10:31:54.000Z</published>
    <updated>2024-12-14T06:24:07.526Z</updated>
    
    <content type="html"><![CDATA[<h1>涉及知识点</h1><ul><li>mutex</li><li>lock</li><li>lamda表达式</li><li>队列queue</li><li>emplace</li><li>可变参数</li><li>模板函数</li><li>万能引用</li><li>左值引用</li><li>右值引用</li><li>完美转发forward</li><li>函数适配器bind</li><li>时间库chrono</li></ul><h1>代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadPool</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">ThreadPool</span>(<span class="type">int</span> numThreads): <span class="built_in">stop</span>(<span class="literal">false</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numThreads; i++) &#123;</span><br><span class="line">threads.<span class="built_in">emplace_back</span>([<span class="keyword">this</span>] &#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">function&lt;<span class="built_in">void</span>()&gt; task;</span><br><span class="line">&#123;</span><br><span class="line">unique_lock&lt;mutex&gt; <span class="built_in">lock</span>(mtx);</span><br><span class="line">condition.<span class="built_in">wait</span>(lock, [<span class="keyword">this</span>] &#123;</span><br><span class="line"><span class="keyword">return</span> !tasks.<span class="built_in">empty</span>() || stop;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">if</span> (stop &amp;&amp; tasks.<span class="built_in">empty</span>()) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">task = <span class="built_in">move</span>(tasks.<span class="built_in">front</span>());</span><br><span class="line">tasks.<span class="built_in">pop</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">task</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~<span class="built_in">ThreadPool</span>() &#123;</span><br><span class="line">&#123;</span><br><span class="line"><span class="function">unique_lock&lt;mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">stop = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">condition.<span class="built_in">notify_all</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; t : threads) &#123;</span><br><span class="line">t.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> F, <span class="keyword">class</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">enqueue</span><span class="params">(F &amp;&amp; f, Args&amp;&amp;... args)</span> </span>&#123;</span><br><span class="line">function&lt;<span class="type">void</span>()&gt;task = <span class="built_in">bind</span>(forward&lt;F&gt;(f), forward&lt;Args&gt;(args)...);</span><br><span class="line">&#123;</span><br><span class="line"><span class="function">unique_lock&lt;mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">tasks.<span class="built_in">emplace</span>(<span class="built_in">move</span>(task));</span><br><span class="line">&#125;</span><br><span class="line">condition.<span class="built_in">notify_one</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">vector&lt;thread&gt; threads;</span><br><span class="line">queue&lt;function&lt;<span class="type">void</span>()&gt; &gt; tasks;</span><br><span class="line"></span><br><span class="line">mutex mtx;</span><br><span class="line">condition_variable condition;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> stop;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">ThreadPool <span class="title">pool</span><span class="params">(<span class="number">4</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">12</span>; i++) &#123;</span><br><span class="line">pool.<span class="built_in">enqueue</span>([i] &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;task : &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;is running !&quot;</span>&lt;&lt;endl;</span><br><span class="line">this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">seconds</span>(<span class="number">2</span>));</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;task : &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;is close !&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;涉及知识点&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;mutex&lt;/li&gt;
&lt;li&gt;lock&lt;/li&gt;
&lt;li&gt;lamda表达式&lt;/li&gt;
&lt;li&gt;队列queue&lt;/li&gt;
&lt;li&gt;emplace&lt;/li&gt;
&lt;li&gt;可变参数&lt;/li&gt;
&lt;li&gt;模板函数&lt;/li&gt;
&lt;li&gt;万能引用&lt;/l</summary>
      
    
    
    
    <category term="C++" scheme="https://escapeey.cn/categories/C/"/>
    
    
    <category term="C++" scheme="https://escapeey.cn/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++-线程安全</title>
    <link href="https://escapeey.cn/post/b0174cac.html"/>
    <id>https://escapeey.cn/post/b0174cac.html</id>
    <published>2024-08-01T11:42:34.000Z</published>
    <updated>2024-12-14T06:24:07.526Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://www.seestudy.cn/?list_9/35.html">参考博客</a></p><h1>thread</h1><h2 id="int">int</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span>&amp; x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">x += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="function">thread <span class="title">t1</span><span class="params">(func, ref(a))</span></span>;</span><br><span class="line">t1.<span class="built_in">join</span>();</span><br><span class="line">cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="类">类</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Hello !&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 智能指针 当当前变量不再被需要时 自动释放</span></span><br><span class="line">shared_ptr&lt;A&gt; a = <span class="built_in">make_shared</span>&lt;A&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function">thread <span class="title">t</span><span class="params">(&amp;A::func, a)</span></span>;</span><br><span class="line">t.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1>mutex</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">timed_mutex mtx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span>&amp; x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line"><span class="function">unique_lock&lt;timed_mutex&gt; <span class="title">lg</span><span class="params">(mtx, defer_lock)</span></span>;</span><br><span class="line"><span class="keyword">if</span> (lg.<span class="built_in">try_lock_for</span>(chrono::<span class="built_in">seconds</span>(<span class="number">2</span>))) &#123;</span><br><span class="line">x++;</span><br><span class="line">this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line"><span class="function">thread <span class="title">thread1</span><span class="params">(func, ref(n))</span></span>;</span><br><span class="line"><span class="function">thread <span class="title">thread2</span><span class="params">(func, ref(n))</span></span>;</span><br><span class="line">thread1.<span class="built_in">join</span>();</span><br><span class="line">thread2.<span class="built_in">join</span>();</span><br><span class="line">cout &lt;&lt; n &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>unique_lock shard_lock</h1><h1>condition_variable</h1><h2 id="生产者-消费者">生产者 消费者</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">mutex mtx;</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; mque;</span><br><span class="line">condition_variable cg;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">productor</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line"><span class="function">unique_lock&lt;mutex&gt; <span class="title">ul</span><span class="params">(mtx)</span></span>;</span><br><span class="line">mque.<span class="built_in">push</span>(i);</span><br><span class="line">cg.<span class="built_in">notify_one</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;生产了&quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">microseconds</span>(<span class="number">100</span>));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">consumer</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"><span class="function">unique_lock&lt;mutex&gt; <span class="title">ul</span><span class="params">(mtx)</span></span>;</span><br><span class="line">cg.<span class="built_in">wait</span>(ul, []() &#123;<span class="keyword">return</span> !mque.<span class="built_in">empty</span>(); &#125;);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> value = mque.<span class="built_in">front</span>();</span><br><span class="line">mque.<span class="built_in">pop</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;消费了&quot;</span>&lt;&lt;value&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">thread <span class="title">prod</span><span class="params">(productor)</span></span>;</span><br><span class="line"><span class="function">thread <span class="title">cons</span><span class="params">(consumer)</span></span>;</span><br><span class="line"></span><br><span class="line">prod.<span class="built_in">join</span>();</span><br><span class="line">cons.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>atomic</h1><p>原子操作 比 加锁 效率高</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">atomic&lt;<span class="type">int</span>&gt; shared_data = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000000</span>; i++) &#123;</span><br><span class="line">shared_data++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">thread <span class="title">t1</span><span class="params">(func)</span></span>;</span><br><span class="line"><span class="function">thread <span class="title">t2</span><span class="params">(func)</span></span>;</span><br><span class="line">t1.<span class="built_in">join</span>();</span><br><span class="line">t2.<span class="built_in">join</span>();</span><br><span class="line"><span class="comment">//store load 操作 可以保证原子性</span></span><br><span class="line">shared_data.<span class="built_in">store</span>(<span class="number">1</span>);</span><br><span class="line">cout &lt;&lt; shared_data.<span class="built_in">load</span>() &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;http://www.seestudy.cn/?list_9/35.html&quot;&gt;参考博客&lt;/a&gt;&lt;/p&gt;
&lt;h1&gt;thread&lt;/h1&gt;
&lt;h2 id=&quot;int&quot;&gt;int&lt;/h2&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;</summary>
      
    
    
    
    <category term="C++" scheme="https://escapeey.cn/categories/C/"/>
    
    
    <category term="C++" scheme="https://escapeey.cn/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>计网优秀博客收藏</title>
    <link href="https://escapeey.cn/post/8d32812f.html"/>
    <id>https://escapeey.cn/post/8d32812f.html</id>
    <published>2024-07-16T15:11:19.000Z</published>
    <updated>2024-12-14T06:24:07.529Z</updated>
    
    <content type="html"><![CDATA[<h1>学习建议</h1><p><a href="https://mp.weixin.qq.com/s?__biz=MzI0NDc3ODE5OQ==&amp;mid=2247488726&amp;idx=1&amp;sn=52b1e3c7932aa8a717661663acadc91d&amp;chksm=e959c16ede2e48784bdc118694c1b40dc20f907542d41ec305211e39efd4f3c411fc854777bb&amp;scene=178&amp;cur_album_id=1677418448106143748#rd">如何构建计算机网络知识体系</a></p><h1>基础知识点</h1><p><a href="https://mp.weixin.qq.com/s?__biz=MzI0NDc3ODE5OQ==&amp;mid=2247483833&amp;idx=1&amp;sn=b9e1af65bdd6d663060bb1cbc44ab3dd&amp;chksm=e959d401de2e5d17ed27203d439a20df99f9de0beb877073725a98f2eae2ac563741a34670fb&amp;scene=178&amp;cur_album_id=1677418448106143748#rd">两台计算机之间是如何通信的</a></p><p><a href="https://mp.weixin.qq.com/s?__biz=MzI0NDc3ODE5OQ==&amp;mid=2247484306&amp;idx=1&amp;sn=0498760c107b773d01a79c340c7f3fcd&amp;scene=21#wechat_redirect">IP协议精讲</a></p><p><a href="https://mp.weixin.qq.com/s?__biz=MzI0NDc3ODE5OQ==&amp;mid=2247484446&amp;idx=1&amp;sn=d5c82d41de69f507a2e59f3fb6074d7a&amp;chksm=e959d1a6de2e58b0600525cbc92e843f560a3ae8de4c09d2cd916f43ea2ff2eb767220f2fbef&amp;scene=178&amp;cur_album_id=1677418448106143748#rd">ARP协议精讲</a></p><p><a href="https://mp.weixin.qq.com/s?__biz=MzI0NDc3ODE5OQ==&amp;mid=2247484021&amp;idx=1&amp;sn=62ecef5d4b08b542056f2f614f5fb4b6&amp;scene=21#wechat_redirect">TCP 三次握手和四次挥手</a></p><p><a href="https://mp.weixin.qq.com/s?__biz=MzI0NDc3ODE5OQ==&amp;mid=2247484407&amp;idx=1&amp;sn=44688d37144e4b65d59bf37a90945f0a&amp;chksm=e959d64fde2e5f59ac0471a359c308d14c289600cb12341ae739c6677b6f1cb209b0a2d4c1c1&amp;scene=178&amp;cur_album_id=1677418448106143748#rd">DNS协议解析</a></p><p><a href="https://mp.weixin.qq.com/s?__biz=MzI0NDc3ODE5OQ==&amp;mid=2247484533&amp;idx=1&amp;sn=015674c8b75933e27111fad6a13b22d4&amp;chksm=e959d1cdde2e58dbfb219a22e14485bac3d70924d76b42a534cc6c667e3f7a5874c80b06407c&amp;scene=178&amp;cur_album_id=1677418448106143748#rd">HTTP协议</a></p><p><a href="https://mp.weixin.qq.com/s?__biz=MzI0NDc3ODE5OQ==&amp;mid=2247486703&amp;idx=1&amp;sn=6a7c5518b78e593e73b587a49dfb4695&amp;chksm=e959d957de2e5041ebed1b08a53cc8d0eba9ad5ff8630c65fc5c93fb446bbe4afd0a6fbb24cd&amp;scene=178&amp;cur_album_id=1677418448106143748#rd">ICMP协议</a></p><p><a href="https://mp.weixin.qq.com/s?__biz=MzI0NDc3ODE5OQ==&amp;mid=2247487338&amp;idx=1&amp;sn=e5bf451ad638e504edbf9c40aa596ae2&amp;chksm=e959dad2de2e53c460bcc3b9d7d3c0e8eb234f57398e867d10eb3f6eb43d75e6b1f142a0abc8&amp;scene=178&amp;cur_album_id=1677418448106143748#rd">DHCP协议</a></p><p><a href="https://mp.weixin.qq.com/s?__biz=MzI0NDc3ODE5OQ==&amp;mid=2247491297&amp;idx=1&amp;sn=24ca974567e890e4735af6033a59760e&amp;chksm=e959cb59de2e424f6d42a55556452f2f523f0fe6756392dde1fc6923c4decf35fd1bdff73298&amp;scene=178&amp;cur_album_id=1677418448106143748#rd">滑动窗口协议</a></p><h1>面试</h1><p><a href="https://cloud.tencent.com/developer/article/1793846">在浏览器中输入网址后回车发生了什么</a></p><p><a href="https://mp.weixin.qq.com/s?__biz=MzI0NDc3ODE5OQ==&amp;mid=2247486620&amp;idx=1&amp;sn=86e1ca0047c0759e14a24b9e059a81b8&amp;chksm=e959d924de2e5032acfa72023823aac41972e993abca93eac8152226a0617001343a08740b88&amp;scene=178&amp;cur_album_id=1677418448106143748#rd">为什么DNS协议使用UDP</a></p><p><a href="https://mp.weixin.qq.com/s?__biz=MzI0NDc3ODE5OQ==&amp;mid=2247492034&amp;idx=1&amp;sn=7621ba55a60a55fa10936771beb4b0e4&amp;chksm=e95a347ade2dbd6c172c93c89a9dbafc6d4e6563031032b7368d7e59a23bd334256502b964e6&amp;scene=178&amp;cur_album_id=1677418448106143748#rd">DDos攻击</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;学习建议&lt;/h1&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI0NDc3ODE5OQ==&amp;amp;mid=2247488726&amp;amp;idx=1&amp;amp;sn=52b1e3c7932aa8a717661663acad</summary>
      
    
    
    
    <category term="计算机网络" scheme="https://escapeey.cn/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机网络" scheme="https://escapeey.cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>OSI七层参考模型</title>
    <link href="https://escapeey.cn/post/fa35e9d3.html"/>
    <id>https://escapeey.cn/post/fa35e9d3.html</id>
    <published>2024-07-16T09:23:17.000Z</published>
    <updated>2024-12-14T06:24:07.529Z</updated>
    
    <content type="html"><![CDATA[<p><strong>参考网址</strong>：</p><ul><li><a href="https://blog.csdn.net/xx16755498979/article/details/132489516">https://blog.csdn.net/xx16755498979/article/details/132489516</a></li></ul><h1>OSI七层参考模型</h1><h2 id="物理层">物理层</h2><ul><li>主要定义物理设备标准，如网线接口类型、传输介质的传输速率等。</li><li>作用：传输比特流（数模转换和模数转换）</li><li>数据：<strong>比特</strong></li></ul><h2 id="数据链路层">数据链路层</h2><ul><li>定义如何让格式化数据以<strong>帧</strong>为单位进行传输，以及如何控制对物理介质的访问，用MAC地址访问介质。</li><li>作用：建立逻辑连接、进行<strong>硬件地址寻址</strong>、差错校验</li><li>数据：<strong>帧</strong></li></ul><h2 id="网络层">网络层</h2><ul><li>进行逻辑地址寻址</li><li>作用：在位于不同地理位置的网络中的两个主机系统之间提供连接和路径选择。</li></ul><h2 id="传输层">传输层</h2><ul><li>定义了一些传输数据的协议和端口号(WWW端口80)，如TCP、UDP。</li><li>作用：将从下层接收的数据进行分段和传输，到达目的地址后再进行重组。</li><li>数据：<strong>段</strong></li></ul><h2 id="会话层">会话层</h2><ul><li>通过传输层(端口号：传输端口与接收端口)建立数据传输的通路。</li><li>作用:再系统之间发起会话或者接受会话请求</li></ul><h2 id="表示层">表示层</h2><ul><li>数据的表示、安全、压缩</li><li>作用: 进行对接收的数据进行解释、加密与解密、压缩与解压缩(把计算机能识别的东西转换为人能识别的东西，如图片、声音等)</li></ul><h2 id="应用层">应用层</h2><ul><li>网络服务与最终用户的一个接口</li><li>作用：为用户的应用程序提供网络服务</li></ul><h1>数据链路层</h1><ul><li>数据链路层是TCP/IP网络模型的第二层，基于物理层和网络层之间，数据链路层在物理层提供的服务的基础上向网络层提供服务</li><li>其最基本的服务是将源自物理层来的数据可靠地传输到<strong>相邻节点</strong>的目标机网络层。</li></ul><h2 id="ARP协议">ARP协议</h2><ul><li>ARP协议是数据进行网络传输过程中，通过IP地址向MAC地址的转换，解决网络层和物理层衔接问题</li></ul><h3 id="引入ARP协议的目的：">引入ARP协议的目的：</h3><p>由于 IP 地址和 MAC 地址定位方式不同，ARP 协议成为数据传输的必备协议。主机发送信息前，必须通过 ARP 协议获取目标 IP 地址对应的 MAC 地址，才能正确地发送数据包。</p><h3 id="ARP的工作流程：">ARP的工作流程：</h3><ul><li>主机A以广播的形式向该网段内的所有主机发送ARP请求，请求中包含了目的主机的IP地址</li><li>主机B接收到请求，通过请求中的目的IP地址发现自己是主机A要找的，返回响应，响应包括主机B的 MAC地址</li></ul><h3 id="ARP缓存：">ARP缓存：</h3><ul><li><p>在请求目标主机的 MAC 地址时，每次获取目标主机 MAC 地址都需要发送一次 ARP 请求，然后根据响应获取到 MAC 地址。</p></li><li><p>为了避免重复发送 ARP 请求，每台主机都有一个 ARP 高速缓存。当主机得到 ARP 响应后，将目标主机的 IP 地址和物理地址存入本机 ARP 缓存中，并保留一定时间。</p></li><li><p>只要在这个时间范围内，下次请求 MAC 地址时，直接查询 ARP 缓存，而无须再发送 ARP 请求，从而节约了网络资源。</p></li></ul><h1>网络层</h1><ul><li>网络层是基于数据链路层和传输层之间的第三层协议，它在数据链路层提供的两个相邻端点之间的数据帧的传送功能上，进一步管理网络中的数据通信，将数据设法从源端经过若干个中间节点传送到目的端，从而向传输层提供最基本的端到端的数据传送服务</li><li>网络层的目的是实现两个端系统之间的数据透明传送，具体功能包括寻址和路由选择、连接的建立、保持和终止等。它提供的服务使传输层不需要了解网络中的数据传输和交换技术。</li></ul><h2 id="IP协议">IP协议</h2><ul><li><p>IP协议是TCP/IP网络模型中的核心部分，他提供了一种分层的、无关硬件的寻址方式，可以在复杂的路由式网络中传递数据所需的服务</p></li><li><p>IP协议可以将多个交换网络连接起来，在源地址和目的地址之间传输数据包，同时它还能提供数据的组装功能，以适应不同网络对数据包大小的要求</p></li></ul><h3 id="预研知识">预研知识</h3><blockquote><p><strong>IP地址</strong>：<br>IP地址是互联网协议特有的一种地址，它是IP协议提供的一种统一的地址格式，IP地址为互联网的每个网络和每台主机分配了一个逻辑地址，以此来屏蔽物理地址的差异</p></blockquote><blockquote><p><strong>IP地址的格式</strong>：<br>IP地址为32位地址，被分为4个部分，<a href="http://xn--XXX-eo8e.XXX.XXX.XXX">如XXX.XXX.XXX.XXX</a>，IP地址又被划分为两个部分<br><strong>网络号</strong>：前三部分用于标识网段，保证相互连接的两个网段有不同标识<br><strong>主机号</strong>：由最后一部分组成，用于标识主机，保证处于同一网段的两台主机有不同的主机号<br>通过合理设置主机号和网络号, 就可以保证在相互连接的网络中, 每台主机的IP地址都不相同4</p></blockquote><blockquote><p><strong>MAC地址</strong>：<br>被称为物理地址，是用来标识网络中每个设备的，MAC地址是设备出厂之后就写死的</p></blockquote><h3 id="引入IP地址的目的：">引入IP地址的目的：</h3><ul><li>在<strong>单个局域网网段</strong>中，计算机与计算机之间可以使用数据链路层提供的MAC地址进行通信</li><li>如果在<strong>路由式网络</strong>中，计算机之间就不能用MAC地址实现通信，主要是因为在路由式网络中，数据只是经过一次简单的利用两个计算机之间的MAC地址建立通信，而是<strong>需要进行多次的通信</strong>，每次跳转都会体目的主机更近一步，经历都次跳转，最终找到目的主机实现通信，而这个过程中，<strong>要知道每次向哪跳转才能更接近目的主机，必须使用一种逻辑化、层次化的寻址方案对网络进行组织</strong>，这就是 IP 地址</li></ul><h3 id="IP协议的工作方式：">IP协议的工作方式：</h3><p>由于网络分为同网段和不同网段，所以会分成两种方式</p><h4 id="同网段：">同网段：</h4><p>如果源地址主机和目的地址主机处于同一网段，则目的IP地址被 ARP协议 解析为MAC地址后，源主机会根据目的MAC地址直接将数据包发送给目的主机</p><h4 id="不同网段-先上后下-：">不同网段(先上后下)：</h4><p>如果源地址主机和目的地址主机不处于同一网段，则数据包会经历多个过程最终发送给目的主机</p><ol><li><strong>网关</strong>(一般为路由器)的 IP地址 被 ARP协议 解析为 MAC地址，根据该 MAC地址 源主机会将数据包发送到网关</li><li>网关根据数据包中的网段ID找到目标网络，如果找到，将数据包发送给目标网路，如果没有则<strong>重复第一步发送到更高一级网关</strong></li><li>数据包经过网关发送到正确的网段后，目标IP被 ARP协议 解析为MAC地址，在根据该 MAC地址 将数据包发送给目标地址的主机</li></ol><h2 id="ICMP协议">ICMP协议</h2><ul><li>ICMP协议又叫控制报文协议，ICMP协议用于在IP 和 路由器之间传递控制消息，描述网络是否通畅、主机是否可达、路由器是否可用等网络状态，ICMP本身并不传输数据，但对于用户间数据的传递起着重要的作用</li><li>作用：<br>在数据包从源主机传输到目的主机的过程中，会经历一个或多个路由器，而数据包在经过这些路由器传输过程中，可能会遇到很多问题，最终导致数据包没有成功传递给目的主机。为了了解数据包在传输过程中在哪个环节出了问题，就需要用到ICMP协议，它可以跟踪数据包，并把消息返回给源主机</li></ul><h1>传输层协议</h1><h1></h1>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;参考网址&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/xx16755498979/article/details/132489516&quot;&gt;https://blog.csdn.net/xx16755</summary>
      
    
    
    
    <category term="计算机网络" scheme="https://escapeey.cn/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机网络" scheme="https://escapeey.cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>C++-模板</title>
    <link href="https://escapeey.cn/post/db164a07.html"/>
    <id>https://escapeey.cn/post/db164a07.html</id>
    <published>2024-07-01T11:35:11.000Z</published>
    <updated>2024-12-14T06:24:07.526Z</updated>
    
    <content type="html"><![CDATA[<h1>模板概念</h1><p>C++ 模板（Templates）是 C++ 中一种强大的工具，用于实现泛型编程。模板允许编写与类型无关的代码，从而可以重用代码，并在编译时生成特定类型的代码。这种机制可以用于函数、类和别名模板等。</p><h3 id="1-什么是模板？">1. 什么是模板？</h3><p>模板是一种用于创建通用代码的机制，它允许我们编写一次代码，然后用不同的数据类型来使用它，而不需要重复编写相同的逻辑。例如，可以使用模板创建一个可以处理 <code>int</code>、<code>double</code>、<code>char</code> 等类型的函数或类。</p><h3 id="2-函数模板">2. 函数模板</h3><p>函数模板是用于生成可以接受不同类型参数的函数的模板。其语法如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">add</span><span class="params">(T a, T b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个示例中：</p><ul><li><code>template&lt;typename T&gt;</code> 声明了一个模板，<code>T</code> 是一个占位符类型。</li><li><code>add</code> 函数的参数类型和返回类型都是 <code>T</code>，这意味着它可以处理任何类型的数据，只要这些数据支持 <code>+</code> 操作符。</li></ul><h4 id="函数模板的使用">函数模板的使用</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">10</span>, y = <span class="number">20</span>;</span><br><span class="line">    <span class="type">double</span> a = <span class="number">1.5</span>, b = <span class="number">2.5</span>;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">add</span>(x, y) &lt;&lt; std::endl; <span class="comment">// 输出 30</span></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">add</span>(a, b) &lt;&lt; std::endl; <span class="comment">// 输出 4.0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在编译时，编译器会根据调用 <code>add</code> 函数时传递的参数类型来实例化模板，为 <code>int</code> 和 <code>double</code> 类型生成对应的函数。</p><h3 id="3-类模板">3. 类模板</h3><p>类模板允许我们创建能够处理不同类型数据的类。其语法如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    T value;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">MyClass</span>(T v) : <span class="built_in">value</span>(v) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">T <span class="title">getValue</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在这个示例中：</p><ul><li><code>template&lt;typename T&gt;</code> 声明了一个类模板。</li><li><code>MyClass</code> 是一个模板类，其中 <code>T</code> 是一个占位符类型，代表可以由用户指定的任何类型。</li><li><code>value</code> 成员变量和 <code>getValue</code> 函数的返回类型都依赖于 <code>T</code>。</li></ul><h4 id="类模板的使用">类模板的使用</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">MyClass&lt;<span class="type">int</span>&gt; <span class="title">obj1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="function">MyClass&lt;<span class="type">double</span>&gt; <span class="title">obj2</span><span class="params">(<span class="number">3.14</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; obj1.<span class="built_in">getValue</span>() &lt;&lt; std::endl; <span class="comment">// 输出 10</span></span><br><span class="line">    std::cout &lt;&lt; obj2.<span class="built_in">getValue</span>() &lt;&lt; std::endl; <span class="comment">// 输出 3.14</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当创建 <code>MyClass&lt;int&gt;</code> 时，<code>T</code> 被替换为 <code>int</code>；创建 <code>MyClass&lt;double&gt;</code> 时，<code>T</code> 被替换为 <code>double</code>。这意味着可以用相同的类模板处理不同类型的数据。</p><h3 id="4-模板的特化">4. 模板的特化</h3><p>模板特化允许我们为特定类型提供专门的实现。它分为<strong>完全特化</strong>和<strong>部分特化</strong>。</p><h4 id="4-1-完全特化">4.1 完全特化</h4><p>完全特化是为某个特定的类型提供模板的特定实现。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>&lt;<span class="type">char</span>&gt; &#123; <span class="comment">// 为 char 类型提供特化版本</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">char</span> value;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">char</span> v) : <span class="built_in">value</span>(v) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">char</span> <span class="title">getValue</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Char value: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="4-2-部分特化">4.2 部分特化</h4><p>部分特化是为某些类型提供特定的实现，而不是为所有类型。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>&lt;T*&gt; &#123; <span class="comment">// 为指针类型提供特化版本</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    T* value;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">MyClass</span>(T* v) : <span class="built_in">value</span>(v) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">T* <span class="title">getValue</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="5-模板的使用场景">5. 模板的使用场景</h3><ul><li><strong>通用算法</strong>：如排序、搜索等算法可以使用模板来处理不同类型的数据。</li><li><strong>容器类</strong>：如 <code>std::vector</code>、<code>std::list</code>、<code>std::map</code> 等 STL 容器类都是模板类，它们可以存储不同类型的数据。</li><li><strong>智能指针</strong>：如 <code>std::unique_ptr</code>、<code>std::shared_ptr</code>，它们是模板类，可以管理不同类型的资源。</li></ul><h3 id="6-模板的限制与注意事项">6. 模板的限制与注意事项</h3><ul><li><strong>编译时间增长</strong>：模板的实例化发生在编译时，因此可能导致编译时间增长。</li><li><strong>错误信息复杂</strong>：模板编程的错误信息有时非常复杂，难以理解和调试。</li><li><strong>代码膨胀</strong>：如果使用大量的模板实例化，可能导致编译出来的二进制文件变大。</li></ul><h3 id="7-进阶：模板编程中的一些重要概念">7. 进阶：模板编程中的一些重要概念</h3><h4 id="7-1-模板元编程（Template-Metaprogramming）">7.1 模板元编程（Template Metaprogramming）</h4><p>模板元编程是一种编写在编译时执行计算的代码的技术。例如，可以使用模板计算在编译时的常量，或进行条件编译。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="type">int</span> N&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Factorial</span> &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> value = N * Factorial&lt;N - <span class="number">1</span>&gt;::value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Factorial</span>&lt;<span class="number">0</span>&gt; &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> value = <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Factorial of 5: &quot;</span> &lt;&lt; Factorial&lt;<span class="number">5</span>&gt;::value &lt;&lt; std::endl; <span class="comment">// 输出120</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7-2-SFINAE（Substitution-Failure-Is-Not-An-Error）">7.2 SFINAE（Substitution Failure Is Not An Error）</h4><p>SFINAE 是模板编程中的一个重要概念，它指的是在模板参数替换过程中发生的错误不会导致编译失败，而是编译器会继续尝试其他重载版本或特化版本。</p><h3 id="总结">总结</h3><p>模板是 C++ 中的一项强大特性，能够实现泛型编程，允许编写与类型无关的代码。通过函数模板和类模板，可以编写更加通用和灵活的代码。模板特化提供了针对特定类型的优化实现，而模板元编程更是扩展了编译期计算的可能性。尽管模板编程复杂，但它在提高代码重用性和效率方面具有重要作用。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;模板概念&lt;/h1&gt;
&lt;p&gt;C++ 模板（Templates）是 C++ 中一种强大的工具，用于实现泛型编程。模板允许编写与类型无关的代码，从而可以重用代码，并在编译时生成特定类型的代码。这种机制可以用于函数、类和别名模板等。&lt;/p&gt;
&lt;h3 id=&quot;1-什么是模板？&quot;&gt;1</summary>
      
    
    
    
    <category term="C++" scheme="https://escapeey.cn/categories/C/"/>
    
    
    <category term="C++" scheme="https://escapeey.cn/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>单调栈</title>
    <link href="https://escapeey.cn/post/16518a5d.html"/>
    <id>https://escapeey.cn/post/16518a5d.html</id>
    <published>2024-05-31T22:53:22.000Z</published>
    <updated>2024-12-14T06:24:07.526Z</updated>
    
    <content type="html"><![CDATA[<h1>单调栈</h1><h2 id="单调栈分为单调递增栈和单调递减栈">单调栈分为单调递增栈和单调递减栈</h2><pre><code>- 单调递增栈即栈内元素保持单调递增的栈- 同理单调递减栈即栈内元素保持单调递减的栈</code></pre><h2 id="操作规则（下面都以单调递增栈为例）">操作规则（下面都以单调递增栈为例）</h2><ul><li><p>如果新的元素比栈顶元素大，就入栈</p></li><li><p>如果新的元素较小，那就一直把栈内元素弹出来，直到栈顶比新元素小</p></li><li><p>效果</p><ul><li>栈内的元素是递增的</li><li>当元素出栈时，说明这个<strong>新元素</strong>是出栈元素<strong>向后</strong>找第一个比其小的元素</li></ul><blockquote><p>举个例子，配合下图，现在索引在 6 ，栈里是 1 5 6 。<br>接下来新元素是 2 ，那么 6 需要出栈。<br>当 6 出栈时，右边 2 代表是 6 右边第一个比 6 小的元素。</p></blockquote><ul><li>当元素出栈后，说明<strong>新栈顶元素</strong>是<strong>出栈元素</strong>向前找第一个比其小的元素</li></ul><blockquote><p>当 6 出栈时，5 成为新的栈顶，那么 5 就是 6 左边第一个比 6 小的元素。</p></blockquote></li></ul><h1>模板</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">stack&lt;<span class="type">int</span>&gt; st;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(!st.<span class="built_in">empty</span>() &amp;&amp; st.<span class="built_in">top</span>() &gt; nums[i])</span><br><span class="line">&#123;</span><br><span class="line">st.<span class="built_in">pop</span>();</span><br><span class="line">&#125;</span><br><span class="line">st.<span class="built_in">push</span>(nums[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1>例题</h1><h2 id="84-柱状图中最大的矩形：">84 柱状图中最大的矩形：</h2><p><a href="https://leetcode.cn/problems/largest-rectangle-in-histogram/description/">https://leetcode.cn/problems/largest-rectangle-in-histogram/description/</a></p><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">largestRectangleArea</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; heights)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        heights.<span class="built_in">insert</span>(heights.<span class="built_in">begin</span>(), <span class="number">0</span>);</span><br><span class="line">        heights.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; st;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;heights.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(!st.<span class="built_in">empty</span>() &amp;&amp; heights[st.<span class="built_in">top</span>()] &gt; heights[i])&#123; </span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="85-最大矩形">85 最大矩形</h2><p><a href="https://leetcode.cn/problems/maximal-rectangle/description/">https://leetcode.cn/problems/maximal-rectangle/description/</a></p><p>代码:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maximalRectangle</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">heights</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;matrix.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;n; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(matrix[i][j] == <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">                    heights[j] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    heights[j]++;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, <span class="built_in">maxRectangle</span>(heights));</span><br><span class="line">            heights.<span class="built_in">pop_back</span>();</span><br><span class="line">            heights.<span class="built_in">erase</span>(heights.<span class="built_in">begin</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxRectangle</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; heights)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        heights.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">        heights.<span class="built_in">insert</span>(heights.<span class="built_in">begin</span>(), <span class="number">0</span>);</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; st;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;heights.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(!st.<span class="built_in">empty</span>() &amp;&amp; heights[st.<span class="built_in">top</span>()] &gt; heights[i])&#123;</span><br><span class="line">                <span class="type">int</span> height = heights[st.<span class="built_in">top</span>()];</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="type">int</span> left = st.<span class="built_in">top</span>() + <span class="number">1</span>;</span><br><span class="line">                <span class="type">int</span> right = i - <span class="number">1</span>;</span><br><span class="line">                ret = <span class="built_in">max</span>(ret, height * (right - left + <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            st.<span class="built_in">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;单调栈&lt;/h1&gt;
&lt;h2 id=&quot;单调栈分为单调递增栈和单调递减栈&quot;&gt;单调栈分为单调递增栈和单调递减栈&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;- 单调递增栈即栈内元素保持单调递增的栈
- 同理单调递减栈即栈内元素保持单调递减的栈
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;操作</summary>
      
    
    
    
    <category term="Algorithm" scheme="https://escapeey.cn/categories/Algorithm/"/>
    
    
    <category term="Algorithm" scheme="https://escapeey.cn/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>编译原理-语法制导翻译与属性文法</title>
    <link href="https://escapeey.cn/post/bb02e719.html"/>
    <id>https://escapeey.cn/post/bb02e719.html</id>
    <published>2024-05-30T15:51:18.000Z</published>
    <updated>2024-12-14T06:24:07.529Z</updated>
    
    <content type="html"><![CDATA[<h1>语法制导翻译概述</h1><p>语法分析的基础上，根据源程序中各语法结构的语义进行翻译<br>编译器一般先将经过语法分析后的源程序翻译成某种形式的中间代码</p><h2 id="语义分析器的主要任务">语义分析器的主要任务</h2><p>检查各个语法结构的静态语义，即<strong>验证语法正确的程序结构是否真正有意义</strong>，也称为<strong>静态语义分析</strong>或<strong>静态检查</strong></p><ul><li><strong>类型检查</strong>：操作数和操作符的类型是否相容；</li><li><strong>控制流检查</strong>：控制流转向目标地址是否合法；</li><li><strong>唯一性检查</strong>：对象是否被重复定义；</li><li><strong>关联名检查</strong>：同一名字多次特定出现是否一致。</li></ul><p>将<strong>静态检查</strong>和<strong>中间代码生成</strong>结合到<strong>语法分析</strong>中进行的技术称为<strong>语法制导翻译</strong> (syntax-directed translation)</p><h2 id="语法制导翻译的基本思想">语法制导翻译的基本思想</h2><ul><li>在进行语法分析的同时，完成相应的<strong>语义处理</strong></li><li>一旦语法分析器识别出一个语法结构（例如E-&gt;E+T）就要立即对其进行<strong>翻译</strong>。</li><li>翻译是根据语言的语义进行的，并通过调用事先为该<strong>语法结构</strong>编写的<strong>语义子程序</strong>来实现。</li><li>对文法中的每个产生式附加一个/多个语义动作(或<strong>语义子程序</strong>)</li><li>在语法分析的过程中，每当需要使用一个产生式进行<strong>推导或归约</strong>时，语法分析程序除执行相应的<strong>语法分析动作</strong>外，还要执行相应的语义动作(或<strong>调用相应的语义子程序</strong>)</li></ul><h2 id="语义子程序的功能">语义子程序的功能</h2><ul><li>指明相应产生式中各个<strong>文法符号的具体含义</strong>，并规定了使用该产生式进行分析时所应采取的<strong>语义动作</strong>。</li><li>语义信息是通过文法符号来携带和传递的。</li></ul><h2 id="属性">属性</h2><ul><li>一个<strong>文法符号X</strong>所携带的<strong>语义信息</strong>称为X的<strong>语义属性</strong>，简称为<strong>属性</strong><ul><li>文法符号的<strong>属性的计算规则</strong>称为<strong>语义规则</strong></li><li>一个变量的属性有类型、值和存储地址等</li></ul></li></ul><h1>语法制导定义</h1><h1>属性计算</h1><h1>翻译模式</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;语法制导翻译概述&lt;/h1&gt;
&lt;p&gt;语法分析的基础上，根据源程序中各语法结构的语义进行翻译&lt;br&gt;
编译器一般先将经过语法分析后的源程序翻译成某种形式的中间代码&lt;/p&gt;
&lt;h2 id=&quot;语义分析器的主要任务&quot;&gt;语义分析器的主要任务&lt;/h2&gt;
&lt;p&gt;检查各个语法结构的静态语义</summary>
      
    
    
    
    <category term="编译原理" scheme="https://escapeey.cn/categories/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
    
    <category term="编译原理" scheme="https://escapeey.cn/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Git指令集</title>
    <link href="https://escapeey.cn/post/f38ad9ef.html"/>
    <id>https://escapeey.cn/post/f38ad9ef.html</id>
    <published>2024-05-22T22:24:07.000Z</published>
    <updated>2024-12-14T06:24:07.527Z</updated>
    
    <content type="html"><![CDATA[<img src="..\img\git\远程仓库操作.png" width="100%" height="100%" align="middle"><h1>初始化设置</h1><p>配置<strong>用户名</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name <span class="string">&quot;Your Name&quot;</span></span><br></pre></td></tr></table></figure><p>配置邮箱</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.email <span class="string">&quot;mail@example.com&quot;</span></span><br></pre></td></tr></table></figure><p><strong>存储</strong>配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global credential.helper store</span><br></pre></td></tr></table></figure><h1>创建仓库</h1><p><strong>创建</strong>一个新的本地仓库 （ 省略 <code>project-name </code> 则在当前目录创建）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init &lt;project-name&gt;</span><br></pre></td></tr></table></figure><p><strong>克隆</strong>一个远程仓库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> &lt;url&gt;</span><br></pre></td></tr></table></figure><h1>四个区域</h1><h3 id="工作区-Working-Directory">工作区(Working Directory)</h3><p>就是你在电脑里能<strong>实际看到的目录</strong>。</p><h3 id="暂存区（Stage-Index）">暂存区（<strong>Stage/Index</strong>）</h3><p>暂存区也叫索引， 用来临时存放<strong>未提交</strong>的内容， 一般在 <code>.git</code> 目录下的 <code>index</code> 中。</p><h3 id="本地仓库（-Repository）">**本地仓库（**Repository）</h3><p>Git在<strong>本地的版本库</strong>， 仓库信息存储在  <code>.git</code> 这个隐藏目录中。</p><h3 id="远程仓库（-Remote-Repository）">**远程仓库（**Remote Repository）</h3><p>托管在<strong>远程服务器</strong>上的仓库。 常用的有GitHub、 GitLab、 Gitee。</p><h2 id="对于区域和分支的问题">对于区域和分支的问题</h2><ul><li><p>当对文件做出改动时，<strong>工作区和暂存区</strong>对所有分支都是可见的；</p></li><li><p>但当在某个分支提交后，则该改动<strong>只能在该提交的分支查看</strong>到，并且 <code>ls</code> 和 <code>ls-files</code> 都只能在<strong>当前分支</strong>中看到<strong>该改动</strong>，别的分支看不到</p></li></ul><p><strong>查看</strong>当前分支当前<strong>工作区</strong>的文件列表</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span></span><br></pre></td></tr></table></figure><p><strong>查看</strong>当前分支当前<strong>暂存区</strong>文件列表</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git ls-files</span><br></pre></td></tr></table></figure><h1>文件状态</h1><h3 id="已修改（Modified）">已修改（<strong>Modified</strong>）</h3><p><strong>修改了</strong>但是<strong>没有保存</strong>到暂存区的文件。</p><h3 id="已暂存（Staged）">已暂存（<strong>Staged</strong>）</h3><p><strong>修改后</strong>已经<strong>保存到暂存区</strong>的文件。</p><h3 id="已提交（Committed）">已提交（Committed）</h3><p>把暂存区的文件<strong>提交到本地仓库</strong>后的状态。</p><h1>基本概念</h1><ul><li><strong><code>main / master</code></strong> 默认主分支</li><li><strong><code>origin</code></strong>        默认远程仓库</li><li><strong><code>HEAD</code></strong>        指向<strong>当前分支</strong>的指针</li><li><strong><code>HEAD^</code></strong>      上一个版本</li><li><strong><code>HEAD~4</code></strong>            上4个版本</li></ul><h1>特殊文件</h1><ul><li><strong><code>.git</code></strong> Git仓库的<strong>元数据</strong>和对象数据库</li><li><strong><code>.gitignore</code></strong>    <strong>忽略文件</strong>，不需要提交到仓库的文件</li><li><strong><code>.gitattributes</code></strong>   指定文件的属性，比如换行符</li><li><strong><code>.gitkeep</code></strong>    使空目录被提交到仓库</li><li><strong><code>.gitmodules</code></strong>      记录子模块的信息</li><li><strong><code>.gitconfig</code></strong>    记录仓库的配置信息</li></ul><h1>添加和提交</h1><p><strong>添加</strong>一个文件到暂存区</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add &lt;file&gt;</span><br></pre></td></tr></table></figure><p>添加所有文件到暂存区</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br></pre></td></tr></table></figure><p><strong>提交</strong>所有暂存区的文件到仓库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m <span class="string">&quot;message&quot;</span></span><br></pre></td></tr></table></figure><p>提交所有已修改的文件到仓库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -am <span class="string">&quot;message&quot;</span></span><br></pre></td></tr></table></figure><h1>分支</h1><p>查看所有<strong>本地分支</strong>，当前分支钱前面会有一个 <code>*</code> , <code>-r</code> 查看远程分支， <code>-a</code> 查看所有分支</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch</span><br></pre></td></tr></table></figure><p><strong>创建</strong>一个新分支</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch &lt;branch-name&gt;</span><br></pre></td></tr></table></figure><p><strong>删除</strong>一个已经合并的分支</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -d &lt;branch-name&gt;</span><br></pre></td></tr></table></figure><p><strong>删除</strong>一个分支，不管是否合并</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -D &lt;branch-name&gt;</span><br></pre></td></tr></table></figure><p><strong>切换</strong>到指定分支，<strong>并更新</strong>工作区</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout &lt;branch-name&gt;</span><br></pre></td></tr></table></figure><p><strong>创建</strong>一个新分支，<strong>并切换</strong>到该分支</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b &lt;branch-name&gt;</span><br></pre></td></tr></table></figure><p>给当前的提交打上标签，通常用于版本发布</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag &lt;tag-name&gt;</span><br></pre></td></tr></table></figure><h1>合并分支</h1><p>合并分支a到分支b</p><p><code>-no-ff</code> 参数表示禁用 <code>Fast forward</code> 模式，合并后的历史有分支，能看出曾经做过合并</p><p><code>-ff</code> 参数表示使用 <code>Fast forward</code> 模式，合并后的历史会变成一条直线</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge --no-ff -m <span class="string">&quot;message&quot;</span> &lt;branch-name&gt;</span><br></pre></td></tr></table></figure><img src="..\img\git\合并分支1.png" width="100%" height="100%" align="middle"><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge --ff -m <span class="string">&quot;message&quot;</span> &lt;branch-name&gt;</span><br></pre></td></tr></table></figure><img src="..\img\git\合并分支2.png" width="100%" height="100%" align="middle"><p>合并&amp;<code>squash</code>所有提交到一个提交</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge --squash &lt;branch-name&gt;</span><br></pre></td></tr></table></figure><p><code>rebase</code> 不会产生新的提交，而是把当前分支的每一个提交都&quot;复制&quot;到目标分支上，然后再把当前分支指向目标分支</p><p><code>merge</code> 会产生一个新的提交，这个提交有两个分支的所有修改</p><p><strong>Rebase</strong></p><p><code>Rebase</code> 操作可以把本地未push的分支提交历史整理成直线，看起来更直观。但是，如果多人协作时，不要对已经推送到远程的分支执行 <code>Rebase</code> 操作</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout &lt;dev&gt;</span><br><span class="line">git rebase &lt;main&gt;</span><br></pre></td></tr></table></figure><img src="..\img\git\合并分支3.png" width="100%" height="100%" align="middle"><h1>撤销</h1><p>移动一个文件到新的位置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">mv</span> &lt;file&gt; &lt;new-file&gt;</span><br></pre></td></tr></table></figure><p>从工作区和暂存区中删除一个文件，然后暂存删除操作</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">rm</span> &lt;file&gt;</span><br></pre></td></tr></table></figure><p>只从暂存区中删除一个文件，工作区中的文件没有变化</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">rm</span> --cached &lt;file&gt;</span><br></pre></td></tr></table></figure><p>恢复一个文件到之前的版本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout &lt;file&gt; &lt;commit-id&gt;</span><br></pre></td></tr></table></figure><p>提交一个新的提交，用来撤销指定的提交，后者的所有变化都将被前者抵消，并且应用到当前分支</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git revert &lt;commit-id&gt;</span><br></pre></td></tr></table></figure><p>重置当前分支的 <code>HEAD</code> 为之前的某个提交，并且删除所有之后的提交。</p><ul><li><p><code>--hard</code> 参数表示重置工作区和暂存区</p></li><li><p><code>--soft</code> 参数表示重置暂存区</p></li><li><p><code>--mixed</code> 参数表示重置工作区</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --mixed &lt;commit-id&gt;</span><br></pre></td></tr></table></figure><p>撤销暂存区的文件，重新放回工作区 （<code>git add</code> 的反向操作）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git restore --staged &lt;file&gt;</span><br></pre></td></tr></table></figure><h1>查看</h1><p>列出还未提交的新的或修改的文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure><p>查看提交历史, <code>--oneline</code>可简略查看</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> --oneline</span><br></pre></td></tr></table></figure><p>查看未暂存的文件更新了哪些部分</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff</span><br></pre></td></tr></table></figure><p>查看两个提交之间的差异</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff &lt;commit-id&gt; &lt;commit-id&gt;</span><br></pre></td></tr></table></figure><h1>Stash</h1><p><code>Stash</code> 操作可以把当前工作现场&quot;储藏&quot;起来，等以后<strong>恢复现场</strong>后继续工作。</p><p><code>-u</code> 参数表示把当前所有 <strong>未跟踪</strong> 的文件也一并存储</p><p><code>-a</code> 参数表示把所有 <strong>未跟踪</strong> 的文件和 <strong>忽略</strong> 的文件也一并存储</p><p><code>save</code> 参数表示存储的信息，可以不写</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash save <span class="string">&quot;message&quot;</span></span><br></pre></td></tr></table></figure><p>查看所有 <code>stash</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash list</span><br></pre></td></tr></table></figure><p>恢复最近一次 <code>stash</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash pop</span><br></pre></td></tr></table></figure><p>恢复指定的 <code>stash</code>, <code>stash@&#123;2&#125;</code>  表示第三个 <code>stash</code> , <code>stash@&#123;0&#125;</code> 表示最近的 <code>stash</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash pop stash@&#123;2&#125;</span><br></pre></td></tr></table></figure><p>重新接受最近一次 <code>stash</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash apply</span><br></pre></td></tr></table></figure><p><code>pop</code> 和 <code>apply</code> 的区别时，<code>pop</code> 会把 <code>stash</code> 内容删除，而 <code>apply</code> 不会。</p><p>可以用 <code>git stash drop</code> 来删除 <code>stash</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash drop stash@&#123;2&#125;</span><br></pre></td></tr></table></figure><p>删除所有 <code>stash</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash clear</span><br></pre></td></tr></table></figure><h1>远程仓库</h1><p>添加远程仓库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add &lt;remote-name&gt; &lt;remote-url&gt;</span><br></pre></td></tr></table></figure><p>查看远程仓库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote -v</span><br></pre></td></tr></table></figure><p>删除远程仓库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote <span class="built_in">rm</span> &lt;remote-name&gt;</span><br></pre></td></tr></table></figure><p>重命名远程仓库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote rename &lt;old-name&gt; &lt;new-name&gt;</span><br></pre></td></tr></table></figure><p>查看远程分支</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -r</span><br></pre></td></tr></table></figure><h2 id="拉取">拉取</h2><ul><li><p><code>git fetch</code>是将远程主机的最新内容拉到本地，用户在检查了以后决定是否合并到工作本机分支中。</p></li><li><p><code>git pull</code> 则是将远程主机的最新内容拉下来后直接合并，即：<code>git pull = git fetch + git merge</code>，这样可能会产生冲突，需要手动解决。</p></li></ul><p>从远程仓库<strong>拉取</strong>代码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull &lt;remote-name&gt; &lt;branch-name&gt;</span><br></pre></td></tr></table></figure><p><code>fetch</code> 默认远程仓库 <code>(origin)</code> 当前分支的代码，然后合并到本地分支</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull</span><br></pre></td></tr></table></figure><p>将本地改动的代码 <code>rebase</code> 到远程仓库的最新代码上（ 为了有一个干净、 线性的提交历史）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull --rebase</span><br></pre></td></tr></table></figure><p>获取所有远程分支</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch &lt;remote-name&gt;</span><br></pre></td></tr></table></figure><p><code>fetch</code> 某一个特定的远程分支</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch &lt;remote-name&gt; &lt;branch-name&gt;</span><br></pre></td></tr></table></figure><h2 id="推送">推送</h2><p><strong>推送</strong>代码到远程仓库 (然后再发起 <code>pull request</code> )</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push &lt;remote-name&gt; &lt;branch-name&gt;</span><br></pre></td></tr></table></figure><h1>GitFlow</h1><p><strong>GitFlow</strong> 是一种流程模型，用于在Git上管理软件开发项目</p><h3 id="主分支-master-main">主分支 (master/main)</h3><p>代表了项目的稳定版本，每个提交到主分支的代码都应该是经过<strong>测试和审核</strong>的。</p><h3 id="开发分支-develop">开发分支 (develop)</h3><p>用于<strong>日常开发</strong>。所有的功能分支、发布分支和修补分支都应该从开发分支派生出来。</p><h3 id="功能分支-feature">功能分支 (feature)</h3><p>用于开发<strong>单独的功能或者特性</strong>。每个功能分支都应该从开发分支派生，并在开发完成后合并回开发分支。</p><h3 id="发布分支-release">发布分支 (release)</h3><p>用于<strong>准备项目发布</strong>。发布分支应从开发分支派生，并在准备好发布版本后合并回主分支和开发分支。</p><h3 id="热修复分支-hotfix">热修复分支 (hotfix)</h3><p>用于<strong>修复</strong>主分支上的紧急问题。热修复分支应该从主分支派生，并在修复完成后，合并回主分支和开发分支。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;img src=&quot;..&#92;img&#92;git&#92;远程仓库操作.png&quot; width=&quot;100%&quot; height=&quot;100%&quot; align=&quot;middle&quot;&gt;
&lt;h1&gt;初始化设置&lt;/h1&gt;
&lt;p&gt;配置&lt;strong&gt;用户名&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;high</summary>
      
    
    
    
    <category term="工具" scheme="https://escapeey.cn/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="工具" scheme="https://escapeey.cn/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>编译原理-自顶向下的语法分析</title>
    <link href="https://escapeey.cn/post/cf412c72.html"/>
    <id>https://escapeey.cn/post/cf412c72.html</id>
    <published>2024-05-21T13:28:07.000Z</published>
    <updated>2024-12-14T06:24:07.529Z</updated>
    
    <content type="html"><![CDATA[<h1>语法分析概述</h1><p>语法分析的主要工作是根据<strong>源语言</strong>的文法，判别某个<strong>单词序列</strong>是否是源语言的一个<strong>句子</strong></p><ul><li><strong>语言</strong>是满足一定<strong>组成规则</strong>的<strong>句子集合</strong></li><li><strong>句子</strong>是满足一定<strong>组成规则</strong>的<strong>单词序列</strong></li><li><strong>单词</strong>则是满足一定<strong>组成规则</strong>的<strong>字符串</strong></li><li>这些<strong>组成规则</strong>就是文法中的<strong>产生式</strong></li></ul><h2 id="两种方式">两种方式</h2><ul><li><strong>产生句子</strong>的方式：从文法的开始符号开始，逐步<strong>推导</strong>出这个单词序列，也称为<strong>自顶向下</strong>的语法分析<ul><li>递归子程序法</li><li>预测分析法(LL(1))</li></ul></li><li><strong>识别句子</strong>的方式：逐步将构成程序的单词序列<strong>归约</strong>为文法的<strong>开始符号</strong>，也称为<strong>自底向上</strong>的语法分析<ul><li>算符优先分析法</li><li>LR(0)、SLR(1)、LR(1)、LALR(1)</li></ul></li></ul><p>无论是自顶向下还是自底向上，语法分析器都是<strong>自左到右</strong>地扫描输入<strong>单词序列</strong>，每次读入一个单词，针对输入单词序列<strong>建立一颗语法分析树</strong><br>不同的分析方法对应着<strong>不同的构建树的方式</strong></p><h2 id="语法分析时的恢复策略">语法分析时的恢复策略</h2><ul><li><strong>紧急方式恢复策略</strong>：丢弃输入记号，直到发现某个指定的同步记号为止。同步记号通常是定界符（分号或end标记），标志着一条新语句的开始。</li><li><strong>短语级恢复策略</strong>：对剩余输入做局部纠正</li></ul><h1>自顶向下的语法分析面临的问题</h1><ul><li><strong>基本思想</strong>:<ul><li>从文法的开始符号出发，寻求所给的输入符号串的一个<strong>最左推导</strong>。</li><li>即从树根S开始，构造所给输入符号串的<strong>语法树</strong></li></ul></li><li>自顶向下分析实际上是一种<strong>试探性</strong>的过程，可能导致分析效率极低甚至失败</li><li>面临三种问题</li></ul><h2 id="二义性问题">二义性问题</h2><p>解决方法1：改造文法，引入新的文法变量<br>解决办法2：根据优先级关系，保证<strong>高优先级运算符优先</strong>的原则</p><h2 id="左递归引起的无穷推导问题">左递归引起的无穷推导问题</h2><ul><li><strong>左递归</strong>: 如果存在推导 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><msup><mo>⇒</mo><mo>+</mo></msup><mi>α</mi><mi>A</mi><mi>β</mi></mrow><annotation encoding="application/x-tex">A \Rightarrow^+ \alpha A\beta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7713em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel"><span class="mrel">⇒</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7713em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">+</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span></span></span></span>，则称文法G是递归的，当 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi><mo>=</mo><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\alpha = \epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">ϵ</span></span></span></span> 时称之为左递归；</li><li><strong>间接左递归</strong>: 如果 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><msup><mo>⇒</mo><mo>+</mo></msup><mi>α</mi><mi>A</mi><mi>β</mi></mrow><annotation encoding="application/x-tex">A \Rightarrow^+ \alpha A\beta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7713em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel"><span class="mrel">⇒</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7713em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">+</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span></span></span></span>至少需要两步推导，则称文法G是间接递归的，当 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi><mo>=</mo><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\alpha = \epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">ϵ</span></span></span></span> 时称之为间接左递归；</li><li><strong>直接左递归</strong>: 如果文法G中存在形如 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>→</mo><mi>α</mi><mi>A</mi><mi>β</mi></mrow><annotation encoding="application/x-tex">A \rightarrow \alpha A\beta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span></span></span></span>的产生式，则称文法G是直接递归的，当 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi><mo>=</mo><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\alpha = \epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">ϵ</span></span></span></span> 时称之为直接左递归。</li></ul><h2 id="回溯问题">回溯问题</h2><ul><li>文法中每个语法变量A的产生式右部称为A的<strong>候选式</strong></li><li>如果A有多个候选式存在<strong>公共前缀</strong>，则自顶向下的语法分析程序将无法根据当前输入符号准确地选择用于推导的产生式，只能试探。</li><li>当试探不成功时就需要退回到上一步推导，看A是否还有其它的候选式，这就是<strong>回溯</strong>(backtracking)。</li></ul><p>我们将采用提取左因子的方法来改造文法，以便减少推导过程中回溯现象的发生<br>当然，单纯通过提取左因子无法彻底避免回溯现象的发生。</p><h1>对上下文无关文法的改造</h1><h2 id="消除二义性">消除二义性</h2><p>改造的方法就是通过<strong>引入新的语法变量</strong>等，使文法含有更多的信息。</p><h3 id="二义性举例：">二义性举例：</h3><img src="..\..\img\CompilerPrinciples\二义性文法举例.png" width="100%" height="100%" align="middle"><p><strong>分析：</strong><br>根据if语句中else与then配对情况将其分为<strong>配对的语句</strong>和<strong>不配对的语句</strong>两类。<br>上述if语句的文法没有对这两个不同的概念加以区分，只是简单地将它们都定义为&lt;stmt&gt;，从而导致该文法是二义性的<br><strong>解决：</strong><br><img src="..\..\img\CompilerPrinciples\二义性文法举例解决.png" width="100%" height="100%" align="middle"></p><h2 id="消除左递归">消除左递归</h2><h3 id="消除直接左递归">消除直接左递归</h3><ul><li>直接左递归的消除(转换为右递归)</li><li>引入新的变量<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>A</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">A&#x27;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7519em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span> ，将左递归产生式<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>→</mo><mi>A</mi><mi>α</mi><mi mathvariant="normal">∣</mi><mi>β</mi></mrow><annotation encoding="application/x-tex">A\rightarrow A\alpha | \beta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span></span></span></span> 替换为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>→</mo><mi>β</mi><msup><mi>A</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">A\rightarrow \beta A&#x27;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.9463em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>A</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo>→</mo><mi>α</mi><msup><mi>A</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mi mathvariant="normal">∣</mi><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">A&#x27; \rightarrow \alpha A&#x27; | \epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7519em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0019em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mord">∣</span><span class="mord mathnormal">ϵ</span></span></span></span><br><img src="..\..\img\CompilerPrinciples\消除左递归1.png" width="100%" height="100%" align="middle"></li></ul><h3 id="具体做法">具体做法</h3><img src="..\..\img\CompilerPrinciples\消除左递归2.png" width="100%" height="100%" align="middle"><ul><li>上述方法<strong>只能消除直接</strong>左递归，<strong>无法消除间接</strong>左递归</li><li>消除<strong>间接左递归</strong>的<strong>基本思想</strong>：为语法<strong>变量编号</strong>，再采用<strong>带入法</strong>将<strong>间接左递归变为直接左递归</strong>，然后采用上述方法来消除直接左递归</li></ul><h3 id="消除所有左递归">消除所有左递归</h3><img src="..\..\img\CompilerPrinciples\消除左递归算法.png" width="100%" height="100%" align="middle"><img src="..\..\img\CompilerPrinciples\消除左递归算法例子.png" width="100%" height="100%" align="middle"><h2 id="提取左因子（解决回溯问题）">提取左因子（解决回溯问题）</h2><p><strong>方法：</strong><br><img src="..\..\img\CompilerPrinciples\提取左因子.png" width="100%" height="100%" align="middle"><br>提取左因子并不能完全消除回溯</p><p><strong>例子：</strong><br><img src="..\..\img\CompilerPrinciples\提取左因子例子.png" width="100%" height="100%" align="middle"></p><h1>LL(1)文法</h1><ul><li><strong>不确定</strong>的自顶向下分析<ul><li>分析需要回溯，导致分析存在不确定性</li><li>代价高、效率低，实际中几乎不被采用</li></ul></li><li><strong>确定</strong>的自顶向下分析<ul><li>不能处理所有文法，这里讨论什么样的文法可以进行确定的自顶向下分析</li></ul></li><li>LL(1)文法就是可以<strong>彻底消除回溯</strong>实现<strong>确定的</strong>自顶向下分析的文法</li><li>文法要求：<ul><li>无二义性</li><li>无左递归</li><li>任意一个语法变量A的各个候选式所能推导出的<strong>第一个终结符</strong>必须各不相同</li></ul></li></ul><h2 id="符号串的首字符集FIRST-a">符号串的首字符集FIRST(a)</h2><h3 id="FIRST集的定义">FIRST集的定义</h3><img src="..\..\img\CompilerPrinciples\符号串的首字符集FIRST(a).png" width="100%" height="100%" align="middle"><h3 id="FIRST集的生成算法">FIRST集的生成算法</h3><ul><li><p><strong>单个符号</strong>的FIRST集的生成算法<br><img src="..\..\img\CompilerPrinciples\单个符号的FIRST集的生成算法.png" width="100%" height="100%" align="middle"></p></li><li><p><strong>符号串</strong>的FIRST集的生成算法<br><img src="..\..\img\CompilerPrinciples\符号串的FIRST集的生成算法.png" width="100%" height="100%" align="middle"></p></li></ul><h3 id="FIRST集举例">FIRST集举例</h3><img src="..\..\img\CompilerPrinciples\FIRST集举例.png" width="100%" height="100%" align="middle"><h2 id="非终结符的FOLLOW集">非终结符的FOLLOW集</h2><p>对于\epsion的考虑，以及提出FOLLOW集的原因<br><img src="..\..\img\CompilerPrinciples\符号串的首字符集FIRST2.png" width="100%" height="100%" align="middle"></p><h3 id="FOLLOW集的定义">FOLLOW集的定义</h3><img src="..\..\img\CompilerPrinciples\非终结符的FOLLOW集.png" width="100%" height="100%" align="middle"><h3 id="FOLLOW集的生成算法">FOLLOW集的生成算法</h3><img src="..\..\img\CompilerPrinciples\FOLLOW集的生成算法.png" width="100%" height="100%" align="middle"><h3 id="FOLLOW集举例">FOLLOW集举例</h3><img src="..\..\img\CompilerPrinciples\FOLLOW集举例.png" width="100%" height="100%" align="middle"><h2 id="LL-1-文法的定义">LL(1)文法的定义</h2><img src="..\..\img\CompilerPrinciples\LL(1)文法的定义.png" width="100%" height="100%" align="middle"><h3 id="LL-1-文法举例">LL(1)文法举例</h3><img src="..\..\img\CompilerPrinciples\LL(1)文法举例.png" width="100%" height="100%" align="middle"><h1>预测分析法</h1><ul><li>一种高效的自顶向下分析法</li><li>能够对LL(1)文法实现确定的自顶向下分析</li></ul><h2 id="方法综述">方法综述</h2><p>采用表驱动方式实现控制算法</p><ul><li><strong>分析表M[A,a]</strong>，即<strong>LL(1)分析表</strong>，存储执行LL(1)分析的信息，其中<strong>A是语法变量</strong>，<strong>a是输入符号</strong>。</li><li><strong>分析栈</strong>，存放文法符号序列，<strong>#为栈底符号</strong>，<strong>初始时栈顶是开始符号</strong></li><li><strong>输入缓冲区</strong>，包括待分析的<strong>串</strong>和<strong>结束符</strong><br>系统维持一个<strong>分析表</strong>和一个<strong>分析栈</strong>，根据当前<strong>输入缓冲区</strong>中扫描到的符号，选择当前语法变量（<strong>处于栈顶</strong>）的<strong>候选式</strong>进行推导——希望找到相应输入符号串的<strong>最左推导</strong>。</li></ul><img src="..\..\img\CompilerPrinciples\预测分析器的构成.png" width="100%" height="100%" align="middle"><h2 id="预测分析表的构造算法">预测分析表的构造算法</h2><img src="..\..\img\CompilerPrinciples\预测分析表的构造算法.png" width="100%" height="100%" align="middle"><h2 id="预测分析法过程">预测分析法过程</h2><h3 id="实现步骤">实现步骤</h3><ol><li><strong>构造文法</strong></li><li><strong>改造文法</strong>：消除二义性、消除左递归、提取左因子</li><li><strong>求</strong>每个候选式的<strong>FIRST集</strong>和变量的<strong>FOLLOW集</strong></li><li><strong>检查</strong>是不是LL(1)文法<br>若不是 LL(1),说明文法的复杂性超过自顶向下方法的分析能力，需要附加新的“信息”</li><li><strong>构造</strong>预测分析<strong>表</strong></li><li><strong>实现</strong>预测<strong>分析器</strong></li></ol><h3 id="预测分析控制过程">预测分析控制过程</h3><ul><li>在系统启动时，输入指针指向输入串的第一个字符，分析栈中存放着栈底符号#和文法的开始符号</li><li>根据栈顶符号A和读入的符号a，查看分析表M,以决定相应的动作。<ul><li>如果 <strong>A=a=#</strong>，分析成功并停机</li><li>如果 <strong>A=a≠#</strong>，弹出栈顶符号A，并将输入指针指向下一个符号</li><li>如果<strong>A是语法变量</strong>，程序访问分析表M的**M[A,a]**表项，该表项或者是一个A产生式，或者是出错信息。</li><li>如果<strong>M[A,a]={A→UVW}</strong>，则用WVU(栈顶)替换原栈顶符号A，<strong>输出该产生式</strong></li></ul></li></ul><h3 id="算法实现">算法实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">算法<span class="number">4.5</span> 预测分析程序的总控程序</span><br><span class="line">输入：输入串w和文法G=(V, T, P, S)的分析表M;</span><br><span class="line">输出：如果w属于<span class="built_in">L</span>(G)，则输出w的最左推导，否则报错;</span><br><span class="line">步骤：</span><br><span class="line">将栈底符号#和文法开始符号S压入栈中;</span><br><span class="line">repeat</span><br><span class="line">    X:=当前栈顶符号; a:=当前输入符号;</span><br><span class="line">    <span class="keyword">if</span> X∈T∪&#123;#&#125; then</span><br><span class="line">        <span class="keyword">if</span> X=a then</span><br><span class="line">            <span class="keyword">if</span> X≠<span class="meta"># then</span></span><br><span class="line">                将X弹出栈;</span><br><span class="line">                前移输入指针; </span><br><span class="line">        <span class="keyword">else</span> <span class="comment">//当前栈顶终结符和当前输入符号不一致</span></span><br><span class="line">            error</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">//也就是X属于一个语法变量</span></span><br><span class="line">        <span class="keyword">if</span> M[X, a] = Y1Y2…Yk then </span><br><span class="line">            将X弹出栈;</span><br><span class="line">            依次将 Yk，…，Y2，Y1 压入栈;</span><br><span class="line">            输出产生式 X → Y1Y2…Yk;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            error</span><br><span class="line">until X=#</span><br></pre></td></tr></table></figure><h3 id="预测分析法举例">预测分析法举例</h3><ul><li><p>文法、FIRST集和FOLLOW集<br><img src="..\..\img\CompilerPrinciples\预测分析法举例1.png" width="100%" height="100%" align="middle"></p></li><li><p>实现的预测分析表<br><img src="..\..\img\CompilerPrinciples\预测分析法举例2.png" width="100%" height="100%" align="middle"></p></li><li><p>对输入串 <strong>id+id*id</strong> 进行分析的过程<br><img src="..\..\img\CompilerPrinciples\预测分析法举例3.png" width="100%" height="100%" align="middle"></p></li></ul><p>输出的产生式序列形成了<strong>最左推导对应的分析树</strong></p><h2 id="预测分析中错误的处理">预测分析中错误的处理</h2><h3 id="错误类型">错误类型</h3><pre><code>- 栈顶终结符号和下一个输入符号不匹配- 栈顶是语法变量A，a是下一个输入符号，M[A, a]是空白表项</code></pre><h3 id="紧急方式错误恢复策略">紧急方式错误恢复策略</h3><p>发现错误时跳过一些输入符号，直到下一个语法成分包含的第一个符号为止 <strong>（同步记号）</strong></p><p><strong>同步记号的一般选择策略</strong>：对语法变量A，如果M[A,a]无定义，并且a属于FOLLOW(A)，则增加M[A,a]为 <strong>“同步点”</strong>(<strong>synch</strong>)。当程序到达这个同步点时，放弃对A的识别，而转入分析A后面的符号。</p><h3 id="错误的处理步骤：">错误的处理步骤：</h3><ul><li>对预测分析表添加<strong>同步点</strong></li><li>预测分析执行过程中加入以下判断<ul><li>如果表项M[A, a]为<strong>空</strong>，则<strong>跳过输入符号</strong>a；</li><li>如果表项M[A, a]是<strong>synch</strong>，则<strong>弹出栈顶</strong>的语法变量并试图恢复分析；</li><li>如果栈顶的记号与输入符号<strong>不匹配</strong>，则从<strong>栈顶弹出</strong>该记号。</li></ul></li></ul><h3 id="错误的处理举例">错误的处理举例</h3><p>对预测分析表添加<strong>同步点</strong><br><img src="..\..\img\CompilerPrinciples\错误的处理举例.png" width="100%" height="100%" align="middle"></p><p>处理过程<br><img src="..\..\img\CompilerPrinciples\错误的处理举例.png" width="100%" height="100%" align="middle"></p><h1>递归下降分析法</h1><p>所谓递归下降分析法，是指根据各个候选式的结构，为<strong>文法的每个 语法变量 编写一个处理程序</strong>，用来识别该语法变量所代表的语法成分</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;语法分析概述&lt;/h1&gt;
&lt;p&gt;语法分析的主要工作是根据&lt;strong&gt;源语言&lt;/strong&gt;的文法，判别某个&lt;strong&gt;单词序列&lt;/strong&gt;是否是源语言的一个&lt;strong&gt;句子&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;语言&lt;/strong</summary>
      
    
    
    
    <category term="编译原理" scheme="https://escapeey.cn/categories/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
    
    <category term="编译原理" scheme="https://escapeey.cn/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>软件工程</title>
    <link href="https://escapeey.cn/post/7821ac43.html"/>
    <id>https://escapeey.cn/post/7821ac43.html</id>
    <published>2024-05-10T20:30:46.000Z</published>
    <updated>2024-12-14T06:24:07.529Z</updated>
    
    <content type="html"><![CDATA[<h1>软件生命周期</h1><p><strong>核心内容：软件生命周期的各过程</strong><br><img src="../img/Software/软件生命周期.png" width="100%" height="100%" align="middle"></p><h1>软件工程学概述</h1><h2 id="概念定义">概念定义</h2><ul><li>软件工程是指导计算机软件开发和维护的一门工程学科。</li><li>采用<strong>工程</strong>的概念、原理、技术和方法来开发与维护软件。把正确的<strong>管理技术</strong>和当前能够得到的最好的<strong>技术方法</strong>结合起来，以经济地开发出高质量的软件并<strong>有效地维护</strong>它，这就是软件工程。</li></ul><h2 id="本质特性">本质特性</h2><ul><li>软件工程关注于大型程序的构造</li><li>软件工程的中心课题是控制复杂性</li><li>软件经常变化</li><li>开发软件的效率非常重要</li><li>和谐地合作是开发软件的关键</li><li>必须有效地支持它的用户</li><li>两种背景的人创造产品这个特性与前两个特性紧密相关</li></ul><h2 id="基本原理">基本原理</h2><ul><li>用分阶段的生命周期计划严格管理</li><li>坚持进行阶段评审</li><li>实行严格的产品控制</li><li>采用现代程序设计技术</li><li>结果应能清楚地审查</li><li>开发小组的人员应该少而精</li><li>承认不断改进软件工程实践的必要性</li></ul><h2 id="三要素">三要素</h2><ul><li><strong>方法</strong>：完成软件开发的各项任务的技术方法，回答“怎样做”的问题</li><li><strong>工具</strong>：为运用方法而提供的自动的或半自动的软件工程支撑环境</li><li><strong>过程</strong>：为了获得高质量的软件所需要完成的一系列任务的框架，它规定了完成各项任务的工作步骤</li></ul><h2 id="方法学">方法学</h2><h3 id="传统方法学">传统方法学</h3><ul><li>也称为生命周期方法学或结构化范型。</li><li>软件生命周期的全过程依次划分为若干个阶段，然后顺序地完成每个阶段的任务。</li><li>每个阶段的开始和结束都有严格标准，对于任何两个相邻的阶段而言，前一阶段的结束标准就是后一阶段的开始标准。</li></ul><h3 id="面向对象方法">面向对象方法</h3><p>面向对象方法把数据和行为看成是同等重要的，它是一种以数据为主线，把数据和对数据的操作紧密地结合起来的方法</p><h4 id="四个要点">四个要点</h4><ul><li>把对象(object)作为融合了数据及在数据上的操作行为的统一的软件构件。</li><li>把所有对象都划分成类(class)。</li><li>按照父类与子类的关系，把若干个相关类组成一个层次结构的系统。</li><li>对象彼此间仅能通过发送消息互相联系</li></ul><h4 id="基本原则">基本原则</h4><ul><li>尽量模拟人类习惯的思维方式</li><li>从而使描述问题的<strong>问题空间</strong>(也称为问题域)与实现解法的<strong>解空间</strong>(也称为求解域)在<strong>结构上尽可能一致</strong>。</li></ul><h4 id="优点">优点</h4><ul><li><strong>降低</strong>了软件产品的<strong>复杂性</strong>，<strong>提高</strong>了软件的<strong>可理解性</strong>，<strong>简化</strong>了软件<strong>开发和维护工作</strong></li><li>面向对象方法特有的继承性和多态性，进一步提高了面向对象软件的<strong>可重用性</strong>。</li></ul><h2 id="软件过程">软件过程</h2><ul><li>软件过程是为了获得高质量软件所需要完成的一系列任务的框架，它规定了完成各项任务的<strong>工作步骤</strong>。</li><li>软件过程描述为了开发出客户需要的软件，什么人（who）、在什么时候（when）、做什么事（what）以及怎样（how）做这些事以实现某一个特定的具体目标。</li></ul><h3 id="瀑布模型">瀑布模型</h3><img src="../img/Software/瀑布模型.png" width="70%" height="70%" align="middle"><h4 id="特点">特点</h4><ul><li>阶段间具有顺序性和依赖性</li><li>推迟实现的观点</li><li>质量保证的观点</li></ul><h4 id="带反馈的瀑布模型">带反馈的瀑布模型</h4><img src="../img/Software/带反馈的瀑布模型.png" width="70%" height="70%" align="middle"><p><strong>实线箭头表示开发过程，虚线箭头表示维护过程</strong></p><ul><li>当在后面阶段发现前面阶段的错误时，需要沿图中左侧的<strong>反馈线返回</strong>前面的阶段，修正前面阶段的产品之后再回来继续完成后面阶段的任务。</li></ul><h3 id="快速原型模型">快速原型模型</h3><img src="../img/Software/快速原型模型.png" width="70%" height="70%" align="middle"><p>快速原型是快速建立起来的，可以在计算机上运行的程序，它所能完成的功能往往是最终产品能完成的功能的一个<strong>子集</strong>。</p><h4 id="相邻阶段无反馈的原因">相邻阶段无反馈的原因</h4><ul><li>原型系统<strong>已经通过与用户交互而得到验证</strong>，据此产生的<strong>规格说明文档</strong>正确地描述了用户需求，因此，在开发过程的后续阶段不会因为发现了规格说明文档的错误而进行较大的返工。</li></ul><h3 id="增量模型">增量模型</h3><img src="../img/Software/增量模型.png" width="70%" height="70%" align="middle"><ul><li>增量模型也称为渐增模型。核心思想是把软件产品作为一系列的<strong>增量构件</strong>来设计、编码、集成和测试。</li><li>第一个增量构件往往实现软件的基本需求，提供最核心的功能</li></ul><h4 id="优点-2">优点</h4><ul><li>能在较短时间内向用户提交可完成部分工作的产品</li><li>逐步增加产品功能可以使用户有较充裕的时间学习和适应新产品，从而减少一个全新的软件可能给客户组织带来的冲击。</li></ul><h3 id="螺旋模型">螺旋模型</h3><img src="../img/Software/螺旋模型.png" width="70%" height="70%" align="middle"><ul><li>在每个阶段之前都<strong>增加了风险分析过程</strong>的快速原型模型。</li></ul><h3 id="喷泉模型">喷泉模型</h3><img src="../img/Software/喷泉模型.png" width="70%" height="70%" align="middle"><ul><li>典型的<strong>面向对象</strong>的软件过程模型</li><li>图中在一个阶段内的向下箭头代表该<strong>阶段内的迭代</strong></li><li>图中较小的圆圈代表维护，圆圈较小象征着采用了面向对象范型之后维护时间缩短了。</li></ul><h3 id="Rational统一过程">Rational统一过程</h3><ul><li>Rational Unified Process 简称 <strong>RUP</strong></li><li>RUP总结了经过多年商业化验证的6条最有效的软件开发经验，这些经验被称为“最佳实践”<ul><li>迭代式开发</li><li>管理需求</li><li>使用基于构件的体系结构</li><li>可视化建模</li><li>验证软件质量</li><li>控制软件变更</li></ul></li></ul><h4 id="软件生命周期">软件生命周期</h4><ul><li><strong>初始阶段</strong>： 建立业务模型，定义最终产品视图，并且确定项目的范围。</li><li><strong>精化阶段</strong>： 设计并确定系统的体系结构，制定项目计划，确定资源需求。</li><li><strong>构建阶段</strong>： 开发出所有构件和应用程序，把它们集成为客户需要的产品，并且详尽地测试所有功能。</li><li><strong>移交阶段</strong>： 把开发出的产品提交给用户使用</li></ul><h4 id="RUP中的迭代">RUP中的迭代</h4><p>每次迭代都是一个小的瀑布模型</p><h3 id="敏捷过程-Agile">敏捷过程 Agile</h3><ul><li>最早是为了与传统的瀑布软件开发模式相比较，所以当时的方法叫做轻量级方法（Light weight methods）</li></ul><h4 id="敏捷过程核心思想">敏捷过程核心思想</h4><img src="../img/Software/敏捷过程核心思想.png" width="70%" height="70%" align="middle"><h4 id="四条价值观">四条价值观</h4><ul><li>人员交流重于过程与工具</li><li>软件产品重于长篇大论</li><li>客户协作重于合同谈判</li><li>随机应变重于循规蹈矩</li></ul><h4 id="敏捷更符合软件开发规律">敏捷更符合软件开发规律</h4><ul><li>软件更像一个活着的植物，软件开发是自底向上逐步有序的生长过程，类似于植物自然生长</li><li>敏捷开发遵循软件客观规律，不断的进行迭代增量开发，最终交付符合客户价值的产品</li></ul><h4 id="价值驱动-敏捷与传统瀑布型模式的最大区别">价值驱动 - 敏捷与传统瀑布型模式的最大区别</h4><ul><li><p>敏捷基于这种方式，可以实现研发过程的持续高可视性、高可适应性，更早且持续产出业务价值，更早发现和解决风险。</p></li><li><p>瀑布模型 基于 <strong>计划驱动</strong></p></li></ul><h3 id="敏捷常用的工程方法">敏捷常用的工程方法</h3><h4 id="极限编程">极限编程</h4><img src="../img/Software/极限编程.png" width="70%" height="70%" align="middle"><h4 id="整体开发过程">整体开发过程</h4><img src="../img/Software/整体开发过程.png" width="70%" height="70%" align="middle"><h4 id="Scrum模型">Scrum模型</h4><ul><li><p>三大特点</p><ul><li>“可能性的”艺术 – <strong>关注当下</strong></li><li>团队自组织，自管理 – <strong>放权</strong></li><li>面对面沟通 – <strong>提高沟通</strong></li></ul></li><li><p>三种角色</p><ul><li>产品负责人 PO<ul><li>负责管理**产品待办事项表（Product Backlog）**并保证其对于客户和团队保持透明度；</li></ul></li><li>团队负责人 SM<ul><li>不要管理团队。</li></ul></li><li>开发团队 5-9 人</li></ul></li><li><p>三种工件</p><ul><li>产品待办事项表(产品Backlog)</li><li>冲刺待办事项表(Sprint Backlog)<ul><li>包含产品待办事项列表中当前 Sprint 的子集</li></ul></li><li>产品增量</li></ul></li><li><p>步骤</p><ul><li>Step1 头脑风暴</li><li>Step2 PO决定实现的功能</li><li>Step3 时间估计: 用扑克牌游戏进行时间估计</li><li>Step4 冲刺</li><li>Step5 评估 PO</li></ul></li></ul><h4 id="微软开发过程">微软开发过程</h4><ul><li>每一个生命周期发布一个递进的软件版本，各个生命周期持续、快速地迭代循环</li></ul><h1>可行性分析</h1><p>描绘<strong>物理系统</strong> -&gt; <strong>系统流程图</strong><br>描绘<strong>逻辑模型</strong> -&gt; <strong>数据流图</strong> / <strong>数据字典</strong><br><strong>主要内容</strong><br><img src="../img/Software/可行性分析主要内容.png" width="100%" height="100%" align="middle"></p><h2 id="可行性研究的任务">可行性研究的任务</h2><h3 id="含义">含义</h3><ul><li>用最小的代价，在尽可能短的时间内（一般占总工作量的5％到10％）确定<strong>能否解决问题</strong>，以及<strong>是否值得解决</strong>的问题 。</li><li>因此，可行性研究的目的是“<strong>做还是不做</strong>”，而非“如何去做”。</li></ul><h3 id="内容">内容</h3><h4 id="从技术可行性">从技术可行性</h4><ul><li>开发风险</li><li>资源有效性</li><li>技术方案<br>表述为：<strong>做得了吗？做得好吗？做得快吗？</strong></li></ul><h4 id="经济可行性">经济可行性</h4><ul><li>度量系统解决方案的性能价格比</li></ul><h4 id="用户操作可行性">用户操作可行性</h4><ul><li>用户组织的结构、工作流程、管理模式及规范是否适合目标系统的运行，是否互不相容。</li><li>现有的人员素质能否胜任对目标系统的操作？</li><li>如果进行培训，时间是多少？成本如何？</li></ul><h4 id="社会环境可行性">社会环境可行性</h4><ul><li>市场</li><li>政策</li><li>法律</li></ul><h2 id="可行性研究过程">可行性研究过程</h2><ol><li>确定项目规模和目标；</li><li>研究当前正在运行的系统；</li><li>建立新系统的高层逻辑模型；</li><li>导出和评价各种方案；</li><li>推荐可行的方案；</li><li>草拟开发计划；</li><li>编写可行性研究报告，提交审查</li></ol><h2 id="系统流程图">系统流程图</h2><h3 id="基本符号">基本符号</h3><img src="../img/Software/系统流程图基本符号.png" width="100%" height="100%" align="middle"><h3 id="例子">例子</h3><h4 id="系统目标">系统目标</h4><ol><li>管理仓库各类零件数量的变化，并及时修改（更新库存清单文件）。</li><li>报告库存零件达到库存量临界值的订货报告，产生订货信息。</li><li>生成订货报表。</li></ol><h4 id="构成部件">构成部件</h4><ol><li>输入终端CRT</li><li>事务处理部件（库存清单程序）</li><li>磁盘（存放库存清单主文件）</li><li>磁带（存放订货信息）</li><li>报告生成部件（报告生成程序）</li><li>打印的文档（订货报告）</li></ol><h4 id="绘制方法">绘制方法</h4><img src="../img/Software/系统流程图示例.png" width="100%" height="100%" align="middle"><h2 id="数据流图">数据流图</h2><p>以图形方式来表达系统的逻辑功能、数据在系统内部的逻辑流向和逻辑变换过程</p><h3 id="基本符号-2">基本符号</h3><img src="../img/Software/数据流图基本符号.png" width="100%" height="100%" align="middle"><h3 id="附加符号">附加符号</h3><p>*****表示数据流之间“与”的关系（同时存在）<br><strong>+</strong> 表示数据流之间“或”的关系<br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⊕</mo></mrow><annotation encoding="application/x-tex">\oplus</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord">⊕</span></span></span></span> 表示数据流之间 “异或”的关系（不能同时存在）<br><img src="../img/Software/数据流图附加符号.png" width="100%" height="100%" align="middle"></p><h3 id="画数据流图的步骤">画数据流图的步骤</h3><ul><li>Step1：画顶层数据流图,包括数据源点、终点，整个软件系统作为一个数据处理，流入和流出系统的数据流。</li><li>Step2：一级细化，即画分层数据流图，逐层分解数据处理，得到功能级数据流图</li><li>Step3：二级细化，进一步分解功能级数据流图到涉及功能具体的实现为止</li></ul><h3 id="数据流图的示例">数据流图的示例</h3><h4 id="问题描述">问题描述</h4><ul><li>工厂采购部每天需要一张订货报表，报表按零件编号编排，表中列出所有需要再次订货的零件（包括零件编号，零件名称，定货数量，当前价格，目前主要供应者，次要供应者）。</li><li>零件入库或出库称为<strong>事务</strong>，通过放在仓库中的CRT终端把事务报告给定货系统。</li><li>当某种零件的库存量少于库存临界值时就应该再次订货。</li></ul><h4 id="问题分析">问题分析</h4><ul><li><strong>源点/终点</strong>：仓库管理员/采购员</li><li><strong>处理</strong>：处理事务、产生订货报表</li><li><strong>数据存储</strong>：订货信息、库存清单</li><li><strong>数据流</strong>：订货报表、事务</li></ul><h4 id="步骤">步骤</h4><ul><li><p>Step1：绘制基本系统模型<br><img src="../img/Software/数据流图的示例Step1.png" width="100%" height="100%" align="middle"></p></li><li><p>Step2：得到功能级数据流图<br><img src="../img/Software/数据流图的示例Step2.png" width="100%" height="100%" align="middle"></p></li><li><p>Step3：细化到功能实现级别<br><img src="../img/Software/数据流图的示例Step3.png" width="100%" height="100%" align="middle"></p></li></ul><h3 id="注意事项">注意事项</h3><ol><li><p>若一张数据流图中包含的数据处理多于7时，其含义将难以领会，此时数据流图应该分层绘制<br><img src="../img/Software/数据流图注意事项.png" width="100%" height="100%" align="middle"></p></li><li><p>数据流图分层细化时必须保持信息的连续性，即细化前后对应功能的输入输出数据必须相同。<br><img src="../img/Software/数据流图注意事项1.png" width="100%" height="100%" align="middle"></p></li><li><p>数据存储和数据流都是数据，仅所处的状态不同，数据存储是静止状态的数据，数据流是运动状态的数据。</p></li><li><p>所有的数据流都必须以一个数据处理开始，或以一个数据处理结束。即，<strong>每个数据处理都应该有输入输出</strong>。</p></li></ol><h3 id="各成分命名要求">各成分命名要求</h3><h4 id="数据流-或数据存储">数据流(或数据存储)</h4><ul><li>代表整个数据流(或数据存储)的内容</li><li>不要使用缺乏具体含义的名字；</li><li>除流入流出<strong>数据存储</strong>的数据流可以命名相同之外，其他的数据流命名需要唯一，即便是同样内容</li></ul><h4 id="数据处理-或数据加工">数据处理(或数据加工)</h4><ul><li>先为数据流命名，再为处理命名，通常1个动词+宾语的命名方式</li><li>如果必须用两个动词才能描述整个处理的功能，则把这个处理再分解成两个处理可能更恰当些。</li><li>若处理的命名比较困难可能是处理包含太多功能</li></ul><h3 id="注意事项及命名练习">注意事项及命名练习</h3><p>阅读下图所示的数据流图，找出其中错误之处<br><img src="../img/Software/注意事项及命名练习.png" width="100%" height="100%" align="middle"></p><img src="../img/Software/注意事项及命名练习答案.png" width="100%" height="100%" align="middle"><h2 id="数据字典">数据字典</h2><h3 id="数据字典的任务">数据字典的任务</h3><ul><li>对于数据流图中出现的所有被命名的图形元素在字典中作为一个词条加以定义，<strong>使得每一个图形元素的名字都有一个确切的解释</strong></li></ul><h3 id="数据字典的定义">数据字典的定义</h3><ul><li>定义：是关于数据的信息集合，即对数据流图中包含的所有元素定义的集合。</li><li>数据字典和数据流图共同构成系统的逻辑模型，有数据字典，数据流图就不严格；没有数据流图，数据字典难于发挥作用。</li></ul><h3 id="定义内容">定义内容</h3><ul><li><strong>数据流</strong>：来源、去向、组成、流通量</li><li><strong>数据元素</strong>：名称、别名、取值范围、含义、数据长度、小数位数、简单描述</li><li><strong>数据存储</strong>：数据结构及数据存放规则</li><li><strong>数据处理</strong>：数据处理的逻辑功能和主要算法</li></ul><h3 id="数据字典举例">数据字典举例</h3><h4 id="数据流定义">数据流定义</h4><p><strong>对数据流和数据存储来说，需要定义到数据元素为止</strong><br><img src="../img/Software/数据字典示例.png" width="100%" height="100%" align="middle"></p><h4 id="数据项定义">数据项定义</h4><p>由数据元素组成数据的方式</p><ul><li>顺序：以确定次序连接两个或多个分量</li><li>选择：从两个或多个可能元素中选取一个</li><li>重复：把指定的分量重复零次或多次。</li><li>可选：一个分量是可有可无的</li></ul><img src="../img/Software/数据字典中的符号表示.png" width="100%" height="100%" align="middle"><h4 id="数据项的定义练习">数据项的定义练习</h4><ul><li>某酒店所提供的电话服务系统的功能为：</li><li>客人可以通过拨分机号联络酒店内的其他房间，也可拨外线号码与酒店外联络。</li><li>分机号从8201至8299。</li><li>外线号码需先拨0，然后加拨市话号码或长途电话号码</li><li>长途电话号码由区号和市话号码组成，其中区号可以为010、021~029、0300~0999中的任意一个数字串</li><li>市话号码是任意7位或8位长度的数字串。<br><img src="../img/Software/数据项的定义练习答案.png" width="100%" height="100%" align="middle"></li></ul><h4 id="加工定义">加工定义</h4><p>数据处理的定义可以采用结构化语言、IPO图、伪代码PDL、判定树、判定表等方式描述</p><h2 id="成本-效益分析">成本/效益分析</h2><p>从经济角度分析新系统的开发是否能盈利，帮助使用部门正确做出是否投资的决定。</p><h3 id="常用的成本估算技术">常用的成本估算技术</h3><ul><li><p>代码行技术</p><ul><li><strong>成本＝总代码行数×每行的平均成本</strong></li><li>根据经验和历史数据，确定上面两个变量。此外，工资水平也是应考虑的一个重要因素。</li></ul></li><li><p>任务分解技术</p><ul><li>根据生命周期瀑布模型，对开发工作将进行任务分解，分别估算每个任务的成本，累加得到总成本</li><li><strong>成本＝所需的总人月数×每人月的成本</strong></li></ul></li><li><p>自动估计成本技术</p><ul><li>利用自动估计成本技术的软件工具进行计算</li></ul></li><li><p>经验统计估计模型</p><ul><li>Walston-Felix（IBM）模型</li><li>Putnam 估算模型（动态多变量参数模型）</li><li>COCOMO 模型</li></ul></li></ul><h3 id="常用的效益度量方法">常用的效益度量方法</h3><ol><li>货币的时间价值</li><li>投资回收期</li><li>纯收入</li><li>投资回收率</li></ol><h3 id="成本-效益分析步骤">成本/效益分析步骤</h3><ul><li>估计开发成本、运行费用和新系统带来的经济效益</li><li>比较新系统的开发成本和经济效益。</li></ul><h3 id="可行性研究报告">可行性研究报告</h3><ul><li>根据DFD+DD、成本/效益分析等方面，进行技术可行性、经济可行性、用户操作可行性、社会环境可行性等方面评价，完成可行性研究报告，并提交审查</li><li>在审查过程中出现问题需要更改，通过多次迭代完成最终可行性报告，从而实现“是否做”的判断</li></ul><h1>需求分析</h1><img src="../img/Software/需求分析逻辑关系.png" width="100%" height="100%" align="middle"><h2 id="需求分析概述">需求分析概述</h2><h3 id="需求的层次">需求的层次</h3><img src="../img/Software/需求的层次.png" width="100%" height="100%" align="middle"><h3 id="需求分析方法需遵守的法则">需求分析方法需遵守的法则</h3><ul><li>必须理解并<strong>描述问题的信息域</strong>，根据这条准则应该建立<strong>数据模型</strong>。</li><li>必须<strong>定义</strong>软件应完成的<strong>功能</strong>，这条准则要求建立<strong>功能模型</strong>。</li><li>必须描述作为外部事件结果的<strong>软件行为</strong>，这条准则要求建立<strong>行为模型</strong></li><li>必须对<strong>描述信息、功能和行为的模型</strong>进行分解，用<strong>层次</strong>的方式展示细节。</li></ul><h2 id="与用户沟获取需求的方法">与用户沟获取需求的方法</h2><h3 id="需求收集过程">需求收集过程</h3><ul><li>访谈<ul><li>**用户（user）**是一种泛称，它可细分为 <strong>客户（customer）</strong>、**最终用户（the end user）**和 <strong>间接用户（或称为关系人）</strong>。<br>掏钱买产品的用户称为客户，而真正操作产品的用户叫最终用户。客户与最终用户可能是同一个人也可能不是同一个人。</li></ul></li><li>面向数据流自顶向下求精</li><li>简易的应用规格说明技术</li><li>快速建立软件原型</li></ul><h2 id="分析建模与规格说明">分析建模与规格说明</h2><h3 id="需求分析应建立的模型">需求分析应建立的模型</h3><ul><li><strong>数据模型</strong>：E-R图(ERD)，描述数据对象，数据对象之间的关系；</li><li><strong>功能模型</strong>：数据流图(DFD)，描述数据在系统中流动，变换的逻辑过程；</li><li><strong>行为模型</strong>：状态转换图(STD)，描绘了系统的各种行为模式和在不同状态之间转换的方式；</li><li><strong>模型中心</strong>：数据字典 (DD)。</li></ul><h3 id="撰写软件需求规格说明书">撰写软件需求规格说明书</h3><h2 id="功能模型构建">功能模型构建</h2><h2 id="数据模型构建">数据模型构建</h2><h2 id="行为模型构建">行为模型构建</h2><h2 id="需求实现验证">需求实现验证</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;软件生命周期&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;核心内容：软件生命周期的各过程&lt;/strong&gt;&lt;br&gt;
&lt;img src=&quot;../img/Software/软件生命周期.png&quot; width=&quot;100%&quot; height=&quot;100%&quot; align=&quot;middle&quot;&gt;&lt;/p&gt;</summary>
      
    
    
    
    <category term="软件工程" scheme="https://escapeey.cn/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
    
    <category term="软件工程" scheme="https://escapeey.cn/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>编译原理-词法分析</title>
    <link href="https://escapeey.cn/post/8254dc99.html"/>
    <id>https://escapeey.cn/post/8254dc99.html</id>
    <published>2024-04-22T19:25:34.000Z</published>
    <updated>2024-12-14T06:24:07.529Z</updated>
    
    <content type="html"><![CDATA[<h1>词法分析器的功能</h1><ul><li>功能：输入源程序，输出单词符号。即：<strong>把构成源程序的字符串转换成“等价的”单词序列</strong><ul><li>根据词法规则识别及组合单词，进行词法检查</li><li>对数字常数完成数字字符串到二进制数值的转换</li><li>删去空格和注释等不影响程序语义的字符</li></ul></li></ul><h2 id="单词的分类与表示-词法分析器的输出">单词的分类与表示&amp;词法分析器的输出</h2><h3 id="单词的内部形式">单词的内部形式</h3><p>二元组 (种别, 属性值)</p><ul><li><strong>种别</strong>：表示种类(可以用整数编码或宏)</li><li><strong>属性值</strong>：不同的单词不同的值</li></ul><h4 id="按单词种类分类">按单词种类分类</h4><img src="..\..\img\CompilerPrinciples\单词的内部形式-按单词种类分类.png" width="100%" height="100%" align="middle"><h4 id="固定数量单词采用一符一类">固定数量单词采用一符一类</h4><img src="..\..\img\CompilerPrinciples\单词的内部形式-一符一类.png" width="100%" height="100%" align="middle"><h3 id="存储方式">存储方式</h3><p>问题：如何存储<strong>标识符和常量</strong>的属性值</p><ul><li>方法1：用标识符和常量<strong>本身的值</strong>表示</li><li>方法2：用<strong>指针</strong>表示</li></ul><h4 id="本身的值">本身的值</h4><ul><li>不同值存储空间长度不同</li><li>往往需要对长度加以限制，意味着要截断</li></ul><h4 id="用指针表示">用指针表示</h4><ul><li>指针长度固定-&gt;属性值的长度相同</li><li>间接访存-&gt;由于词法分析器要兼顾符号表的查填和维护，间接访存增加负担</li></ul><h3 id="例子">例子</h3><img src="..\..\img\CompilerPrinciples\单词的分类与表示-例子.png" width="100%" height="100%" align="middle"><h2 id="源程序的输入缓冲与预处理">源程序的输入缓冲与预处理</h2><p>源程序以<strong>字符流形式</strong>存储于外部介质<br>为正确识别单词，编译程序需要一系列相关处理</p><ul><li><strong>超前搜索和回退</strong><ul><li>标识符的识别，或双字符运算符（**, &lt;=, &lt;&gt;）</li><li>回退操作修正超前搜索</li></ul></li><li><strong>缓冲区</strong><ul><li>假定源程序存储在磁盘上，这样每读一个字符就需要访问一次磁盘，效率显然是很低的。</li><li>一次性从磁盘读取给定大小的部分源程序</li></ul></li><li><strong>空白字符的剔除</strong><ul><li>剔除源程序中的无用符号、空格、换行、注释等</li></ul></li></ul><h3 id="输入缓冲区">输入缓冲区</h3><img src="..\..\img\CompilerPrinciples\词法分析-输入缓冲区.png" width="100%" height="100%" align="middle"><ul><li>单缓冲区存在的问题<ul><li>缓冲区内容用完后，等待新的输入需要等待，应该避免类似的等待</li><li>缓冲区尾部可能只包含单词的一部分，载入下一部分程序时，当前缓冲区的内容被覆盖，最坏情况下可识别的单词长度只能为1，而且无法执行超前搜索</li></ul></li><li>采用<strong>双缓冲区</strong><br><img src="..\..\img\CompilerPrinciples\词法分析-双缓冲区.png" width="100%" height="100%" align="middle"></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">if forward在缓冲区第一部分末尾 then</span><br><span class="line">    重装缓冲区第二部分;</span><br><span class="line">    forward := forward +1</span><br><span class="line">if forward在缓冲区第二部分末尾 then</span><br><span class="line">    重装缓冲区第一部分;</span><br><span class="line">    将forward移到缓冲区第一部分开始</span><br><span class="line">其他情况且当前字符不是EOF </span><br><span class="line">    forward:= forward +1;</span><br></pre></td></tr></table></figure><ul><li>令缓冲区大小为2N，则双缓冲区的每一个大小是N，双缓冲技术将可识别单词的长度扩展到N</li><li>每次移动向前指针都需要做<strong>两次测试</strong>:<ul><li>是否到缓冲区末尾</li><li>当前字符是否是EOF</li></ul></li><li><strong>修正方法</strong>：采用带标记缓冲区，即两个缓冲区的末尾处各设置一个“EOF”标志<ul><li>如果当前字符是“EOF”，就再判断是否到达缓冲区末尾，将移动向前指针需要的两次测试减少到 <strong>(N+1)/N</strong></li></ul></li></ul><h2 id="词法分析阶段的错误处理">词法分析阶段的错误处理</h2><h3 id="非法字符检查">非法字符检查</h3><ul><li>维护一个合法字符集合，对于每一个输入字符，判断该字符是否属于该字符集合</li></ul><h3 id="单词拼写错误">单词拼写错误</h3><ul><li><strong>关键字拼写</strong>词法分析阶段<strong>无法检测</strong>，待语法分析阶段发现错误</li><li>标识符拼写错误，如3b78，处理方法有两种<ul><li>识别出整数3、标识符b78</li><li>错误的标识符</li></ul></li></ul><h3 id="注释或字符常量不封闭">注释或字符常量不封闭</h3><ul><li>会错误地将后续所有源程序看作是<strong>注释或者是字符串</strong>的一部分，影响正常程序分析</li><li>对注释或字符串长度加以限制，如注释长度不超过1行，字符串长度最大是256</li></ul><h3 id="变量重复说明">变量重复说明</h3><ul><li>当词法分析器<strong>兼顾符号表的查填工作时</strong>才能发现该错误</li><li>为了指出<strong>错误的位置</strong>，必须<strong>对源程序进行行列计数</strong></li><li>出错信息可以夹在源程序发生错误的地方（便于修改，但容易弄乱源程序）</li><li>出错信息也可以收集起来统一处理</li></ul><h3 id="错误恢复与续编译">错误恢复与续编译</h3><ul><li>词法分析阶段的错误使得编译无法继续进行，需要采取措施使得编译继续下去</li><li>方法<ul><li>错误校正：极其困难</li><li><strong>紧急方式恢复(panic-mode recovery)</strong>：反复删掉剩余输入最前面的字符，直到词法分析器能发现一个正确的单词为止。</li></ul></li></ul><h2 id="词法分析器的位置">词法分析器的位置</h2><ul><li>独立地完成对源程序的一遍扫描，将单词序列以中间文件形式存储，作为语法分析的输入<ul><li>简化编译器的设计</li><li>提高编译器的效率</li><li>增强编译器的可移植性</li></ul></li><li>作为语法分析器的一个子程序<ul><li>整个编译程序简单紧凑</li></ul></li></ul><h1>单词的描述</h1><ul><li>根据正则文法构造等价的正则表达式</li><li>将正则表达式转换成等价的正则文法</li><li>构造有穷状态自动机</li><li>正则表达式转换为状态转换图</li></ul><h1>单词的识别</h1><h2 id="有穷状态自动机与单词识别的关系">有穷状态自动机与单词识别的关系</h2><ul><li>识别不同进制数的状态图 P91</li><li>单词识别的状态转换图表示 P96</li><li>利用状态转换图识别单词 P98</li><li>由正则文法构造状态转换图 P101</li><li>状态转换图的实现 P107<ul><li>状态矩阵</li><li>邻接表</li><li><strong>四个数组组成的结构</strong>，既可以实现数据压缩存储，又可以实现元素的快速访问 P117</li></ul></li></ul><h1>词法分析程序的自动生成</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;词法分析器的功能&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;功能：输入源程序，输出单词符号。即：&lt;strong&gt;把构成源程序的字符串转换成“等价的”单词序列&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;根据词法规则识别及组合单词，进行词法检查&lt;/li&gt;
&lt;li&gt;对数字常数完成数字字符串到二进制</summary>
      
    
    
    
    <category term="编译原理" scheme="https://escapeey.cn/categories/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
    
    <category term="编译原理" scheme="https://escapeey.cn/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>编译原理-引论</title>
    <link href="https://escapeey.cn/post/a7451f54.html"/>
    <id>https://escapeey.cn/post/a7451f54.html</id>
    <published>2024-04-21T15:47:22.000Z</published>
    <updated>2024-12-14T06:24:07.529Z</updated>
    
    <content type="html"><![CDATA[<h1>程序设计语言</h1><ul><li><strong>机器语言</strong><ul><li>每一个具体的计算机系统都具有自己的指令系统</li><li>以<strong>0,1代码</strong>表示的机器指令所构成的语言</li></ul></li><li><strong>汇编语言</strong><ul><li>适当的助记符来表示指令中的操作和操作数</li><li>如含有：add、mov …</li></ul></li><li><strong>高级语言</strong><ul><li>其表示方法更接近于待解问题的表示方法</li><li>定义数据、描述运算、控制流程、传输数据</li><li>如：C、FORTRAN、PASCAL、C++、JAVA</li></ul></li></ul><h1>程序设计语言的翻译</h1><h2 id="翻译程序-Translator">翻译程序(Translator)</h2><ul><li>将某一种语言描述的程序(源程序——Source Program)翻译成<strong>等价</strong>的另一种语言描述的程序(目标程序——Object Program)的<strong>程序</strong>。<br><img src="..\..\img\CompilerPrinciples\翻译程序.png" width="100%" height="100%" align="middle"></li></ul><p><strong>翻译程序</strong> 包含 <strong>解释程序</strong> 和 <strong>编译程序</strong> 两种</p><h3 id="解释程序-Interpreter">解释程序(Interpreter)</h3><ul><li>边解释边执行：不断读取源程序的语句，解释语句，读取此语句需要的数据，根据执行结果读取下一条语句，继续解释执行，直到返回结果</li><li>类似于自然语言翻译的同声传译<br><img src="..\..\img\CompilerPrinciples\解释程序.png" width="100%" height="100%" align="middle"></li></ul><h3 id="编译程序-Compiler">编译程序(Compiler)</h3><ul><li>将源程序<strong>完整地</strong>转换成机器语言程序或汇编语言程序，然后再处理、执行的翻译程序</li><li><strong>高级语言程序</strong> → <strong>汇编/机器语言程序</strong></li><li>类似于自然语言翻译的通篇笔译</li></ul><h3 id="其他翻译程序">其他翻译程序</h3><ul><li><strong>汇编程序(Assembler)</strong><ul><li><strong>源</strong>程序是 <strong>汇编程序</strong>，<strong>目标</strong>程序是 <strong>机器程序</strong></li></ul></li><li><strong>交叉汇编程序(Cross Assembler)</strong><ul><li><strong>源</strong>程序是 <strong>汇编程序</strong>，<strong>目标</strong>程序是 <strong>另一台机器</strong>的 <strong>机器程序</strong></li></ul></li><li><strong>反汇编程序(Disassembler)</strong><ul><li><strong>源</strong>程序是 <strong>机器程序</strong>，<strong>目标</strong>程序是 <strong>汇编程序</strong></li></ul></li><li><strong>交叉编译程序(Cross Compiler)</strong></li></ul><h2 id="编译系统">编译系统</h2><p><strong>编译系统 = 编译程序 + 运行系统</strong><br><img src="..\..\img\CompilerPrinciples\编译系统.png" width="100%" height="100%" align="middle"></p><h1>编译程序的总体结构</h1><img src="..\..\img\CompilerPrinciples\编译程序的总体结构.png" width="100%" height="100%" align="middle"><ul><li><strong>模块分类</strong>：<ul><li><strong>分析</strong>：词法分析、语法分析、语义分析</li><li><strong>综合</strong>：中间代码生成、代码优化、目标代码生成</li><li><strong>辅助</strong>：符号表管理、出错处理</li></ul></li><li>8项功能对应8个模块</li></ul><h2 id="词法分析">词法分析</h2><h3 id="定义">定义</h3><ul><li><p>词法分析由<strong>词法分析器</strong>(Lexical Analyzer)完成，词法分析器又称为<strong>扫描器</strong>(Scanner)</p></li><li><p>词法分析器从左到右扫描组成源程序的<strong>字符串</strong>，并将其转换成单词串；<strong>同时要</strong>：<strong>查词法错误</strong>，<strong>进行标识符登记</strong>（符号表管理）。</p></li><li><p><strong>输入</strong>：<strong>字符串</strong></p></li><li><p><strong>输出</strong>：<strong>(种别码，属性值)——序对</strong></p><ul><li><strong>属性值</strong>——token的机内表示</li></ul></li></ul><h3 id="例子：">例子：</h3><p><strong>输入</strong>：sum=(10+20) * (num+square);<br><strong>输出</strong>: (标识符，sum)    (赋值号，=)    (左括号，()<br>(整常数，10)     (加号，+ )    (整常数，20)<br>(右括号，))      (乘号，* )    (左括号，()<br>(标识符，num)    (加号，+ )    (标识符，square)<br>(右括号，))      (分号，;)</p><h2 id="语法分析">语法分析</h2><ul><li><p>语法分析由<strong>语法分析器</strong>(Syntax Analyzer)完成，语法分析器又叫Parser。</p></li><li><p><strong>功能</strong>：</p><ul><li>Parser实现“<strong>组词成句</strong>”： 将词组成各类语法成分，例如因子、项、表达式、语句、子程序…</li><li>构造分析树</li><li>指出语法错误</li><li>指导翻译</li></ul></li><li><p><strong>输入</strong>：<strong>token序列</strong></p></li><li><p><strong>输出</strong>：<strong>语法成分</strong></p></li></ul><img src="..\..\img\CompilerPrinciples\语法分析.png" width="100%" height="100%" align="middle"><h2 id="语义分析">语义分析</h2><ul><li>语义分析(semantic analysis)一般<strong>和语法分析同时进行</strong>，称为<strong>语法制导翻译</strong></li><li><strong>功能</strong>：分析由<strong>语法分析器</strong>识别出来的 语法成分的<strong>语义</strong><ul><li>获取标识符的<strong>属性</strong>：类型、作用域等</li><li><strong>语义检查</strong>：运算的合法性、取值范围等</li><li><strong>子程序的静态绑定</strong>：代码的相对地址</li><li><strong>变量的静态绑定</strong>：数据的相对地址<br><img src="..\..\img\CompilerPrinciples\语义分析.png" width="100%" height="100%" align="middle"></li></ul></li></ul><h2 id="中间代码生成">中间代码生成</h2><ul><li>语义分析通常以中间代码形式表达操作</li><li>中间代码的<strong>特点</strong><ul><li>简单规范</li><li><strong>与机器无关</strong></li><li>易于优化与转换<br><img src="..\..\img\CompilerPrinciples\中间代码生成.png" width="100%" height="100%" align="middle"></li></ul></li></ul><h2 id="代码优化-optimization">代码优化(optimization)</h2><ul><li>对中间代码进行优化处理，使程序运行能够 尽量<strong>节省存储空间</strong>，更<strong>有效地利用机器资源</strong>，使得程序的<strong>运行速度更快</strong>，<strong>效率更高</strong></li><li>这种优化<strong>变换必须是等价的</strong>。</li><li>分为（<strong>与机器无关的优化</strong>）和（<strong>与机器有关的优化</strong>）两种</li></ul><h3 id="与机器无关的优化">与机器无关的优化</h3><p>可以理解为 <strong>算法</strong></p><h4 id="局部优化">局部优化</h4><ul><li><strong>常量合并</strong>：常数运算在编译期间完成，如 8+9*4</li><li><strong>公共子表达式的提取</strong></li></ul><h4 id="全局优化">全局优化</h4><ul><li>主要是指<strong>循环优化</strong></li><li><strong>强度削减</strong>：用较快的操作代替较慢的操作</li><li><strong>代码外提</strong>：将循环中不变的计算移出循环</li></ul><h3 id="与机器有关的优化">与机器有关的优化</h3><p>可以理解为 <strong>组成原理</strong> 和 <strong>体系结构</strong></p><ul><li><strong>寄存器的利用</strong><ul><li>将常用量放入寄存器，以减少访问内存的次数</li></ul></li><li><strong>体系结构</strong><ul><li>SIMD 、MIMD、SPMD、向量机、流水机</li></ul></li><li><strong>任务划分</strong><ul><li>按运行的算法及体系结构，划分子任务(MPMD)</li></ul></li><li><strong>存储策略</strong><ul><li>根据算法访存的要求安排：Cache、并行存储体系——减少访问冲突</li></ul></li></ul><h4 id="存储层次">存储层次</h4><ul><li>CPU寄存器<ul><li>保存着最常用的数据，0 个周期访问数据</li></ul></li><li>高速缓冲存储器<ul><li>靠近CPU的小的、快速的存储器，1-30个周期访问数据</li></ul></li><li>主存储器<ul><li>存储系统和进程运行所需的数据和指令，50-200个周期访问数据</li></ul></li><li>磁盘<ul><li>最主要存储设备，10,000,000个周期访问数据</li></ul></li></ul><h2 id="目标代码生成">目标代码生成</h2><ul><li>编译程序的<strong>最后一个阶段</strong></li><li>为中间代码中出现的运算对象<strong>分配存储单元、寄存器</strong>等</li><li>将<strong>中间代码转换成目标机上的机器指令代码或汇编代码</strong><ul><li>对于确定源语言的各种语法成分，确定目标代码结构（机器指令组/汇编语句组）</li><li>制定从中间代码到目标代码的翻译策略或算法</li></ul></li></ul><h2 id="错误处理">错误处理</h2><ul><li>进行各种错误的<strong>检查、报告、纠正</strong>，以及相应的续编译处理(如：错误的定位与局部化)<ul><li><strong>词法分析阶段</strong>：拼写方面的错误，出现非法字符等</li><li><strong>语法分析阶段</strong>：表达式、句子或程序结构等错误</li><li><strong>语义分析阶段</strong>：类型匹配错误、参数匹配错误、非法转移问题等</li></ul></li></ul><h2 id="表格管理">表格管理</h2><ul><li><strong>管理各种符号表</strong>(常数、标号、变量、过程、结构……)，查、填源程序中出现的符号和编译程序生成的符号，<strong>为编译的各个阶段提供信息</strong>。</li><li>Hash表、链表等各种表的查、填技术</li><li>“数据结构与算法” 课程的应用</li></ul><h1>编译程序的组织</h1><ul><li>根据系统资源的状况、运行目标的要求等，可以将一个编译程序设计成多**遍（Pass）**扫描的形式，在每一遍扫描中，完成不同任务。<ul><li>如：首遍构造语法树，二遍处理中间表示，增加信息等</li></ul></li><li><strong>遍可以和阶段相对应，也可以和阶段无关</strong></li><li>遍<strong>数量</strong>的优化<ul><li>根据语言、系统追求的目标、计算机的资源状况等决定</li></ul></li></ul><h2 id="多遍扫描">多遍扫描</h2><ul><li>本遍扫描的结果作为下一遍扫描的输入，本遍扫描中得到的信息在下一遍扫描中也有效，容易获得更优化的程序<ul><li>可以将词法分析、语法分析、语义分析和中间代码生成做成一遍；</li><li>将代码优化做成一遍；</li><li>将目标代码生成做成一遍</li></ul></li><li>增加内存访问次数，可能增加外部存储的访问次数</li></ul><h2 id="单遍扫描">单遍扫描</h2><ul><li>分析所需的信息可能目前尚未掌握，导致产生的目标程序难以达到最优</li></ul><h2 id="编译程序的设计目标">编译程序的设计目标</h2><ul><li>规模小、速度快、诊断能力强、可靠性高、<strong>可移植性好</strong>、可扩充性好</li><li>目标程序也要规模小、执行速度快</li><li>为了提高可移植性，将<strong>编译程序划分为前端和后端</strong></li></ul><h2 id="前端">前端</h2><ul><li>与源语言有关、与目标机无关的部分</li><li>词法分析、语法分析、语义分析与中间代码生成、与机器无关的代码优化</li><li>对于<strong>某一种高级语言在不同机器上的编译系统</strong>，前端的处理基本是一样的，<strong>前端部分可被复用</strong>，只需要针对不同的机器构建后端就可以</li></ul><h2 id="后端">后端</h2><ul><li>与目标机有关的部分</li><li>与机器有关的代码优化、目标代码生成</li><li>在<strong>某一种机器上实现多种高级语言的编译系统</strong>，<strong>后端部分可以被复用</strong>，只需要针对不同高级语言构建前端就可以</li></ul><h1>编译程序的生成</h1><ul><li>编译程序也是运行在计算机上的<strong>程序</strong></li></ul><h2 id="T形图">T形图</h2><p>表示语言翻译的T形图<br><img src="..\..\img\CompilerPrinciples\T形图.png" width="100%" height="100%" align="middle"></p><p>一个用A语言描述的编译程序，它将S语言源程序翻译成了T语言目标程序</p><h2 id="自展">自展</h2><ul><li><strong>问题一：如何直接在一个机器上实现C语言编译器？</strong></li><li>解决：<ol><li>用汇编语言实现一个C子集的编译程序<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">P_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></li><li>用汇编程序处理该程序<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">P_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>,得到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">P_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>（可直接运行）</li><li>用C子集编制C语言的编译程序<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mn>3</mn></msub></mrow><annotation encoding="application/x-tex">P_3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></li><li>用<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">P_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>编译<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mn>3</mn></msub></mrow><annotation encoding="application/x-tex">P_3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，得到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mn>4</mn></msub></mrow><annotation encoding="application/x-tex">P_4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></li></ol></li></ul><h2 id="移植">移植</h2><ul><li><strong>问题二</strong>：A机上有一个C语言编译器，是否可利用此编译器实现B机上的C语言编译器？<ul><li>条件：A机有C 语言的编译程序</li><li>目的：实现B机的C语言的编译</li></ul></li><li>解决：<ol><li>用Ｃ语言编制B机的Ｃ编译程序<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">P_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></li><li>(Ａ机C编译器<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">P_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>)编译<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">P_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，得到在A机上可运行的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">P_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></li><li>(Ａ机的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">P_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>)编译<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">P_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，得到B机上可运行的编译器<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mn>3</mn></msub></mrow><annotation encoding="application/x-tex">P_3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></li></ol></li></ul><h2 id="本机编译器的利用">本机编译器的利用</h2><ul><li><strong>问题三</strong>： A机上有一个C语言编译器，现要实现一个新语言NEW的编译器？</li><li>解决：<ul><li>用C编写NEW的编译器，并用C编译器编译它</li></ul></li></ul><h2 id="编译程序的自动生成">编译程序的自动生成</h2><h3 id="词法分析器的自动生成程序">词法分析器的自动生成程序</h3><img src="..\..\img\CompilerPrinciples\词法分析器的自动生成程序.png" width="100%" height="100%" align="middle"><h3 id="语法分析器的自动生成程序">语法分析器的自动生成程序</h3><img src="..\..\img\CompilerPrinciples\语法分析器的自动生成程序.png" width="100%" height="100%" align="middle">]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;程序设计语言&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;机器语言&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;每一个具体的计算机系统都具有自己的指令系统&lt;/li&gt;
&lt;li&gt;以&lt;strong&gt;0,1代码&lt;/strong&gt;表示的机器指令所构成的语言&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;</summary>
      
    
    
    
    <category term="编译原理" scheme="https://escapeey.cn/categories/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
    
    <category term="编译原理" scheme="https://escapeey.cn/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络-概述</title>
    <link href="https://escapeey.cn/post/be54bfd5.html"/>
    <id>https://escapeey.cn/post/be54bfd5.html</id>
    <published>2024-04-11T08:17:51.000Z</published>
    <updated>2024-12-14T06:24:07.529Z</updated>
    
    <content type="html"><![CDATA[<h2 id="因特网">因特网</h2><ul><li><p>基于ISP的三层结构的因特网<br><img src="../../img/Network/基于ISP的三层结构的因特网.png" width="100%" height="100%"></p></li><li><p>因特网的组成<br><img src="../../img/Network/因特网的组成.png" width="100%" height="100%"></p></li></ul><h2 id="三种交换方式">三种交换方式</h2><h3 id="电路交换">电路交换</h3><ul><li>电话交换机 接通电话线的方式称为 电路交换</li><li>三个步骤：<ul><li>建立连接 （分配通信资源）</li><li>通话 （<strong>一直占用</strong>通信资源）</li><li>释放连接 （归还通信资源）</li></ul></li><li>传输计算机数据时效率很低 （因为计算机数据传输是 <strong>突发式</strong>的）</li></ul><h3 id="分组交换">分组交换</h3><ul><li>通过路由器 传送 分组</li><li>三方：<ul><li>发送方： 构造分组、发送分组</li><li>路由器： 缓存分组、转发分组 （<strong>存储转发</strong>）</li><li>接收方： 接收分组、还原报文</li></ul></li></ul><h3 id="报文交换">报文交换</h3><ul><li>没有限制报文大小的交换， 需要各个节点交换机有较大的缓存空间<br><img src="../../img/Network/三种交换方式.png" width="100%" height="100%"></li></ul><h3 id="优缺点">优缺点</h3><h4 id="电路交换-2">电路交换</h4><ul><li>优点：<ul><li>通信时延小</li><li>有序传输</li><li>没有冲突</li><li>适用范围广</li><li>实时性强</li><li>控制简单</li></ul></li><li>缺点：<ul><li>建立连接时间长</li><li>线路独占、使用效率低</li><li>灵活性差</li><li>难以规格化</li></ul></li></ul><h4 id="报文交换-2">报文交换</h4><ul><li>优点：<ul><li>无需建立连接</li><li>动态分配线路</li><li>提高线路可靠性</li><li>提高线路利用率</li><li>提供多目标服务</li></ul></li><li>缺点：<ul><li>引起了转发时延</li><li>需要较大存储缓存空间</li><li>需要传输额外的信息量</li></ul></li></ul><h4 id="分组交换-2">分组交换</h4><ul><li>优点：<ul><li>无需建立连接</li><li>提高线路利用率</li><li><strong>简化了存储管理</strong> （分组大小固定）</li><li><strong>加速传输</strong>（在转发分组时可以同时存储下一个分组）</li><li><strong>减少出错概率和重发数据量</strong>（分组小，从而出错概率小，重发量小）</li></ul></li><li>缺点：<ul><li>引起了转发时延</li><li>需要传输额外的信息量</li><li><strong>对于数据报服务，存在失序、丢失或重复分组的问题</strong></li><li>对于虚电路服务，存在呼叫建立、数据传输和虚电路释放三个过程</li></ul></li></ul><h2 id="计算机网络的分类">计算机网络的分类</h2><img src="../../img/Network/计算机网络分类.png" width="100%" height="100%"><h2 id="计算机网络的性能指标">计算机网络的性能指标</h2><h3 id="速率">速率</h3><ul><li>传送比特的速率，也称 <strong>比特率</strong></li><li>单位：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi><mi>i</mi><mi>t</mi><mi mathvariant="normal">/</mi><mi>s</mi><mo stretchy="false">(</mo><mi>b</mi><mi>p</mi><mi>s</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">bit/s   (bps)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">bi</span><span class="mord mathnormal">t</span><span class="mord">/</span><span class="mord mathnormal">s</span><span class="mopen">(</span><span class="mord mathnormal">b</span><span class="mord mathnormal">p</span><span class="mord mathnormal">s</span><span class="mclose">)</span></span></span></span><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mi>b</mi><mi mathvariant="normal">/</mi><mi>s</mi><mo>=</mo><mn>1</mn><msup><mn>0</mn><mn>3</mn></msup><mi>b</mi><mi>i</mi><mi>t</mi><mi mathvariant="normal">/</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">kb/s = 10^3 bit/s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">kb</span><span class="mord">/</span><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mord mathnormal">bi</span><span class="mord mathnormal">t</span><span class="mord">/</span><span class="mord mathnormal">s</span></span></span></span></li></ul></li><li>速率单位中 是以 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>3</mn></msup></mrow><annotation encoding="application/x-tex">10^3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span></span></span></span> 进制的</li><li>数据量单位中 是以 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>1</mn></msup><mn>0</mn></mrow><annotation encoding="application/x-tex">2^10</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span></span></span></span></span><span class="mord">0</span></span></span></span> 进制的<br><img src="../../img/Network/速率计算例题.png" width="100%" height="100%"></li></ul><h3 id="带宽">带宽</h3><h4 id="在模拟信号系统的意义">在模拟信号系统的意义</h4><ul><li><strong>信号</strong>所包含的各种不同频率成分所占据的 <strong>频率范围</strong></li><li>单位：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>H</mi><mi>z</mi><mo stretchy="false">(</mo><mi>k</mi><mi>H</mi><mi>z</mi><mo separator="true">,</mo><mi>M</mi><mi>H</mi><mi>z</mi><mo separator="true">,</mo><mi>G</mi><mi>H</mi><mi>z</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Hz (kHz, MHz, GHz)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.04398em;">Hz</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mord mathnormal" style="margin-right:0.04398em;">Hz</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mord mathnormal" style="margin-right:0.04398em;">Hz</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">G</span><span class="mord mathnormal" style="margin-right:0.04398em;">Hz</span><span class="mclose">)</span></span></span></span></li></ul><h4 id="计网中的意义">计网中的意义</h4><ul><li>表示网络的<strong>通信线路</strong>所能传送数据的能力，因此网络带宽表示 <strong>在单位时间内</strong>从网络中的某一点到另一点所能通过的“<strong>最高数据率</strong>”</li><li>单位：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi><mi>i</mi><mi>t</mi><mi mathvariant="normal">/</mi><mi>s</mi><mo stretchy="false">(</mo><mi>b</mi><mi>p</mi><mi>s</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">bit/s (bps)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">bi</span><span class="mord mathnormal">t</span><span class="mord">/</span><span class="mord mathnormal">s</span><span class="mopen">(</span><span class="mord mathnormal">b</span><span class="mord mathnormal">p</span><span class="mord mathnormal">s</span><span class="mclose">)</span></span></span></span> <strong>与速率单位相同</strong></li></ul><h3 id="吞吐量">吞吐量</h3><ul><li>单位时间内通过某个网络的数据量</li><li>受网络的带宽或额定速率的限制</li></ul><h3 id="时延">时延</h3><ul><li>由 发送时延、传播时延、处理时延构成</li><li>发送时延 = 分组长度(b) / 发送速率(b/s)</li><li>传播时延 = 信道长度(m) / 电磁波传播速率(m/s)</li><li>处理时延 不方便计算</li></ul><h3 id="时延带宽积">时延带宽积</h3><ul><li>时延带宽积 = 传播时延 * 带宽<br><img src="../../img/Network/时延带宽积.png" width="100%" height="100%"></li></ul><h3 id="往返时间-RTT">往返时间 RTT</h3><p>Round-Trip Time 双向交互一次的时间 <strong>RTT</strong></p><h3 id="利用率">利用率</h3><ul><li><p>信道利用率： 用来表示某信道有百分之几的时间是被利用的(有数据通过)</p></li><li><p>网络利用率： 全网络的信道利用率的加权平均</p></li><li><p>当某信道的利用率增大时，该信道引起的时延也会迅速增加</p></li><li><p>如令 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>D</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">D_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 表示网络空闲时的时延，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi></mrow><annotation encoding="application/x-tex">D</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span></span></span></span> 表示网络当前时延，可以用下面简化的公式表示时延与利用率 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>U</mi></mrow><annotation encoding="application/x-tex">U</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span></span></span></span>的关系：</p></li></ul><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>D</mi><mo>=</mo><mfrac><msub><mi>D</mi><mn>0</mn></msub><mrow><mn>1</mn><mo>−</mo><mi>U</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">D = \dfrac{D_0}{1-U}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.1297em;vertical-align:-0.7693em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3603em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.7693em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><ul><li>因此一些有较大主干网的ISP通常会控制它们的 信道利用率不超过 50%。</li></ul><h3 id="丢包率">丢包率</h3><ul><li>即分组丢失率，在一定时间内，传输过程中<strong>丢失的分组数</strong>与<strong>总分组数</strong>的比率</li><li>分组丢失主要两种情况：<ul><li>分组在传输过程中出现<strong>误码</strong>, 被结点丢弃；</li><li>分组到达一台队列已满的交换机时被丢弃，在通信量较大时造成<strong>网络拥塞</strong></li></ul></li><li>丢包率反应了网络的拥塞情况<ul><li>无拥塞时 丢包率为0</li><li>轻度拥塞时 为 1% - 4%</li><li>严重拥塞时 为 5% - 15%</li></ul></li></ul><h2 id="计算机网络体系结构">计算机网络体系结构</h2><h3 id="体系结构层次">体系结构层次</h3><img src="../../img/Network/体系结构层次.png" width="100%" height="100%"><h3 id="术语">术语</h3><ul><li><p><strong>实体</strong>： 任何可发送或接受信息的<strong>硬件</strong>或<strong>软件进程</strong></p></li><li><p><strong>对等实体</strong>： 收发双方<strong>相同层次中的实体</strong></p></li><li><p><strong>协议</strong>：控制两个对等实体进行逻辑通信的规则的集合</p></li><li><p>协议的<strong>三要素</strong>： 语法  语义  同步</p><ul><li><strong>语法</strong> 定义所交换信息的格式</li><li><strong>语义</strong> 定义收发双方所要完成的操作</li><li><strong>同步</strong> 定义收发双方的时序关系</li></ul></li><li><p>在协议的控制下，两个对等实体间的逻辑通信使得本层能向上一层提供<strong>服务</strong></p></li><li><p>协议时 <strong>“水平的”</strong>， 服务是 <strong>“垂直的”</strong></p></li><li><p><strong>服务访问点</strong>： 在同一系统中 <strong>相邻两层的实体交换信息的逻辑接口</strong></p><ul><li>数据链路层 的 服务访问点为 帧的“类型”字段</li><li>网络层 的 服务访问点为 IP数据报首部中的“协议字段”</li><li>运输层 的 服务访问点为 “端口号”</li></ul></li><li><p><strong>服务原语</strong>： 上层使用下层所提供的服务必须通过与下层<strong>交换一些命令</strong>，这些命令称为服务原语</p></li><li><p><strong>协议数据单元PDU</strong>: <strong>对等层次之间传送的数据包</strong> 称为该层的协议数据单元</p></li><li><p><strong>服务数据单元SDU</strong>: <strong>同一系统内，层与层之间交换的数据包</strong> 称为服务数据单元</p></li></ul><img src="../../img/Network/术语.png" width="100%" height="100%">]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;因特网&quot;&gt;因特网&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;基于ISP的三层结构的因特网&lt;br&gt;
&lt;img src=&quot;../../img/Network/基于ISP的三层结构的因特网.png&quot; width=&quot;100%&quot; height=&quot;100%&quot;&gt;&lt;/p&gt;
&lt;/li&gt;
</summary>
      
    
    
    
    <category term="计算机网络" scheme="https://escapeey.cn/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机网络" scheme="https://escapeey.cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>DFS和BFS</title>
    <link href="https://escapeey.cn/post/f5273844.html"/>
    <id>https://escapeey.cn/post/f5273844.html</id>
    <published>2024-04-03T11:31:37.000Z</published>
    <updated>2024-12-14T06:24:07.526Z</updated>
    
    <content type="html"><![CDATA[<h1>DFS</h1><p>回溯算法，其实就是dfs的过程，这里给出dfs的代码框架：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(参数)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (终止条件) &#123;</span><br><span class="line">        存放结果;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (选择：本节点所连接的其他节点) &#123;</span><br><span class="line">        处理节点;</span><br><span class="line">        <span class="built_in">dfs</span>(图，选择的节点); <span class="comment">// 递归</span></span><br><span class="line">        回溯，撤销处理结果</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>深搜代码模板，该模板针对的是四方格的地图：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> dir[<span class="number">4</span>][<span class="number">2</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;; <span class="comment">// 四个方向</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; grid, vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt;&amp; visited, <span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        <span class="type">int</span> nextx = x + dir[i][<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> nexty = y + dir[i][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (nextx &lt; <span class="number">0</span> || nextx &gt;= grid.<span class="built_in">size</span>() || nexty &lt; <span class="number">0</span> || nexty &gt;= grid[<span class="number">0</span>].<span class="built_in">size</span>()) <span class="keyword">continue</span>;  <span class="comment">// 越界了，直接跳过</span></span><br><span class="line">        <span class="keyword">if</span> (!visited[nextx][nexty]) &#123; <span class="comment">// 没有访问过的</span></span><br><span class="line">            visited[nextx][nexty] = <span class="literal">true</span>; </span><br><span class="line">            <span class="built_in">dfs</span>(grid, visited, nextx, nexty);</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>BFS</h1><p>广搜代码模板，该模板针对的是四方格的地图：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> dir[<span class="number">4</span>][<span class="number">2</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;; <span class="comment">// 表示四个方向</span></span><br><span class="line"><span class="comment">// grid 是地图，也就是一个二维数组</span></span><br><span class="line"><span class="comment">// visited标记访问过的节点，不要重复访问</span></span><br><span class="line"><span class="comment">// x,y 表示开始搜索节点的下标</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; grid, vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt;&amp; visited, <span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; que; <span class="comment">// 定义队列</span></span><br><span class="line">    que.<span class="built_in">push</span>(&#123;x, y&#125;); <span class="comment">// 起始节点加入队列</span></span><br><span class="line">    visited[x][y] = <span class="literal">true</span>; <span class="comment">// 只要加入队列，立刻标记为访问过的节点</span></span><br><span class="line">    <span class="keyword">while</span>(!que.<span class="built_in">empty</span>()) &#123; <span class="comment">// 开始遍历队列里的元素</span></span><br><span class="line">        pair&lt;<span class="type">int</span> ,<span class="type">int</span>&gt; cur = que.<span class="built_in">front</span>(); </span><br><span class="line">        que.<span class="built_in">pop</span>(); <span class="comment">// 从队列取元素</span></span><br><span class="line">        <span class="type">int</span> curx = cur.first;</span><br><span class="line">        <span class="type">int</span> cury = cur.second; <span class="comment">// 当前节点坐标</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123; <span class="comment">// 开始想当前节点的四个方向左右上下去遍历</span></span><br><span class="line">            <span class="type">int</span> nextx = curx + dir[i][<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> nexty = cury + dir[i][<span class="number">1</span>]; <span class="comment">// 获取周边四个方向的坐标</span></span><br><span class="line">            <span class="keyword">if</span> (nextx &lt; <span class="number">0</span> || nextx &gt;= grid.<span class="built_in">size</span>() || nexty &lt; <span class="number">0</span> || nexty &gt;= grid[<span class="number">0</span>].<span class="built_in">size</span>())</span><br><span class="line">                <span class="keyword">continue</span>;<span class="comment">// 坐标越界了，直接跳过</span></span><br><span class="line">            <span class="keyword">if</span> (!visited[nextx][nexty]) &#123; <span class="comment">// 如果节点没被访问过</span></span><br><span class="line">                que.<span class="built_in">push</span>(&#123;nextx, nexty&#125;);  <span class="comment">// 队列添加该节点为下一轮要遍历的节点</span></span><br><span class="line">                visited[nextx][nexty] = <span class="literal">true</span>; <span class="comment">// 只要加入队列立刻标记，避免重复访问</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;DFS&lt;/h1&gt;
&lt;p&gt;回溯算法，其实就是dfs的过程，这里给出dfs的代码框架：&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/spa</summary>
      
    
    
    
    <category term="Algorithm" scheme="https://escapeey.cn/categories/Algorithm/"/>
    
    
    <category term="Algorithm" scheme="https://escapeey.cn/tags/Algorithm/"/>
    
  </entry>
  
</feed>
