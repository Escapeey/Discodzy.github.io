<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Escapeey`Blog</title>
  
  <subtitle>岂能尽如人意，但求无愧我心。</subtitle>
  <link href="https://escapeey.github.io/atom.xml" rel="self"/>
  
  <link href="https://escapeey.github.io/"/>
  <updated>2024-05-22T06:03:05.833Z</updated>
  <id>https://escapeey.github.io/</id>
  
  <author>
    <name>Escapeey</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>编译原理-自底向上的语法分析</title>
    <link href="https://escapeey.github.io/post/1cebdcd6.html"/>
    <id>https://escapeey.github.io/post/1cebdcd6.html</id>
    <published>2024-05-22T11:14:16.000Z</published>
    <updated>2024-05-22T06:03:05.833Z</updated>
    
    <content type="html"><![CDATA[<h1>自底向上的语法分析</h1><h2 id="自底向上的语法分析概述">自底向上的语法分析概述</h2><h2 id="算符优先分析法">算符优先分析法</h2><h2 id="LR分析法">LR分析法</h2><h2 id="语法分析程序的自动生成工具Yacc">语法分析程序的自动生成工具Yacc</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;自底向上的语法分析&lt;/h1&gt;
&lt;h2 id=&quot;自底向上的语法分析概述&quot;&gt;自底向上的语法分析概述&lt;/h2&gt;
&lt;h2 id=&quot;算符优先分析法&quot;&gt;算符优先分析法&lt;/h2&gt;
&lt;h2 id=&quot;LR分析法&quot;&gt;LR分析法&lt;/h2&gt;
&lt;h2 id=&quot;语法分析程序的自动生成工具Yacc&quot;&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>编译原理-自顶向下的语法分析</title>
    <link href="https://escapeey.github.io/post/cf412c72.html"/>
    <id>https://escapeey.github.io/post/cf412c72.html</id>
    <published>2024-05-21T13:28:07.000Z</published>
    <updated>2024-05-22T06:03:05.833Z</updated>
    
    <content type="html"><![CDATA[<h1>语法分析概述</h1><p>语法分析的主要工作是根据<strong>源语言</strong>的文法，判别某个<strong>单词序列</strong>是否是源语言的一个<strong>句子</strong></p><ul><li><strong>语言</strong>是满足一定<strong>组成规则</strong>的<strong>句子集合</strong></li><li><strong>句子</strong>是满足一定<strong>组成规则</strong>的<strong>单词序列</strong></li><li><strong>单词</strong>则是满足一定<strong>组成规则</strong>的<strong>字符串</strong></li><li>这些<strong>组成规则</strong>就是文法中的<strong>产生式</strong></li></ul><h2 id="两种方式">两种方式</h2><ul><li><strong>产生句子</strong>的方式：从文法的开始符号开始，逐步<strong>推导</strong>出这个单词序列，也称为<strong>自顶向下</strong>的语法分析<ul><li>递归子程序法</li><li>预测分析法(LL(1))</li></ul></li><li><strong>识别句子</strong>的方式：逐步将构成程序的单词序列<strong>归约</strong>为文法的<strong>开始符号</strong>，也称为<strong>自底向上</strong>的语法分析<ul><li>算符优先分析法</li><li>LR(0)、SLR(1)、LR(1)、LALR(1)</li></ul></li></ul><p>无论是自顶向下还是自底向上，语法分析器都是<strong>自左到右</strong>地扫描输入<strong>单词序列</strong>，每次读入一个单词，针对输入单词序列<strong>建立一颗语法分析树</strong><br>不同的分析方法对应着<strong>不同的构建树的方式</strong></p><h2 id="语法分析时的恢复策略">语法分析时的恢复策略</h2><ul><li><strong>紧急方式恢复策略</strong>：丢弃输入记号，直到发现某个指定的同步记号为止。同步记号通常是定界符（分号或end标记），标志着一条新语句的开始。</li><li><strong>短语级恢复策略</strong>：对剩余输入做局部纠正</li></ul><h1>自顶向下的语法分析面临的问题</h1><ul><li><strong>基本思想</strong>:<ul><li>从文法的开始符号出发，寻求所给的输入符号串的一个<strong>最左推导</strong>。</li><li>即从树根S开始，构造所给输入符号串的<strong>语法树</strong></li></ul></li><li>自顶向下分析实际上是一种<strong>试探性</strong>的过程，可能导致分析效率极低甚至失败</li><li>面临三种问题</li></ul><h2 id="二义性问题">二义性问题</h2><p>解决方法1：改造文法，引入新的文法变量<br>解决办法2：根据优先级关系，保证<strong>高优先级运算符优先</strong>的原则</p><h2 id="左递归引起的无穷推导问题">左递归引起的无穷推导问题</h2><ul><li><strong>左递归</strong>: 如果存在推导 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><msup><mo>⇒</mo><mo>+</mo></msup><mi>α</mi><mi>A</mi><mi>β</mi></mrow><annotation encoding="application/x-tex">A \Rightarrow^+ \alpha A\beta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7713em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel"><span class="mrel">⇒</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7713em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">+</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span></span></span></span>，则称文法G是递归的，当 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi><mo>=</mo><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\alpha = \epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">ϵ</span></span></span></span> 时称之为左递归；</li><li><strong>间接左递归</strong>: 如果 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><msup><mo>⇒</mo><mo>+</mo></msup><mi>α</mi><mi>A</mi><mi>β</mi></mrow><annotation encoding="application/x-tex">A \Rightarrow^+ \alpha A\beta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7713em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel"><span class="mrel">⇒</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7713em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">+</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span></span></span></span>至少需要两步推导，则称文法G是间接递归的，当 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi><mo>=</mo><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\alpha = \epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">ϵ</span></span></span></span> 时称之为间接左递归；</li><li><strong>直接左递归</strong>: 如果文法G中存在形如 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>→</mo><mi>α</mi><mi>A</mi><mi>β</mi></mrow><annotation encoding="application/x-tex">A \rightarrow \alpha A\beta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span></span></span></span>的产生式，则称文法G是直接递归的，当 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi><mo>=</mo><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\alpha = \epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">ϵ</span></span></span></span> 时称之为直接左递归。</li></ul><h2 id="回溯问题">回溯问题</h2><ul><li>文法中每个语法变量A的产生式右部称为A的<strong>候选式</strong></li><li>如果A有多个候选式存在<strong>公共前缀</strong>，则自顶向下的语法分析程序将无法根据当前输入符号准确地选择用于推导的产生式，只能试探。</li><li>当试探不成功时就需要退回到上一步推导，看A是否还有其它的候选式，这就是<strong>回溯</strong>(backtracking)。</li></ul><p>我们将采用提取左因子的方法来改造文法，以便减少推导过程中回溯现象的发生<br>当然，单纯通过提取左因子无法彻底避免回溯现象的发生。</p><h1>对上下文无关文法的改造</h1><h2 id="消除二义性">消除二义性</h2><p>改造的方法就是通过<strong>引入新的语法变量</strong>等，使文法含有更多的信息。</p><h3 id="二义性举例：">二义性举例：</h3><img src="..\..\img\CompilerPrinciples\二义性文法举例.png" width="100%" height="100%" align="middle"><p><strong>分析：</strong><br>根据if语句中else与then配对情况将其分为<strong>配对的语句</strong>和<strong>不配对的语句</strong>两类。<br>上述if语句的文法没有对这两个不同的概念加以区分，只是简单地将它们都定义为&lt;stmt&gt;，从而导致该文法是二义性的<br><strong>解决：</strong><br><img src="..\..\img\CompilerPrinciples\二义性文法举例解决.png" width="100%" height="100%" align="middle"></p><h2 id="消除左递归">消除左递归</h2><h3 id="消除直接左递归">消除直接左递归</h3><ul><li>直接左递归的消除(转换为右递归)</li><li>引入新的变量<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>A</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">A&#x27;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7519em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span> ，将左递归产生式<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>→</mo><mi>A</mi><mi>α</mi><mi mathvariant="normal">∣</mi><mi>β</mi></mrow><annotation encoding="application/x-tex">A\rightarrow A\alpha | \beta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span></span></span></span> 替换为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>→</mo><mi>β</mi><msup><mi>A</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">A\rightarrow \beta A&#x27;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.9463em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>A</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo>→</mo><mi>α</mi><msup><mi>A</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mi mathvariant="normal">∣</mi><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">A&#x27; \rightarrow \alpha A&#x27; | \epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7519em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0019em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mord">∣</span><span class="mord mathnormal">ϵ</span></span></span></span><br><img src="..\..\img\CompilerPrinciples\消除左递归1.png" width="100%" height="100%" align="middle"></li></ul><h3 id="具体做法">具体做法</h3><img src="..\..\img\CompilerPrinciples\消除左递归2.png" width="100%" height="100%" align="middle"><ul><li>上述方法<strong>只能消除直接</strong>左递归，<strong>无法消除间接</strong>左递归</li><li>消除<strong>间接左递归</strong>的<strong>基本思想</strong>：为语法<strong>变量编号</strong>，再采用<strong>带入法</strong>将<strong>间接左递归变为直接左递归</strong>，然后采用上述方法来消除直接左递归</li></ul><h3 id="消除所有左递归">消除所有左递归</h3><img src="..\..\img\CompilerPrinciples\消除左递归算法.png" width="100%" height="100%" align="middle"><img src="..\..\img\CompilerPrinciples\消除左递归算法例子.png" width="100%" height="100%" align="middle"><h2 id="提取左因子（解决回溯问题）">提取左因子（解决回溯问题）</h2><p><strong>方法：</strong><br><img src="..\..\img\CompilerPrinciples\提取左因子.png" width="100%" height="100%" align="middle"><br>提取左因子并不能完全消除回溯</p><p><strong>例子：</strong><br><img src="..\..\img\CompilerPrinciples\提取左因子例子.png" width="100%" height="100%" align="middle"></p><h1>LL(1)文法</h1><ul><li><strong>不确定</strong>的自顶向下分析<ul><li>分析需要回溯，导致分析存在不确定性</li><li>代价高、效率低，实际中几乎不被采用</li></ul></li><li><strong>确定</strong>的自顶向下分析<ul><li>不能处理所有文法，这里讨论什么样的文法可以进行确定的自顶向下分析</li></ul></li><li>LL(1)文法就是可以<strong>彻底消除回溯</strong>实现<strong>确定的</strong>自顶向下分析的文法</li><li>文法要求：<ul><li>无二义性</li><li>无左递归</li><li>任意一个语法变量A的各个候选式所能推导出的<strong>第一个终结符</strong>必须各不相同</li></ul></li></ul><h1>预测分析法</h1><h1>递归下降分析法</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;语法分析概述&lt;/h1&gt;
&lt;p&gt;语法分析的主要工作是根据&lt;strong&gt;源语言&lt;/strong&gt;的文法，判别某个&lt;strong&gt;单词序列&lt;/strong&gt;是否是源语言的一个&lt;strong&gt;句子&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;语言&lt;/strong</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>软件工程</title>
    <link href="https://escapeey.github.io/post/7821ac43.html"/>
    <id>https://escapeey.github.io/post/7821ac43.html</id>
    <published>2024-05-10T20:30:46.000Z</published>
    <updated>2024-05-22T06:03:05.837Z</updated>
    
    <content type="html"><![CDATA[<h1>软件生命周期</h1><p><strong>核心内容：软件生命周期的各过程</strong><br><img src="../img/Software/软件生命周期.png" width="100%" height="100%" align="middle"></p><h1>软件工程学概述</h1><h2 id="概念定义">概念定义</h2><ul><li>软件工程是指导计算机软件开发和维护的一门工程学科。</li><li>采用<strong>工程</strong>的概念、原理、技术和方法来开发与维护软件。把正确的<strong>管理技术</strong>和当前能够得到的最好的<strong>技术方法</strong>结合起来，以经济地开发出高质量的软件并<strong>有效地维护</strong>它，这就是软件工程。</li></ul><h2 id="本质特性">本质特性</h2><ul><li>软件工程关注于大型程序的构造</li><li>软件工程的中心课题是控制复杂性</li><li>软件经常变化</li><li>开发软件的效率非常重要</li><li>和谐地合作是开发软件的关键</li><li>必须有效地支持它的用户</li><li>两种背景的人创造产品这个特性与前两个特性紧密相关</li></ul><h2 id="基本原理">基本原理</h2><ul><li>用分阶段的生命周期计划严格管理</li><li>坚持进行阶段评审</li><li>实行严格的产品控制</li><li>采用现代程序设计技术</li><li>结果应能清楚地审查</li><li>开发小组的人员应该少而精</li><li>承认不断改进软件工程实践的必要性</li></ul><h2 id="三要素">三要素</h2><ul><li><strong>方法</strong>：完成软件开发的各项任务的技术方法，回答“怎样做”的问题</li><li><strong>工具</strong>：为运用方法而提供的自动的或半自动的软件工程支撑环境</li><li><strong>过程</strong>：为了获得高质量的软件所需要完成的一系列任务的框架，它规定了完成各项任务的工作步骤</li></ul><h2 id="方法学">方法学</h2><h3 id="传统方法学">传统方法学</h3><ul><li>也称为生命周期方法学或结构化范型。</li><li>软件生命周期的全过程依次划分为若干个阶段，然后顺序地完成每个阶段的任务。</li><li>每个阶段的开始和结束都有严格标准，对于任何两个相邻的阶段而言，前一阶段的结束标准就是后一阶段的开始标准。</li></ul><h3 id="面向对象方法">面向对象方法</h3><p>面向对象方法把数据和行为看成是同等重要的，它是一种以数据为主线，把数据和对数据的操作紧密地结合起来的方法</p><h4 id="四个要点">四个要点</h4><ul><li>把对象(object)作为融合了数据及在数据上的操作行为的统一的软件构件。</li><li>把所有对象都划分成类(class)。</li><li>按照父类与子类的关系，把若干个相关类组成一个层次结构的系统。</li><li>对象彼此间仅能通过发送消息互相联系</li></ul><h4 id="基本原则">基本原则</h4><ul><li>尽量模拟人类习惯的思维方式</li><li>从而使描述问题的<strong>问题空间</strong>(也称为问题域)与实现解法的<strong>解空间</strong>(也称为求解域)在<strong>结构上尽可能一致</strong>。</li></ul><h4 id="优点">优点</h4><ul><li><strong>降低</strong>了软件产品的<strong>复杂性</strong>，<strong>提高</strong>了软件的<strong>可理解性</strong>，<strong>简化</strong>了软件<strong>开发和维护工作</strong></li><li>面向对象方法特有的继承性和多态性，进一步提高了面向对象软件的<strong>可重用性</strong>。</li></ul><h2 id="软件过程">软件过程</h2><ul><li>软件过程是为了获得高质量软件所需要完成的一系列任务的框架，它规定了完成各项任务的<strong>工作步骤</strong>。</li><li>软件过程描述为了开发出客户需要的软件，什么人（who）、在什么时候（when）、做什么事（what）以及怎样（how）做这些事以实现某一个特定的具体目标。</li></ul><h3 id="瀑布模型">瀑布模型</h3><img src="../img/Software/瀑布模型.png" width="70%" height="70%" align="middle"><h4 id="特点">特点</h4><ul><li>阶段间具有顺序性和依赖性</li><li>推迟实现的观点</li><li>质量保证的观点</li></ul><h4 id="带反馈的瀑布模型">带反馈的瀑布模型</h4><img src="../img/Software/带反馈的瀑布模型.png" width="70%" height="70%" align="middle"><p><strong>实线箭头表示开发过程，虚线箭头表示维护过程</strong></p><ul><li>当在后面阶段发现前面阶段的错误时，需要沿图中左侧的<strong>反馈线返回</strong>前面的阶段，修正前面阶段的产品之后再回来继续完成后面阶段的任务。</li></ul><h3 id="快速原型模型">快速原型模型</h3><img src="../img/Software/快速原型模型.png" width="70%" height="70%" align="middle"><p>快速原型是快速建立起来的，可以在计算机上运行的程序，它所能完成的功能往往是最终产品能完成的功能的一个<strong>子集</strong>。</p><h4 id="相邻阶段无反馈的原因">相邻阶段无反馈的原因</h4><ul><li>原型系统<strong>已经通过与用户交互而得到验证</strong>，据此产生的<strong>规格说明文档</strong>正确地描述了用户需求，因此，在开发过程的后续阶段不会因为发现了规格说明文档的错误而进行较大的返工。</li></ul><h3 id="增量模型">增量模型</h3><img src="../img/Software/增量模型.png" width="70%" height="70%" align="middle"><ul><li>增量模型也称为渐增模型。核心思想是把软件产品作为一系列的<strong>增量构件</strong>来设计、编码、集成和测试。</li><li>第一个增量构件往往实现软件的基本需求，提供最核心的功能</li></ul><h4 id="优点-2">优点</h4><ul><li>能在较短时间内向用户提交可完成部分工作的产品</li><li>逐步增加产品功能可以使用户有较充裕的时间学习和适应新产品，从而减少一个全新的软件可能给客户组织带来的冲击。</li></ul><h3 id="螺旋模型">螺旋模型</h3><img src="../img/Software/螺旋模型.png" width="70%" height="70%" align="middle"><ul><li>在每个阶段之前都<strong>增加了风险分析过程</strong>的快速原型模型。</li></ul><h3 id="喷泉模型">喷泉模型</h3><img src="../img/Software/喷泉模型.png" width="70%" height="70%" align="middle"><ul><li>典型的<strong>面向对象</strong>的软件过程模型</li><li>图中在一个阶段内的向下箭头代表该<strong>阶段内的迭代</strong></li><li>图中较小的圆圈代表维护，圆圈较小象征着采用了面向对象范型之后维护时间缩短了。</li></ul><h3 id="Rational统一过程">Rational统一过程</h3><ul><li>Rational Unified Process 简称 <strong>RUP</strong></li><li>RUP总结了经过多年商业化验证的6条最有效的软件开发经验，这些经验被称为“最佳实践”<ul><li>迭代式开发</li><li>管理需求</li><li>使用基于构件的体系结构</li><li>可视化建模</li><li>验证软件质量</li><li>控制软件变更</li></ul></li></ul><h4 id="软件生命周期">软件生命周期</h4><ul><li><strong>初始阶段</strong>： 建立业务模型，定义最终产品视图，并且确定项目的范围。</li><li><strong>精化阶段</strong>： 设计并确定系统的体系结构，制定项目计划，确定资源需求。</li><li><strong>构建阶段</strong>： 开发出所有构件和应用程序，把它们集成为客户需要的产品，并且详尽地测试所有功能。</li><li><strong>移交阶段</strong>： 把开发出的产品提交给用户使用</li></ul><h4 id="RUP中的迭代">RUP中的迭代</h4><p>每次迭代都是一个小的瀑布模型</p><h3 id="敏捷过程-Agile">敏捷过程 Agile</h3><ul><li>最早是为了与传统的瀑布软件开发模式相比较，所以当时的方法叫做轻量级方法（Light weight methods）</li></ul><h4 id="敏捷过程核心思想">敏捷过程核心思想</h4><img src="../img/Software/敏捷过程核心思想.png" width="70%" height="70%" align="middle"><h4 id="四条价值观">四条价值观</h4><ul><li>人员交流重于过程与工具</li><li>软件产品重于长篇大论</li><li>客户协作重于合同谈判</li><li>随机应变重于循规蹈矩</li></ul><h4 id="敏捷更符合软件开发规律">敏捷更符合软件开发规律</h4><ul><li>软件更像一个活着的植物，软件开发是自底向上逐步有序的生长过程，类似于植物自然生长</li><li>敏捷开发遵循软件客观规律，不断的进行迭代增量开发，最终交付符合客户价值的产品</li></ul><h4 id="价值驱动-敏捷与传统瀑布型模式的最大区别">价值驱动 - 敏捷与传统瀑布型模式的最大区别</h4><ul><li><p>敏捷基于这种方式，可以实现研发过程的持续高可视性、高可适应性，更早且持续产出业务价值，更早发现和解决风险。</p></li><li><p>瀑布模型 基于 <strong>计划驱动</strong></p></li></ul><h3 id="敏捷常用的工程方法">敏捷常用的工程方法</h3><h4 id="极限编程">极限编程</h4><img src="../img/Software/极限编程.png" width="70%" height="70%" align="middle"><h4 id="整体开发过程">整体开发过程</h4><img src="../img/Software/整体开发过程.png" width="70%" height="70%" align="middle"><h4 id="Scrum模型">Scrum模型</h4><ul><li><p>三大特点</p><ul><li>“可能性的”艺术 – <strong>关注当下</strong></li><li>团队自组织，自管理 – <strong>放权</strong></li><li>面对面沟通 – <strong>提高沟通</strong></li></ul></li><li><p>三种角色</p><ul><li>产品负责人 PO<ul><li>负责管理**产品待办事项表（Product Backlog）**并保证其对于客户和团队保持透明度；</li></ul></li><li>团队负责人 SM<ul><li>不要管理团队。</li></ul></li><li>开发团队 5-9 人</li></ul></li><li><p>三种工件</p><ul><li>产品待办事项表(产品Backlog)</li><li>冲刺待办事项表(Sprint Backlog)<ul><li>包含产品待办事项列表中当前 Sprint 的子集</li></ul></li><li>产品增量</li></ul></li><li><p>步骤</p><ul><li>Step1 头脑风暴</li><li>Step2 PO决定实现的功能</li><li>Step3 时间估计: 用扑克牌游戏进行时间估计</li><li>Step4 冲刺</li><li>Step5 评估 PO</li></ul></li></ul><h4 id="微软开发过程">微软开发过程</h4><ul><li>每一个生命周期发布一个递进的软件版本，各个生命周期持续、快速地迭代循环</li></ul><h1>可行性分析</h1><p>描绘<strong>物理系统</strong> -&gt; <strong>系统流程图</strong><br>描绘<strong>逻辑模型</strong> -&gt; <strong>数据流图</strong> / <strong>数据字典</strong><br><strong>主要内容</strong><br><img src="../img/Software/可行性分析主要内容.png" width="100%" height="100%" align="middle"></p><h2 id="可行性研究的任务">可行性研究的任务</h2><h3 id="含义">含义</h3><ul><li>用最小的代价，在尽可能短的时间内（一般占总工作量的5％到10％）确定<strong>能否解决问题</strong>，以及<strong>是否值得解决</strong>的问题 。</li><li>因此，可行性研究的目的是“<strong>做还是不做</strong>”，而非“如何去做”。</li></ul><h3 id="内容">内容</h3><h4 id="从技术可行性">从技术可行性</h4><ul><li>开发风险</li><li>资源有效性</li><li>技术方案<br>表述为：<strong>做得了吗？做得好吗？做得快吗？</strong></li></ul><h4 id="经济可行性">经济可行性</h4><ul><li>度量系统解决方案的性能价格比</li></ul><h4 id="用户操作可行性">用户操作可行性</h4><ul><li>用户组织的结构、工作流程、管理模式及规范是否适合目标系统的运行，是否互不相容。</li><li>现有的人员素质能否胜任对目标系统的操作？</li><li>如果进行培训，时间是多少？成本如何？</li></ul><h4 id="社会环境可行性">社会环境可行性</h4><ul><li>市场</li><li>政策</li><li>法律</li></ul><h2 id="可行性研究过程">可行性研究过程</h2><ol><li>确定项目规模和目标；</li><li>研究当前正在运行的系统；</li><li>建立新系统的高层逻辑模型；</li><li>导出和评价各种方案；</li><li>推荐可行的方案；</li><li>草拟开发计划；</li><li>编写可行性研究报告，提交审查</li></ol><h2 id="系统流程图">系统流程图</h2><h3 id="基本符号">基本符号</h3><img src="../img/Software/系统流程图基本符号.png" width="100%" height="100%" align="middle"><h3 id="例子">例子</h3><h4 id="系统目标">系统目标</h4><ol><li>管理仓库各类零件数量的变化，并及时修改（更新库存清单文件）。</li><li>报告库存零件达到库存量临界值的订货报告，产生订货信息。</li><li>生成订货报表。</li></ol><h4 id="构成部件">构成部件</h4><ol><li>输入终端CRT</li><li>事务处理部件（库存清单程序）</li><li>磁盘（存放库存清单主文件）</li><li>磁带（存放订货信息）</li><li>报告生成部件（报告生成程序）</li><li>打印的文档（订货报告）</li></ol><h4 id="绘制方法">绘制方法</h4><img src="../img/Software/系统流程图示例.png" width="100%" height="100%" align="middle"><h2 id="数据流图">数据流图</h2><p>以图形方式来表达系统的逻辑功能、数据在系统内部的逻辑流向和逻辑变换过程</p><h3 id="基本符号-2">基本符号</h3><img src="../img/Software/数据流图基本符号.png" width="100%" height="100%" align="middle"><h3 id="附加符号">附加符号</h3><p>*****表示数据流之间“与”的关系（同时存在）<br><strong>+</strong> 表示数据流之间“或”的关系<br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⊕</mo></mrow><annotation encoding="application/x-tex">\oplus</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord">⊕</span></span></span></span> 表示数据流之间 “异或”的关系（不能同时存在）<br><img src="../img/Software/数据流图附加符号.png" width="100%" height="100%" align="middle"></p><h3 id="画数据流图的步骤">画数据流图的步骤</h3><ul><li>Step1：画顶层数据流图,包括数据源点、终点，整个软件系统作为一个数据处理，流入和流出系统的数据流。</li><li>Step2：一级细化，即画分层数据流图，逐层分解数据处理，得到功能级数据流图</li><li>Step3：二级细化，进一步分解功能级数据流图到涉及功能具体的实现为止</li></ul><h3 id="数据流图的示例">数据流图的示例</h3><h4 id="问题描述">问题描述</h4><ul><li>工厂采购部每天需要一张订货报表，报表按零件编号编排，表中列出所有需要再次订货的零件（包括零件编号，零件名称，定货数量，当前价格，目前主要供应者，次要供应者）。</li><li>零件入库或出库称为<strong>事务</strong>，通过放在仓库中的CRT终端把事务报告给定货系统。</li><li>当某种零件的库存量少于库存临界值时就应该再次订货。</li></ul><h4 id="问题分析">问题分析</h4><ul><li><strong>源点/终点</strong>：仓库管理员/采购员</li><li><strong>处理</strong>：处理事务、产生订货报表</li><li><strong>数据存储</strong>：订货信息、库存清单</li><li><strong>数据流</strong>：订货报表、事务</li></ul><h4 id="步骤">步骤</h4><ul><li><p>Step1：绘制基本系统模型<br><img src="../img/Software/数据流图的示例Step1.png" width="100%" height="100%" align="middle"></p></li><li><p>Step2：得到功能级数据流图<br><img src="../img/Software/数据流图的示例Step2.png" width="100%" height="100%" align="middle"></p></li><li><p>Step3：细化到功能实现级别<br><img src="../img/Software/数据流图的示例Step3.png" width="100%" height="100%" align="middle"></p></li></ul><h3 id="注意事项">注意事项</h3><ol><li><p>若一张数据流图中包含的数据处理多于7时，其含义将难以领会，此时数据流图应该分层绘制<br><img src="../img/Software/数据流图注意事项.png" width="100%" height="100%" align="middle"></p></li><li><p>数据流图分层细化时必须保持信息的连续性，即细化前后对应功能的输入输出数据必须相同。<br><img src="../img/Software/数据流图注意事项1.png" width="100%" height="100%" align="middle"></p></li><li><p>数据存储和数据流都是数据，仅所处的状态不同，数据存储是静止状态的数据，数据流是运动状态的数据。</p></li><li><p>所有的数据流都必须以一个数据处理开始，或以一个数据处理结束。即，<strong>每个数据处理都应该有输入输出</strong>。</p></li></ol><h3 id="各成分命名要求">各成分命名要求</h3><h4 id="数据流-或数据存储">数据流(或数据存储)</h4><ul><li>代表整个数据流(或数据存储)的内容</li><li>不要使用缺乏具体含义的名字；</li><li>除流入流出<strong>数据存储</strong>的数据流可以命名相同之外，其他的数据流命名需要唯一，即便是同样内容</li></ul><h4 id="数据处理-或数据加工">数据处理(或数据加工)</h4><ul><li>先为数据流命名，再为处理命名，通常1个动词+宾语的命名方式</li><li>如果必须用两个动词才能描述整个处理的功能，则把这个处理再分解成两个处理可能更恰当些。</li><li>若处理的命名比较困难可能是处理包含太多功能</li></ul><h3 id="注意事项及命名练习">注意事项及命名练习</h3><p>阅读下图所示的数据流图，找出其中错误之处<br><img src="../img/Software/注意事项及命名练习.png" width="100%" height="100%" align="middle"></p><img src="../img/Software/注意事项及命名练习答案.png" width="100%" height="100%" align="middle"><h2 id="数据字典">数据字典</h2><h3 id="数据字典的任务">数据字典的任务</h3><ul><li>对于数据流图中出现的所有被命名的图形元素在字典中作为一个词条加以定义，<strong>使得每一个图形元素的名字都有一个确切的解释</strong></li></ul><h3 id="数据字典的定义">数据字典的定义</h3><ul><li>定义：是关于数据的信息集合，即对数据流图中包含的所有元素定义的集合。</li><li>数据字典和数据流图共同构成系统的逻辑模型，有数据字典，数据流图就不严格；没有数据流图，数据字典难于发挥作用。</li></ul><h3 id="定义内容">定义内容</h3><ul><li><strong>数据流</strong>：来源、去向、组成、流通量</li><li><strong>数据元素</strong>：名称、别名、取值范围、含义、数据长度、小数位数、简单描述</li><li><strong>数据存储</strong>：数据结构及数据存放规则</li><li><strong>数据处理</strong>：数据处理的逻辑功能和主要算法</li></ul><h3 id="数据字典举例">数据字典举例</h3><h4 id="数据流定义">数据流定义</h4><p><strong>对数据流和数据存储来说，需要定义到数据元素为止</strong><br><img src="../img/Software/数据字典示例.png" width="100%" height="100%" align="middle"></p><h4 id="数据项定义">数据项定义</h4><p>由数据元素组成数据的方式</p><ul><li>顺序：以确定次序连接两个或多个分量</li><li>选择：从两个或多个可能元素中选取一个</li><li>重复：把指定的分量重复零次或多次。</li><li>可选：一个分量是可有可无的</li></ul><img src="../img/Software/数据字典中的符号表示.png" width="100%" height="100%" align="middle"><h4 id="数据项的定义练习">数据项的定义练习</h4><ul><li>某酒店所提供的电话服务系统的功能为：</li><li>客人可以通过拨分机号联络酒店内的其他房间，也可拨外线号码与酒店外联络。</li><li>分机号从8201至8299。</li><li>外线号码需先拨0，然后加拨市话号码或长途电话号码</li><li>长途电话号码由区号和市话号码组成，其中区号可以为010、021~029、0300~0999中的任意一个数字串</li><li>市话号码是任意7位或8位长度的数字串。<br><img src="../img/Software/数据项的定义练习答案.png" width="100%" height="100%" align="middle"></li></ul><h4 id="加工定义">加工定义</h4><p>数据处理的定义可以采用结构化语言、IPO图、伪代码PDL、判定树、判定表等方式描述</p><h2 id="成本-效益分析">成本/效益分析</h2><p>从经济角度分析新系统的开发是否能盈利，帮助使用部门正确做出是否投资的决定。</p><h3 id="常用的成本估算技术">常用的成本估算技术</h3><ul><li><p>代码行技术</p><ul><li><strong>成本＝总代码行数×每行的平均成本</strong></li><li>根据经验和历史数据，确定上面两个变量。此外，工资水平也是应考虑的一个重要因素。</li></ul></li><li><p>任务分解技术</p><ul><li>根据生命周期瀑布模型，对开发工作将进行任务分解，分别估算每个任务的成本，累加得到总成本</li><li><strong>成本＝所需的总人月数×每人月的成本</strong></li></ul></li><li><p>自动估计成本技术</p><ul><li>利用自动估计成本技术的软件工具进行计算</li></ul></li><li><p>经验统计估计模型</p><ul><li>Walston-Felix（IBM）模型</li><li>Putnam 估算模型（动态多变量参数模型）</li><li>COCOMO 模型</li></ul></li></ul><h3 id="常用的效益度量方法">常用的效益度量方法</h3><ol><li>货币的时间价值</li><li>投资回收期</li><li>纯收入</li><li>投资回收率</li></ol><h3 id="成本-效益分析步骤">成本/效益分析步骤</h3><ul><li>估计开发成本、运行费用和新系统带来的经济效益</li><li>比较新系统的开发成本和经济效益。</li></ul><h3 id="可行性研究报告">可行性研究报告</h3><ul><li>根据DFD+DD、成本/效益分析等方面，进行技术可行性、经济可行性、用户操作可行性、社会环境可行性等方面评价，完成可行性研究报告，并提交审查</li><li>在审查过程中出现问题需要更改，通过多次迭代完成最终可行性报告，从而实现“是否做”的判断</li></ul><h1>需求分析</h1><img src="../img/Software/需求分析逻辑关系.png" width="100%" height="100%" align="middle"><h2 id="需求分析概述">需求分析概述</h2><h3 id="需求的层次">需求的层次</h3><img src="../img/Software/需求的层次.png" width="100%" height="100%" align="middle"><h3 id="需求分析方法需遵守的法则">需求分析方法需遵守的法则</h3><ul><li>必须理解并<strong>描述问题的信息域</strong>，根据这条准则应该建立<strong>数据模型</strong>。</li><li>必须<strong>定义</strong>软件应完成的<strong>功能</strong>，这条准则要求建立<strong>功能模型</strong>。</li><li>必须描述作为外部事件结果的<strong>软件行为</strong>，这条准则要求建立<strong>行为模型</strong></li><li>必须对<strong>描述信息、功能和行为的模型</strong>进行分解，用<strong>层次</strong>的方式展示细节。</li></ul><h2 id="与用户沟获取需求的方法">与用户沟获取需求的方法</h2><h3 id="需求收集过程">需求收集过程</h3><ul><li>访谈<ul><li>**用户（user）**是一种泛称，它可细分为 <strong>客户（customer）</strong>、**最终用户（the end user）**和 <strong>间接用户（或称为关系人）</strong>。<br>掏钱买产品的用户称为客户，而真正操作产品的用户叫最终用户。客户与最终用户可能是同一个人也可能不是同一个人。</li></ul></li><li>面向数据流自顶向下求精</li><li>简易的应用规格说明技术</li><li>快速建立软件原型</li></ul><h2 id="分析建模与规格说明">分析建模与规格说明</h2><h3 id="需求分析应建立的模型">需求分析应建立的模型</h3><ul><li><strong>数据模型</strong>：E-R图(ERD)，描述数据对象，数据对象之间的关系；</li><li><strong>功能模型</strong>：数据流图(DFD)，描述数据在系统中流动，变换的逻辑过程；</li><li><strong>行为模型</strong>：状态转换图(STD)，描绘了系统的各种行为模式和在不同状态之间转换的方式；</li><li><strong>模型中心</strong>：数据字典 (DD)。</li></ul><h3 id="撰写软件需求规格说明书">撰写软件需求规格说明书</h3><h2 id="功能模型构建">功能模型构建</h2><h2 id="数据模型构建">数据模型构建</h2><h2 id="行为模型构建">行为模型构建</h2><h2 id="需求实现验证">需求实现验证</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;软件生命周期&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;核心内容：软件生命周期的各过程&lt;/strong&gt;&lt;br&gt;
&lt;img src=&quot;../img/Software/软件生命周期.png&quot; width=&quot;100%&quot; height=&quot;100%&quot; align=&quot;middle&quot;&gt;&lt;/p&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>编译原理-词法分析</title>
    <link href="https://escapeey.github.io/post/8254dc99.html"/>
    <id>https://escapeey.github.io/post/8254dc99.html</id>
    <published>2024-04-22T19:25:34.000Z</published>
    <updated>2024-05-22T06:03:05.837Z</updated>
    
    <content type="html"><![CDATA[<h1>词法分析器的功能</h1><ul><li>功能：输入源程序，输出单词符号。即：<strong>把构成源程序的字符串转换成“等价的”单词序列</strong><ul><li>根据词法规则识别及组合单词，进行词法检查</li><li>对数字常数完成数字字符串到二进制数值的转换</li><li>删去空格和注释等不影响程序语义的字符</li></ul></li></ul><h2 id="单词的分类与表示-词法分析器的输出">单词的分类与表示&amp;词法分析器的输出</h2><h3 id="单词的内部形式">单词的内部形式</h3><p>二元组 (种别, 属性值)</p><ul><li><strong>种别</strong>：表示种类(可以用整数编码或宏)</li><li><strong>属性值</strong>：不同的单词不同的值</li></ul><h4 id="按单词种类分类">按单词种类分类</h4><img src="..\..\img\CompilerPrinciples\单词的内部形式-按单词种类分类.png" width="100%" height="100%" align="middle"><h4 id="固定数量单词采用一符一类">固定数量单词采用一符一类</h4><img src="..\..\img\CompilerPrinciples\单词的内部形式-一符一类.png" width="100%" height="100%" align="middle"><h3 id="存储方式">存储方式</h3><p>问题：如何存储<strong>标识符和常量</strong>的属性值</p><ul><li>方法1：用标识符和常量<strong>本身的值</strong>表示</li><li>方法2：用<strong>指针</strong>表示</li></ul><h4 id="本身的值">本身的值</h4><ul><li>不同值存储空间长度不同</li><li>往往需要对长度加以限制，意味着要截断</li></ul><h4 id="用指针表示">用指针表示</h4><ul><li>指针长度固定-&gt;属性值的长度相同</li><li>间接访存-&gt;由于词法分析器要兼顾符号表的查填和维护，间接访存增加负担</li></ul><h3 id="例子">例子</h3><img src="..\..\img\CompilerPrinciples\单词的分类与表示-例子.png" width="100%" height="100%" align="middle"><h2 id="源程序的输入缓冲与预处理">源程序的输入缓冲与预处理</h2><p>源程序以<strong>字符流形式</strong>存储于外部介质<br>为正确识别单词，编译程序需要一系列相关处理</p><ul><li><strong>超前搜索和回退</strong><ul><li>标识符的识别，或双字符运算符（**, &lt;=, &lt;&gt;）</li><li>回退操作修正超前搜索</li></ul></li><li><strong>缓冲区</strong><ul><li>假定源程序存储在磁盘上，这样每读一个字符就需要访问一次磁盘，效率显然是很低的。</li><li>一次性从磁盘读取给定大小的部分源程序</li></ul></li><li><strong>空白字符的剔除</strong><ul><li>剔除源程序中的无用符号、空格、换行、注释等</li></ul></li></ul><h3 id="输入缓冲区">输入缓冲区</h3><img src="..\..\img\CompilerPrinciples\词法分析-输入缓冲区.png" width="100%" height="100%" align="middle"><ul><li>单缓冲区存在的问题<ul><li>缓冲区内容用完后，等待新的输入需要等待，应该避免类似的等待</li><li>缓冲区尾部可能只包含单词的一部分，载入下一部分程序时，当前缓冲区的内容被覆盖，最坏情况下可识别的单词长度只能为1，而且无法执行超前搜索</li></ul></li><li>采用<strong>双缓冲区</strong><br><img src="..\..\img\CompilerPrinciples\词法分析-双缓冲区.png" width="100%" height="100%" align="middle"></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">if forward在缓冲区第一部分末尾 then</span><br><span class="line">    重装缓冲区第二部分;</span><br><span class="line">    forward := forward +1</span><br><span class="line">if forward在缓冲区第二部分末尾 then</span><br><span class="line">    重装缓冲区第一部分;</span><br><span class="line">    将forward移到缓冲区第一部分开始</span><br><span class="line">其他情况且当前字符不是EOF </span><br><span class="line">    forward:= forward +1;</span><br></pre></td></tr></table></figure><ul><li>令缓冲区大小为2N，则双缓冲区的每一个大小是N，双缓冲技术将可识别单词的长度扩展到N</li><li>每次移动向前指针都需要做<strong>两次测试</strong>:<ul><li>是否到缓冲区末尾</li><li>当前字符是否是EOF</li></ul></li><li><strong>修正方法</strong>：采用带标记缓冲区，即两个缓冲区的末尾处各设置一个“EOF”标志<ul><li>如果当前字符是“EOF”，就再判断是否到达缓冲区末尾，将移动向前指针需要的两次测试减少到 <strong>(N+1)/N</strong></li></ul></li></ul><h2 id="词法分析阶段的错误处理">词法分析阶段的错误处理</h2><h3 id="非法字符检查">非法字符检查</h3><ul><li>维护一个合法字符集合，对于每一个输入字符，判断该字符是否属于该字符集合</li></ul><h3 id="单词拼写错误">单词拼写错误</h3><ul><li><strong>关键字拼写</strong>词法分析阶段<strong>无法检测</strong>，待语法分析阶段发现错误</li><li>标识符拼写错误，如3b78，处理方法有两种<ul><li>识别出整数3、标识符b78</li><li>错误的标识符</li></ul></li></ul><h3 id="注释或字符常量不封闭">注释或字符常量不封闭</h3><ul><li>会错误地将后续所有源程序看作是<strong>注释或者是字符串</strong>的一部分，影响正常程序分析</li><li>对注释或字符串长度加以限制，如注释长度不超过1行，字符串长度最大是256</li></ul><h3 id="变量重复说明">变量重复说明</h3><ul><li>当词法分析器<strong>兼顾符号表的查填工作时</strong>才能发现该错误</li><li>为了指出<strong>错误的位置</strong>，必须<strong>对源程序进行行列计数</strong></li><li>出错信息可以夹在源程序发生错误的地方（便于修改，但容易弄乱源程序）</li><li>出错信息也可以收集起来统一处理</li></ul><h3 id="错误恢复与续编译">错误恢复与续编译</h3><ul><li>词法分析阶段的错误使得编译无法继续进行，需要采取措施使得编译继续下去</li><li>方法<ul><li>错误校正：极其困难</li><li><strong>紧急方式恢复(panic-mode recovery)</strong>：反复删掉剩余输入最前面的字符，直到词法分析器能发现一个正确的单词为止。</li></ul></li></ul><h2 id="词法分析器的位置">词法分析器的位置</h2><ul><li>独立地完成对源程序的一遍扫描，将单词序列以中间文件形式存储，作为语法分析的输入<ul><li>简化编译器的设计</li><li>提高编译器的效率</li><li>增强编译器的可移植性</li></ul></li><li>作为语法分析器的一个子程序<ul><li>整个编译程序简单紧凑</li></ul></li></ul><h1>单词的描述</h1><ul><li>根据正则文法构造等价的正则表达式</li><li>将正则表达式转换成等价的正则文法</li><li>构造有穷状态自动机</li><li>正则表达式转换为状态转换图</li></ul><h1>单词的识别</h1><h2 id="有穷状态自动机与单词识别的关系">有穷状态自动机与单词识别的关系</h2><ul><li>识别不同进制数的状态图 P91</li><li>单词识别的状态转换图表示 P96</li><li>利用状态转换图识别单词 P98</li><li>由正则文法构造状态转换图 P101</li><li>状态转换图的实现 P107<ul><li>状态矩阵</li><li>邻接表</li><li><strong>四个数组组成的结构</strong>，既可以实现数据压缩存储，又可以实现元素的快速访问 P117</li></ul></li></ul><h1>词法分析程序的自动生成</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;词法分析器的功能&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;功能：输入源程序，输出单词符号。即：&lt;strong&gt;把构成源程序的字符串转换成“等价的”单词序列&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;根据词法规则识别及组合单词，进行词法检查&lt;/li&gt;
&lt;li&gt;对数字常数完成数字字符串到二进制</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>编译原理-引论</title>
    <link href="https://escapeey.github.io/post/a7451f54.html"/>
    <id>https://escapeey.github.io/post/a7451f54.html</id>
    <published>2024-04-21T15:47:22.000Z</published>
    <updated>2024-05-22T06:03:05.833Z</updated>
    
    <content type="html"><![CDATA[<h1>程序设计语言</h1><ul><li><strong>机器语言</strong><ul><li>每一个具体的计算机系统都具有自己的指令系统</li><li>以<strong>0,1代码</strong>表示的机器指令所构成的语言</li></ul></li><li><strong>汇编语言</strong><ul><li>适当的助记符来表示指令中的操作和操作数</li><li>如含有：add、mov …</li></ul></li><li><strong>高级语言</strong><ul><li>其表示方法更接近于待解问题的表示方法</li><li>定义数据、描述运算、控制流程、传输数据</li><li>如：C、FORTRAN、PASCAL、C++、JAVA</li></ul></li></ul><h1>程序设计语言的翻译</h1><h2 id="翻译程序-Translator">翻译程序(Translator)</h2><ul><li>将某一种语言描述的程序(源程序——Source Program)翻译成<strong>等价</strong>的另一种语言描述的程序(目标程序——Object Program)的<strong>程序</strong>。<br><img src="..\..\img\CompilerPrinciples\翻译程序.png" width="100%" height="100%" align="middle"></li></ul><p><strong>翻译程序</strong> 包含 <strong>解释程序</strong> 和 <strong>编译程序</strong> 两种</p><h3 id="解释程序-Interpreter">解释程序(Interpreter)</h3><ul><li>边解释边执行：不断读取源程序的语句，解释语句，读取此语句需要的数据，根据执行结果读取下一条语句，继续解释执行，直到返回结果</li><li>类似于自然语言翻译的同声传译<br><img src="..\..\img\CompilerPrinciples\解释程序.png" width="100%" height="100%" align="middle"></li></ul><h3 id="编译程序-Compiler">编译程序(Compiler)</h3><ul><li>将源程序<strong>完整地</strong>转换成机器语言程序或汇编语言程序，然后再处理、执行的翻译程序</li><li><strong>高级语言程序</strong> → <strong>汇编/机器语言程序</strong></li><li>类似于自然语言翻译的通篇笔译</li></ul><h3 id="其他翻译程序">其他翻译程序</h3><ul><li><strong>汇编程序(Assembler)</strong><ul><li><strong>源</strong>程序是 <strong>汇编程序</strong>，<strong>目标</strong>程序是 <strong>机器程序</strong></li></ul></li><li><strong>交叉汇编程序(Cross Assembler)</strong><ul><li><strong>源</strong>程序是 <strong>汇编程序</strong>，<strong>目标</strong>程序是 <strong>另一台机器</strong>的 <strong>机器程序</strong></li></ul></li><li><strong>反汇编程序(Disassembler)</strong><ul><li><strong>源</strong>程序是 <strong>机器程序</strong>，<strong>目标</strong>程序是 <strong>汇编程序</strong></li></ul></li><li><strong>交叉编译程序(Cross Compiler)</strong></li></ul><h2 id="编译系统">编译系统</h2><p><strong>编译系统 = 编译程序 + 运行系统</strong><br><img src="..\..\img\CompilerPrinciples\编译系统.png" width="100%" height="100%" align="middle"></p><h1>编译程序的总体结构</h1><img src="..\..\img\CompilerPrinciples\编译程序的总体结构.png" width="100%" height="100%" align="middle"><ul><li><strong>模块分类</strong>：<ul><li><strong>分析</strong>：词法分析、语法分析、语义分析</li><li><strong>综合</strong>：中间代码生成、代码优化、目标代码生成</li><li><strong>辅助</strong>：符号表管理、出错处理</li></ul></li><li>8项功能对应8个模块</li></ul><h2 id="词法分析">词法分析</h2><h3 id="定义">定义</h3><ul><li><p>词法分析由<strong>词法分析器</strong>(Lexical Analyzer)完成，词法分析器又称为<strong>扫描器</strong>(Scanner)</p></li><li><p>词法分析器从左到右扫描组成源程序的<strong>字符串</strong>，并将其转换成单词串；<strong>同时要</strong>：<strong>查词法错误</strong>，<strong>进行标识符登记</strong>（符号表管理）。</p></li><li><p><strong>输入</strong>：<strong>字符串</strong></p></li><li><p><strong>输出</strong>：<strong>(种别码，属性值)——序对</strong></p><ul><li><strong>属性值</strong>——token的机内表示</li></ul></li></ul><h3 id="例子：">例子：</h3><p><strong>输入</strong>：sum=(10+20) * (num+square);<br><strong>输出</strong>: (标识符，sum)    (赋值号，=)    (左括号，()<br>(整常数，10)     (加号，+ )    (整常数，20)<br>(右括号，))      (乘号，* )    (左括号，()<br>(标识符，num)    (加号，+ )    (标识符，square)<br>(右括号，))      (分号，;)</p><h2 id="语法分析">语法分析</h2><ul><li><p>语法分析由<strong>语法分析器</strong>(Syntax Analyzer)完成，语法分析器又叫Parser。</p></li><li><p><strong>功能</strong>：</p><ul><li>Parser实现“<strong>组词成句</strong>”： 将词组成各类语法成分，例如因子、项、表达式、语句、子程序…</li><li>构造分析树</li><li>指出语法错误</li><li>指导翻译</li></ul></li><li><p><strong>输入</strong>：<strong>token序列</strong></p></li><li><p><strong>输出</strong>：<strong>语法成分</strong></p></li></ul><img src="..\..\img\CompilerPrinciples\语法分析.png" width="100%" height="100%" align="middle"><h2 id="语义分析">语义分析</h2><ul><li>语义分析(semantic analysis)一般<strong>和语法分析同时进行</strong>，称为<strong>语法制导翻译</strong></li><li><strong>功能</strong>：分析由<strong>语法分析器</strong>识别出来的 语法成分的<strong>语义</strong><ul><li>获取标识符的<strong>属性</strong>：类型、作用域等</li><li><strong>语义检查</strong>：运算的合法性、取值范围等</li><li><strong>子程序的静态绑定</strong>：代码的相对地址</li><li><strong>变量的静态绑定</strong>：数据的相对地址<br><img src="..\..\img\CompilerPrinciples\语义分析.png" width="100%" height="100%" align="middle"></li></ul></li></ul><h2 id="中间代码生成">中间代码生成</h2><ul><li>语义分析通常以中间代码形式表达操作</li><li>中间代码的<strong>特点</strong><ul><li>简单规范</li><li><strong>与机器无关</strong></li><li>易于优化与转换<br><img src="..\..\img\CompilerPrinciples\中间代码生成.png" width="100%" height="100%" align="middle"></li></ul></li></ul><h2 id="代码优化-optimization">代码优化(optimization)</h2><ul><li>对中间代码进行优化处理，使程序运行能够 尽量<strong>节省存储空间</strong>，更<strong>有效地利用机器资源</strong>，使得程序的<strong>运行速度更快</strong>，<strong>效率更高</strong></li><li>这种优化<strong>变换必须是等价的</strong>。</li><li>分为（<strong>与机器无关的优化</strong>）和（<strong>与机器有关的优化</strong>）两种</li></ul><h3 id="与机器无关的优化">与机器无关的优化</h3><p>可以理解为 <strong>算法</strong></p><h4 id="局部优化">局部优化</h4><ul><li><strong>常量合并</strong>：常数运算在编译期间完成，如 8+9*4</li><li><strong>公共子表达式的提取</strong></li></ul><h4 id="全局优化">全局优化</h4><ul><li>主要是指<strong>循环优化</strong></li><li><strong>强度削减</strong>：用较快的操作代替较慢的操作</li><li><strong>代码外提</strong>：将循环中不变的计算移出循环</li></ul><h3 id="与机器有关的优化">与机器有关的优化</h3><p>可以理解为 <strong>组成原理</strong> 和 <strong>体系结构</strong></p><ul><li><strong>寄存器的利用</strong><ul><li>将常用量放入寄存器，以减少访问内存的次数</li></ul></li><li><strong>体系结构</strong><ul><li>SIMD 、MIMD、SPMD、向量机、流水机</li></ul></li><li><strong>任务划分</strong><ul><li>按运行的算法及体系结构，划分子任务(MPMD)</li></ul></li><li><strong>存储策略</strong><ul><li>根据算法访存的要求安排：Cache、并行存储体系——减少访问冲突</li></ul></li></ul><h4 id="存储层次">存储层次</h4><ul><li>CPU寄存器<ul><li>保存着最常用的数据，0 个周期访问数据</li></ul></li><li>高速缓冲存储器<ul><li>靠近CPU的小的、快速的存储器，1-30个周期访问数据</li></ul></li><li>主存储器<ul><li>存储系统和进程运行所需的数据和指令，50-200个周期访问数据</li></ul></li><li>磁盘<ul><li>最主要存储设备，10,000,000个周期访问数据</li></ul></li></ul><h2 id="目标代码生成">目标代码生成</h2><ul><li>编译程序的<strong>最后一个阶段</strong></li><li>为中间代码中出现的运算对象<strong>分配存储单元、寄存器</strong>等</li><li>将<strong>中间代码转换成目标机上的机器指令代码或汇编代码</strong><ul><li>对于确定源语言的各种语法成分，确定目标代码结构（机器指令组/汇编语句组）</li><li>制定从中间代码到目标代码的翻译策略或算法</li></ul></li></ul><h2 id="错误处理">错误处理</h2><ul><li>进行各种错误的<strong>检查、报告、纠正</strong>，以及相应的续编译处理(如：错误的定位与局部化)<ul><li><strong>词法分析阶段</strong>：拼写方面的错误，出现非法字符等</li><li><strong>语法分析阶段</strong>：表达式、句子或程序结构等错误</li><li><strong>语义分析阶段</strong>：类型匹配错误、参数匹配错误、非法转移问题等</li></ul></li></ul><h2 id="表格管理">表格管理</h2><ul><li><strong>管理各种符号表</strong>(常数、标号、变量、过程、结构……)，查、填源程序中出现的符号和编译程序生成的符号，<strong>为编译的各个阶段提供信息</strong>。</li><li>Hash表、链表等各种表的查、填技术</li><li>“数据结构与算法” 课程的应用</li></ul><h1>编译程序的组织</h1><ul><li>根据系统资源的状况、运行目标的要求等，可以将一个编译程序设计成多**遍（Pass）**扫描的形式，在每一遍扫描中，完成不同任务。<ul><li>如：首遍构造语法树，二遍处理中间表示，增加信息等</li></ul></li><li><strong>遍可以和阶段相对应，也可以和阶段无关</strong></li><li>遍<strong>数量</strong>的优化<ul><li>根据语言、系统追求的目标、计算机的资源状况等决定</li></ul></li></ul><h2 id="多遍扫描">多遍扫描</h2><ul><li>本遍扫描的结果作为下一遍扫描的输入，本遍扫描中得到的信息在下一遍扫描中也有效，容易获得更优化的程序<ul><li>可以将词法分析、语法分析、语义分析和中间代码生成做成一遍；</li><li>将代码优化做成一遍；</li><li>将目标代码生成做成一遍</li></ul></li><li>增加内存访问次数，可能增加外部存储的访问次数</li></ul><h2 id="单遍扫描">单遍扫描</h2><ul><li>分析所需的信息可能目前尚未掌握，导致产生的目标程序难以达到最优</li></ul><h2 id="编译程序的设计目标">编译程序的设计目标</h2><ul><li>规模小、速度快、诊断能力强、可靠性高、<strong>可移植性好</strong>、可扩充性好</li><li>目标程序也要规模小、执行速度快</li><li>为了提高可移植性，将<strong>编译程序划分为前端和后端</strong></li></ul><h2 id="前端">前端</h2><ul><li>与源语言有关、与目标机无关的部分</li><li>词法分析、语法分析、语义分析与中间代码生成、与机器无关的代码优化</li><li>对于<strong>某一种高级语言在不同机器上的编译系统</strong>，前端的处理基本是一样的，<strong>前端部分可被复用</strong>，只需要针对不同的机器构建后端就可以</li></ul><h2 id="后端">后端</h2><ul><li>与目标机有关的部分</li><li>与机器有关的代码优化、目标代码生成</li><li>在<strong>某一种机器上实现多种高级语言的编译系统</strong>，<strong>后端部分可以被复用</strong>，只需要针对不同高级语言构建前端就可以</li></ul><h1>编译程序的生成</h1><ul><li>编译程序也是运行在计算机上的<strong>程序</strong></li></ul><h2 id="T形图">T形图</h2><p>表示语言翻译的T形图<br><img src="..\..\img\CompilerPrinciples\T形图.png" width="100%" height="100%" align="middle"></p><p>一个用A语言描述的编译程序，它将S语言源程序翻译成了T语言目标程序</p><h2 id="自展">自展</h2><ul><li><strong>问题一：如何直接在一个机器上实现C语言编译器？</strong></li><li>解决：<ol><li>用汇编语言实现一个C子集的编译程序<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">P_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></li><li>用汇编程序处理该程序<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">P_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>,得到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">P_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>（可直接运行）</li><li>用C子集编制C语言的编译程序<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mn>3</mn></msub></mrow><annotation encoding="application/x-tex">P_3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></li><li>用<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">P_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>编译<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mn>3</mn></msub></mrow><annotation encoding="application/x-tex">P_3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，得到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mn>4</mn></msub></mrow><annotation encoding="application/x-tex">P_4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></li></ol></li></ul><h2 id="移植">移植</h2><ul><li><strong>问题二</strong>：A机上有一个C语言编译器，是否可利用此编译器实现B机上的C语言编译器？<ul><li>条件：A机有C 语言的编译程序</li><li>目的：实现B机的C语言的编译</li></ul></li><li>解决：<ol><li>用Ｃ语言编制B机的Ｃ编译程序<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">P_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></li><li>(Ａ机C编译器<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">P_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>)编译<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">P_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，得到在A机上可运行的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">P_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></li><li>(Ａ机的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">P_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>)编译<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">P_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，得到B机上可运行的编译器<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mn>3</mn></msub></mrow><annotation encoding="application/x-tex">P_3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></li></ol></li></ul><h2 id="本机编译器的利用">本机编译器的利用</h2><ul><li><strong>问题三</strong>： A机上有一个C语言编译器，现要实现一个新语言NEW的编译器？</li><li>解决：<ul><li>用C编写NEW的编译器，并用C编译器编译它</li></ul></li></ul><h2 id="编译程序的自动生成">编译程序的自动生成</h2><h3 id="词法分析器的自动生成程序">词法分析器的自动生成程序</h3><img src="..\..\img\CompilerPrinciples\词法分析器的自动生成程序.png" width="100%" height="100%" align="middle"><h3 id="语法分析器的自动生成程序">语法分析器的自动生成程序</h3><img src="..\..\img\CompilerPrinciples\语法分析器的自动生成程序.png" width="100%" height="100%" align="middle">]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;程序设计语言&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;机器语言&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;每一个具体的计算机系统都具有自己的指令系统&lt;/li&gt;
&lt;li&gt;以&lt;strong&gt;0,1代码&lt;/strong&gt;表示的机器指令所构成的语言&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>计算机网络-概述</title>
    <link href="https://escapeey.github.io/post/be54bfd5.html"/>
    <id>https://escapeey.github.io/post/be54bfd5.html</id>
    <published>2024-04-11T08:17:51.000Z</published>
    <updated>2024-05-22T06:03:05.837Z</updated>
    
    <content type="html"><![CDATA[<h2 id="因特网">因特网</h2><ul><li><p>基于ISP的三层结构的因特网<br><img src="../../img/Network/基于ISP的三层结构的因特网.png" width="100%" height="100%"></p></li><li><p>因特网的组成<br><img src="../../img/Network/因特网的组成.png" width="100%" height="100%"></p></li></ul><h2 id="三种交换方式">三种交换方式</h2><h3 id="电路交换">电路交换</h3><ul><li>电话交换机 接通电话线的方式称为 电路交换</li><li>三个步骤：<ul><li>建立连接 （分配通信资源）</li><li>通话 （<strong>一直占用</strong>通信资源）</li><li>释放连接 （归还通信资源）</li></ul></li><li>传输计算机数据时效率很低 （因为计算机数据传输是 <strong>突发式</strong>的）</li></ul><h3 id="分组交换">分组交换</h3><ul><li>通过路由器 传送 分组</li><li>三方：<ul><li>发送方： 构造分组、发送分组</li><li>路由器： 缓存分组、转发分组 （<strong>存储转发</strong>）</li><li>接收方： 接收分组、还原报文</li></ul></li></ul><h3 id="报文交换">报文交换</h3><ul><li>没有限制报文大小的交换， 需要各个节点交换机有较大的缓存空间<br><img src="../../img/Network/三种交换方式.png" width="100%" height="100%"></li></ul><h3 id="优缺点">优缺点</h3><h4 id="电路交换-2">电路交换</h4><ul><li>优点：<ul><li>通信时延小</li><li>有序传输</li><li>没有冲突</li><li>适用范围广</li><li>实时性强</li><li>控制简单</li></ul></li><li>缺点：<ul><li>建立连接时间长</li><li>线路独占、使用效率低</li><li>灵活性差</li><li>难以规格化</li></ul></li></ul><h4 id="报文交换-2">报文交换</h4><ul><li>优点：<ul><li>无需建立连接</li><li>动态分配线路</li><li>提高线路可靠性</li><li>提高线路利用率</li><li>提供多目标服务</li></ul></li><li>缺点：<ul><li>引起了转发时延</li><li>需要较大存储缓存空间</li><li>需要传输额外的信息量</li></ul></li></ul><h4 id="分组交换-2">分组交换</h4><ul><li>优点：<ul><li>无需建立连接</li><li>提高线路利用率</li><li><strong>简化了存储管理</strong> （分组大小固定）</li><li><strong>加速传输</strong>（在转发分组时可以同时存储下一个分组）</li><li><strong>减少出错概率和重发数据量</strong>（分组小，从而出错概率小，重发量小）</li></ul></li><li>缺点：<ul><li>引起了转发时延</li><li>需要传输额外的信息量</li><li><strong>对于数据报服务，存在失序、丢失或重复分组的问题</strong></li><li>对于虚电路服务，存在呼叫建立、数据传输和虚电路释放三个过程</li></ul></li></ul><h2 id="计算机网络的分类">计算机网络的分类</h2><img src="../../img/Network/计算机网络分类.png" width="100%" height="100%"><h2 id="计算机网络的性能指标">计算机网络的性能指标</h2><h3 id="速率">速率</h3><ul><li>传送比特的速率，也称 <strong>比特率</strong></li><li>单位：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi><mi>i</mi><mi>t</mi><mi mathvariant="normal">/</mi><mi>s</mi><mo stretchy="false">(</mo><mi>b</mi><mi>p</mi><mi>s</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">bit/s   (bps)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">bi</span><span class="mord mathnormal">t</span><span class="mord">/</span><span class="mord mathnormal">s</span><span class="mopen">(</span><span class="mord mathnormal">b</span><span class="mord mathnormal">p</span><span class="mord mathnormal">s</span><span class="mclose">)</span></span></span></span><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mi>b</mi><mi mathvariant="normal">/</mi><mi>s</mi><mo>=</mo><mn>1</mn><msup><mn>0</mn><mn>3</mn></msup><mi>b</mi><mi>i</mi><mi>t</mi><mi mathvariant="normal">/</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">kb/s = 10^3 bit/s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">kb</span><span class="mord">/</span><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mord mathnormal">bi</span><span class="mord mathnormal">t</span><span class="mord">/</span><span class="mord mathnormal">s</span></span></span></span></li></ul></li><li>速率单位中 是以 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>3</mn></msup></mrow><annotation encoding="application/x-tex">10^3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span></span></span></span> 进制的</li><li>数据量单位中 是以 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>1</mn></msup><mn>0</mn></mrow><annotation encoding="application/x-tex">2^10</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span></span></span></span></span><span class="mord">0</span></span></span></span> 进制的<br><img src="../../img/Network/速率计算例题.png" width="100%" height="100%"></li></ul><h3 id="带宽">带宽</h3><h4 id="在模拟信号系统的意义">在模拟信号系统的意义</h4><ul><li><strong>信号</strong>所包含的各种不同频率成分所占据的 <strong>频率范围</strong></li><li>单位：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>H</mi><mi>z</mi><mo stretchy="false">(</mo><mi>k</mi><mi>H</mi><mi>z</mi><mo separator="true">,</mo><mi>M</mi><mi>H</mi><mi>z</mi><mo separator="true">,</mo><mi>G</mi><mi>H</mi><mi>z</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Hz (kHz, MHz, GHz)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.04398em;">Hz</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mord mathnormal" style="margin-right:0.04398em;">Hz</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mord mathnormal" style="margin-right:0.04398em;">Hz</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">G</span><span class="mord mathnormal" style="margin-right:0.04398em;">Hz</span><span class="mclose">)</span></span></span></span></li></ul><h4 id="计网中的意义">计网中的意义</h4><ul><li>表示网络的<strong>通信线路</strong>所能传送数据的能力，因此网络带宽表示 <strong>在单位时间内</strong>从网络中的某一点到另一点所能通过的“<strong>最高数据率</strong>”</li><li>单位：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi><mi>i</mi><mi>t</mi><mi mathvariant="normal">/</mi><mi>s</mi><mo stretchy="false">(</mo><mi>b</mi><mi>p</mi><mi>s</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">bit/s (bps)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">bi</span><span class="mord mathnormal">t</span><span class="mord">/</span><span class="mord mathnormal">s</span><span class="mopen">(</span><span class="mord mathnormal">b</span><span class="mord mathnormal">p</span><span class="mord mathnormal">s</span><span class="mclose">)</span></span></span></span> <strong>与速率单位相同</strong></li></ul><h3 id="吞吐量">吞吐量</h3><ul><li>单位时间内通过某个网络的数据量</li><li>受网络的带宽或额定速率的限制</li></ul><h3 id="时延">时延</h3><ul><li>由 发送时延、传播时延、处理时延构成</li><li>发送时延 = 分组长度(b) / 发送速率(b/s)</li><li>传播时延 = 信道长度(m) / 电磁波传播速率(m/s)</li><li>处理时延 不方便计算</li></ul><h3 id="时延带宽积">时延带宽积</h3><ul><li>时延带宽积 = 传播时延 * 带宽<br><img src="../../img/Network/时延带宽积.png" width="100%" height="100%"></li></ul><h3 id="往返时间-RTT">往返时间 RTT</h3><p>Round-Trip Time 双向交互一次的时间 <strong>RTT</strong></p><h3 id="利用率">利用率</h3><ul><li><p>信道利用率： 用来表示某信道有百分之几的时间是被利用的(有数据通过)</p></li><li><p>网络利用率： 全网络的信道利用率的加权平均</p></li><li><p>当某信道的利用率增大时，该信道引起的时延也会迅速增加</p></li><li><p>如令 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>D</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">D_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 表示网络空闲时的时延，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi></mrow><annotation encoding="application/x-tex">D</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span></span></span></span> 表示网络当前时延，可以用下面简化的公式表示时延与利用率 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>U</mi></mrow><annotation encoding="application/x-tex">U</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span></span></span></span>的关系：</p></li></ul><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>D</mi><mo>=</mo><mfrac><msub><mi>D</mi><mn>0</mn></msub><mrow><mn>1</mn><mo>−</mo><mi>U</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">D = \dfrac{D_0}{1-U}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.1297em;vertical-align:-0.7693em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3603em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.7693em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><ul><li>因此一些有较大主干网的ISP通常会控制它们的 信道利用率不超过 50%。</li></ul><h3 id="丢包率">丢包率</h3><ul><li>即分组丢失率，在一定时间内，传输过程中<strong>丢失的分组数</strong>与<strong>总分组数</strong>的比率</li><li>分组丢失主要两种情况：<ul><li>分组在传输过程中出现<strong>误码</strong>, 被结点丢弃；</li><li>分组到达一台队列已满的交换机时被丢弃，在通信量较大时造成<strong>网络拥塞</strong></li></ul></li><li>丢包率反应了网络的拥塞情况<ul><li>无拥塞时 丢包率为0</li><li>轻度拥塞时 为 1% - 4%</li><li>严重拥塞时 为 5% - 15%</li></ul></li></ul><h2 id="计算机网络体系结构">计算机网络体系结构</h2><h3 id="体系结构层次">体系结构层次</h3><img src="../../img/Network/体系结构层次.png" width="100%" height="100%"><h3 id="术语">术语</h3><ul><li><p><strong>实体</strong>： 任何可发送或接受信息的<strong>硬件</strong>或<strong>软件进程</strong></p></li><li><p><strong>对等实体</strong>： 收发双方<strong>相同层次中的实体</strong></p></li><li><p><strong>协议</strong>：控制两个对等实体进行逻辑通信的规则的集合</p></li><li><p>协议的<strong>三要素</strong>： 语法  语义  同步</p><ul><li><strong>语法</strong> 定义所交换信息的格式</li><li><strong>语义</strong> 定义收发双方所要完成的操作</li><li><strong>同步</strong> 定义收发双方的时序关系</li></ul></li><li><p>在协议的控制下，两个对等实体间的逻辑通信使得本层能向上一层提供<strong>服务</strong></p></li><li><p>协议时 <strong>“水平的”</strong>， 服务是 <strong>“垂直的”</strong></p></li><li><p><strong>服务访问点</strong>： 在同一系统中 <strong>相邻两层的实体交换信息的逻辑接口</strong></p><ul><li>数据链路层 的 服务访问点为 帧的“类型”字段</li><li>网络层 的 服务访问点为 IP数据报首部中的“协议字段”</li><li>运输层 的 服务访问点为 “端口号”</li></ul></li><li><p><strong>服务原语</strong>： 上层使用下层所提供的服务必须通过与下层<strong>交换一些命令</strong>，这些命令称为服务原语</p></li><li><p><strong>协议数据单元PDU</strong>: <strong>对等层次之间传送的数据包</strong> 称为该层的协议数据单元</p></li><li><p><strong>服务数据单元SDU</strong>: <strong>同一系统内，层与层之间交换的数据包</strong> 称为服务数据单元</p></li></ul><img src="../../img/Network/术语.png" width="100%" height="100%">]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;因特网&quot;&gt;因特网&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;基于ISP的三层结构的因特网&lt;br&gt;
&lt;img src=&quot;../../img/Network/基于ISP的三层结构的因特网.png&quot; width=&quot;100%&quot; height=&quot;100%&quot;&gt;&lt;/p&gt;
&lt;/li&gt;
</summary>
      
    
    
    
    <category term="Computer-Network" scheme="https://escapeey.github.io/categories/Computer-Network/"/>
    
    
    <category term="Computer-Network" scheme="https://escapeey.github.io/tags/Computer-Network/"/>
    
  </entry>
  
  <entry>
    <title>DFS和BFS</title>
    <link href="https://escapeey.github.io/post/f5273844.html"/>
    <id>https://escapeey.github.io/post/f5273844.html</id>
    <published>2024-04-03T11:31:37.000Z</published>
    <updated>2024-05-22T06:03:05.833Z</updated>
    
    <content type="html"><![CDATA[<h1>DFS</h1><p>回溯算法，其实就是dfs的过程，这里给出dfs的代码框架：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(参数)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (终止条件) &#123;</span><br><span class="line">        存放结果;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (选择：本节点所连接的其他节点) &#123;</span><br><span class="line">        处理节点;</span><br><span class="line">        <span class="built_in">dfs</span>(图，选择的节点); <span class="comment">// 递归</span></span><br><span class="line">        回溯，撤销处理结果</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>深搜代码模板，该模板针对的是四方格的地图：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> dir[<span class="number">4</span>][<span class="number">2</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;; <span class="comment">// 四个方向</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; grid, vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt;&amp; visited, <span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        <span class="type">int</span> nextx = x + dir[i][<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> nexty = y + dir[i][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (nextx &lt; <span class="number">0</span> || nextx &gt;= grid.<span class="built_in">size</span>() || nexty &lt; <span class="number">0</span> || nexty &gt;= grid[<span class="number">0</span>].<span class="built_in">size</span>()) <span class="keyword">continue</span>;  <span class="comment">// 越界了，直接跳过</span></span><br><span class="line">        <span class="keyword">if</span> (!visited[nextx][nexty]) &#123; <span class="comment">// 没有访问过的</span></span><br><span class="line">            visited[nextx][nexty] = <span class="literal">true</span>; </span><br><span class="line">            <span class="built_in">dfs</span>(grid, visited, nextx, nexty);</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>BFS</h1><p>广搜代码模板，该模板针对的是四方格的地图：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> dir[<span class="number">4</span>][<span class="number">2</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;; <span class="comment">// 表示四个方向</span></span><br><span class="line"><span class="comment">// grid 是地图，也就是一个二维数组</span></span><br><span class="line"><span class="comment">// visited标记访问过的节点，不要重复访问</span></span><br><span class="line"><span class="comment">// x,y 表示开始搜索节点的下标</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; grid, vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt;&amp; visited, <span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; que; <span class="comment">// 定义队列</span></span><br><span class="line">    que.<span class="built_in">push</span>(&#123;x, y&#125;); <span class="comment">// 起始节点加入队列</span></span><br><span class="line">    visited[x][y] = <span class="literal">true</span>; <span class="comment">// 只要加入队列，立刻标记为访问过的节点</span></span><br><span class="line">    <span class="keyword">while</span>(!que.<span class="built_in">empty</span>()) &#123; <span class="comment">// 开始遍历队列里的元素</span></span><br><span class="line">        pair&lt;<span class="type">int</span> ,<span class="type">int</span>&gt; cur = que.<span class="built_in">front</span>(); </span><br><span class="line">        que.<span class="built_in">pop</span>(); <span class="comment">// 从队列取元素</span></span><br><span class="line">        <span class="type">int</span> curx = cur.first;</span><br><span class="line">        <span class="type">int</span> cury = cur.second; <span class="comment">// 当前节点坐标</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123; <span class="comment">// 开始想当前节点的四个方向左右上下去遍历</span></span><br><span class="line">            <span class="type">int</span> nextx = curx + dir[i][<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> nexty = cury + dir[i][<span class="number">1</span>]; <span class="comment">// 获取周边四个方向的坐标</span></span><br><span class="line">            <span class="keyword">if</span> (nextx &lt; <span class="number">0</span> || nextx &gt;= grid.<span class="built_in">size</span>() || nexty &lt; <span class="number">0</span> || nexty &gt;= grid[<span class="number">0</span>].<span class="built_in">size</span>())</span><br><span class="line">                <span class="keyword">continue</span>;<span class="comment">// 坐标越界了，直接跳过</span></span><br><span class="line">            <span class="keyword">if</span> (!visited[nextx][nexty]) &#123; <span class="comment">// 如果节点没被访问过</span></span><br><span class="line">                que.<span class="built_in">push</span>(&#123;nextx, nexty&#125;);  <span class="comment">// 队列添加该节点为下一轮要遍历的节点</span></span><br><span class="line">                visited[nextx][nexty] = <span class="literal">true</span>; <span class="comment">// 只要加入队列立刻标记，避免重复访问</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;DFS&lt;/h1&gt;
&lt;p&gt;回溯算法，其实就是dfs的过程，这里给出dfs的代码框架：&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/spa</summary>
      
    
    
    
    <category term="Algorithm" scheme="https://escapeey.github.io/categories/Algorithm/"/>
    
    
    <category term="Algorithm" scheme="https://escapeey.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>C++-仿函数与函数指针</title>
    <link href="https://escapeey.github.io/post/7b13e28b.html"/>
    <id>https://escapeey.github.io/post/7b13e28b.html</id>
    <published>2024-04-02T22:02:04.000Z</published>
    <updated>2024-05-22T06:03:05.833Z</updated>
    
    <content type="html"><![CDATA[<h1>函数指针</h1><h2 id="指向函数存储内存地址的指针">指向函数存储内存地址的指针</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个 无参返回值为int 的函数指针</span></span><br><span class="line"><span class="built_in">int</span> (*funcPtr)();</span><br></pre></td></tr></table></figure><h2 id="把函数赋值给函数指针">把函数赋值给函数指针</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">func1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">int</span> (*funcPtr)() = func1; </span><br><span class="line">    <span class="comment">// C++会隐式得把func1 转换成 &amp;func1, 无需加入&amp;</span></span><br><span class="line">    funcPtr = func2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="通过函数指针调用函数">通过函数指针调用函数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">func3</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">int</span> (*funcPtr1)(<span class="type">int</span>) = func3;</span><br><span class="line">(*funcPtr1)(<span class="number">5</span>);</span><br><span class="line"><span class="built_in">funcPtr1</span>(<span class="number">5</span>);   <span class="comment">//也可以这么使用，在一些古老的编译器上可能不行</span></span><br></pre></td></tr></table></figure><h2 id="把函数作为参数传入另一个函数">把函数作为参数传入另一个函数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sub</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a-b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> e, <span class="type">int</span> d, <span class="type">int</span>(*func)(<span class="type">int</span> a, <span class="type">int</span> b))</span></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">func</span>(e,d)&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">func</span>(<span class="number">2</span>,<span class="number">3</span>,add);</span><br><span class="line">    <span class="built_in">func</span>(<span class="number">2</span>,<span class="number">3</span>,sub);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>仿函数</h1><h2 id="仿函数由来">仿函数由来</h2><ul><li>是代替 <strong>函数指针</strong> 的手段</li><li>定义一个类，类里面重载函数运算符()，将该类的对象作为函数的入参，那么在函数中同样能调用重载符()里面的方法</li><li>所以说，仿函数就是仿造的函数，它并不是一个真正意义上的函数。它是一个类中的运算符()重载，但它具有函数的功能。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Compare</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_Number;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Compare</span>(<span class="type">int</span> num) : <span class="built_in">m_Number</span>(num)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> other)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_Number &gt; other;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//定义对象调用</span></span><br><span class="line">    <span class="function">Compare <span class="title">cmp</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    cout&lt;&lt; <span class="built_in">cmp</span>(<span class="number">11</span>);</span><br><span class="line">    <span class="comment">//通过临时对象调用</span></span><br><span class="line">    cout&lt;&lt; <span class="built_in">Compare</span>(<span class="number">10</span>)();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="作用">作用</h2><ul><li>在STL库中十分常见</li></ul><h3 id="sort-与-priority-queue-中的用法">sort() 与 priority_queue 中的用法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> pair&lt;string, <span class="type">int</span>&gt; PAIR;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmpfunc</span><span class="params">(<span class="type">const</span> PAIR&amp; lhs, <span class="type">const</span> PAIR&amp; rhs)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> lhs.second &lt; rhs.second;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Compare</span> &#123;  </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> PAIR&amp; lhs, <span class="type">const</span> PAIR&amp; rhs)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> lhs.second &lt; rhs.second;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 仿函数 并且是临时对象</span></span><br><span class="line">    <span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), <span class="built_in">Compare</span>());  </span><br><span class="line">    <span class="comment">// 直接传入函数指针 隐式将cmpfunc 转为 &amp;cmpfunc</span></span><br><span class="line">    <span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), cmpfunc);</span><br><span class="line">    <span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), <span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">    <span class="comment">// 对priority_queue 只能传 结构体或类的 名称，不是对象！！！</span></span><br><span class="line">    <span class="comment">// 因为是定义 而不是像sort一样直接使用 仿函数 greater&lt;int&gt;()</span></span><br><span class="line">    priority_queue&lt;PAIR, vector&lt;PAIR&gt;, Compare &gt; que;</span><br><span class="line">    priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt; &gt; que;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="greater-int-源码">greater<int> 源码</h3><p>是一个仿函数<br><img src="../../img/C++/greater源码.png" width="100%" height="100%"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;函数指针&lt;/h1&gt;
&lt;h2 id=&quot;指向函数存储内存地址的指针&quot;&gt;指向函数存储内存地址的指针&lt;/h2&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;</summary>
      
    
    
    
    <category term="C++" scheme="https://escapeey.github.io/categories/C/"/>
    
    
    <category term="C++" scheme="https://escapeey.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>排序算法</title>
    <link href="https://escapeey.github.io/post/735e5788.html"/>
    <id>https://escapeey.github.io/post/735e5788.html</id>
    <published>2024-04-01T16:36:10.000Z</published>
    <updated>2024-05-22T06:03:05.833Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/alzzw/article/details/98100378">参考博客</a></p><img src="../../img/Algorithm/排序算法分类.png" width="100%" height="100%"><h1>复杂度</h1><img src="../../img/Algorithm/排序算法复杂度对比.png" width="100%" height="100%"><ul><li>稳定性：<ul><li>指待排序的序列中有两元素相等,排序之后它们的先后顺序不变.</li><li>也可以理解为一切皆在掌握中,元素的位置处在你在控制中.而不稳定算法有时就有点碰运气,随机的成分.</li></ul></li></ul><h1>BubbleSort</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">BubbleSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; vec, <span class="type">int</span> l, <span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &lt; r)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;r; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(vec[i] &gt; vec[i+<span class="number">1</span>])</span><br><span class="line">                <span class="built_in">swap</span>(vec[i], vec[i+<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">BubbleSort</span>(vec, l, r<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>SelectionSort</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SelectionSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; vec, <span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(n &gt; <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="type">int</span> max = vec[<span class="number">0</span>], pos = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(max &lt; vec[i])&#123;</span><br><span class="line">                max = vec[i];</span><br><span class="line">                pos = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">swap</span>(vec[pos], vec[n<span class="number">-1</span>];)</span><br><span class="line">        n--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>InsertionSort</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">InsertionSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; vec, <span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;n; i++)&#123;</span><br><span class="line">        <span class="type">int</span> key = vec[i], j = i;</span><br><span class="line">        <span class="keyword">while</span>(vec[j<span class="number">-1</span>] &gt; key)&#123;</span><br><span class="line">            vec[j] = vec[j<span class="number">-1</span>];</span><br><span class="line">            j--;</span><br><span class="line">            <span class="keyword">if</span>(j==<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        vec[j] = key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>ShellSort</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ShellSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> gap = n / <span class="number">2</span>; gap &gt;= <span class="number">1</span> ; gap /= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = gap; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="type">int</span> j, key = nums[i];</span><br><span class="line">            <span class="keyword">for</span> (j = i - gap; j &gt;= <span class="number">0</span> &amp;&amp; key &lt; nums[j]; j -= gap) &#123;</span><br><span class="line">                <span class="comment">// 依次后移</span></span><br><span class="line">                nums[j + gap] = nums[j];</span><br><span class="line">            &#125;</span><br><span class="line">            nums[j + gap] = key;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>MergeSort</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Merge</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; vec, <span class="type">int</span> l, <span class="type">int</span> mid, <span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">helper</span><span class="params">(vec)</span></span>;</span><br><span class="line">    <span class="type">int</span> lp = l, rp = mid+<span class="number">1</span>, cp = l;</span><br><span class="line">    <span class="keyword">while</span>(lp&lt;=mid &amp;&amp; rp&lt;=r)&#123;</span><br><span class="line">        <span class="keyword">if</span>(helper[lp] &gt;= helper[rp])&#123;</span><br><span class="line">            vec[cp++] = helper[rp++];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            vec[cp++] = helper[lp++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(lp &lt;= mid)&#123;</span><br><span class="line">        vec[cp++] = helper[lp++];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MergeSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; vec, <span class="type">int</span> l, <span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &lt; r)&#123;</span><br><span class="line">        <span class="type">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">MergeSort</span>(vec, l, mid);</span><br><span class="line">        <span class="built_in">MergeSort</span>(vec, mid+<span class="number">1</span>, r);</span><br><span class="line">        <span class="built_in">Merge</span>(vec, l, mid, r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>QuickSort</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">QuickSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp;nums, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;    </span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) </span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> x = <span class="built_in">rand</span>() % (r - l + <span class="number">1</span>) + l;</span><br><span class="line">    <span class="built_in">swap</span>(nums[l], nums[x]);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> pivot = nums[l], lp = l, rp = r;</span><br><span class="line">    <span class="keyword">while</span> (lp &lt; rp) &#123;</span><br><span class="line">        <span class="keyword">while</span> (nums[rp] &gt;= pivot &amp;&amp; lp &lt; rp) </span><br><span class="line">            rp--;</span><br><span class="line">        <span class="keyword">if</span> (lp &lt; rp)</span><br><span class="line">            nums[lp] = nums[rp];</span><br><span class="line">        <span class="keyword">while</span> (nums[lp] &lt;= pivot &amp;&amp; lp &lt; rp) </span><br><span class="line">            lp++;</span><br><span class="line">        <span class="keyword">if</span> (lp &lt; rp)</span><br><span class="line">            nums[rp] = nums[lp];</span><br><span class="line">    &#125;</span><br><span class="line">    nums[lp] = pivot;</span><br><span class="line">    <span class="built_in">QuickSort</span>(nums, l, lp - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">QuickSort</span>(nums, lp + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>HeapSort</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">heapify</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; vec, <span class="type">int</span> i, <span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> lp = <span class="number">2</span>*i+<span class="number">1</span>, rp = <span class="number">2</span>*i+<span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> largestId = i;</span><br><span class="line">    <span class="keyword">if</span>(lp &lt; n &amp;&amp; vec[largestId] &lt; vec[lp]) </span><br><span class="line">        largestId = lp;</span><br><span class="line">    <span class="keyword">if</span>(rp &lt; n &amp;&amp; vec[largestId] &lt; vec[rp])</span><br><span class="line">        largestId = rp;</span><br><span class="line">    <span class="keyword">if</span>(largestId != i)&#123;</span><br><span class="line">        <span class="built_in">swap</span>(vec[largestId], vec[i]);</span><br><span class="line">        <span class="built_in">heapify</span>(vec, largestId, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HeapSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; vec)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n = vec.<span class="built_in">size</span>();</span><br><span class="line">    <span class="comment">// 建堆</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n/<span class="number">2</span><span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">        <span class="built_in">heapify</span>(vec, i, n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//排序</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n<span class="number">-1</span>; i&gt;<span class="number">0</span>; i--)&#123;</span><br><span class="line">        <span class="built_in">swap</span>(vec[i], vec[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">heapify</span>(vec, <span class="number">0</span>, i); </span><br><span class="line">        <span class="comment">// 这里的i是堆去掉排序好的元素后的长度</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>BucketSort</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置10个桶</span></span><br><span class="line"><span class="type">int</span> N = <span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BucketSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;vec)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n = vec.<span class="built_in">size</span>();</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">bucket</span>(N);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    bucket[vec[i] / <span class="number">10</span>].<span class="built_in">push_back</span>(vec[i]);</span><br><span class="line">    <span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++)&#123;</span><br><span class="line">    <span class="comment">//对每个桶进行排序</span></span><br><span class="line">    <span class="built_in">sort</span>(bucket[i].<span class="built_in">begin</span>(), bucket[i].<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;bucket[i].<span class="built_in">size</span>(); j++)</span><br><span class="line">        vec[k++] = bucket[i][j];<span class="comment">//放入原数组</span></span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;().<span class="built_in">swap</span>(bucket); <span class="comment">//释放空间</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>RadixSort</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_max</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; vec, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> max = vec[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">        <span class="keyword">if</span> (vec[i] &gt; max)</span><br><span class="line">            max = vec[i];</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对数组按照&quot;某个位数&quot;进行排序(桶排序)</span></span><br><span class="line"><span class="comment">// exp -- 指数 0, 10, 100, ...</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">count_sort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; vec, <span class="type">int</span> n, <span class="type">int</span> exp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">output</span><span class="params">(n)</span></span>;             <span class="comment">// 存储&quot;被排序数据&quot;的临时数组</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">buckets</span><span class="params">(<span class="number">10</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="comment">// 将数据出现的次数存储在buckets中</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        buckets[(vec[i]/exp)%<span class="number">10</span>]++;</span><br><span class="line">    <span class="comment">// 更改buckets[i]。目的是让更改后的buckets[i]的值，是该数据在output[]中的位置。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">        buckets[i] += buckets[i - <span class="number">1</span>];</span><br><span class="line">    <span class="comment">// 将数据存储到临时数组output中</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        output[buckets[(vec[i]/exp)%<span class="number">10</span>] - <span class="number">1</span>] = vec[i];</span><br><span class="line">        buckets[(vec[i]/exp)%<span class="number">10</span>]--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将排序好的数据赋值给vec</span></span><br><span class="line">    vec.<span class="built_in">swap</span>(output);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RadixSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; vec, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> max = <span class="built_in">get_max</span>(vec, n);    </span><br><span class="line">    <span class="comment">// 从个位开始，对数组a按&quot;指数&quot;进行排序</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> exp = <span class="number">1</span>; max/exp &gt; <span class="number">0</span>; exp *= <span class="number">10</span>)</span><br><span class="line">        <span class="built_in">count_sort</span>(vec, n, exp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/alzzw/article/details/98100378&quot;&gt;参考博客&lt;/a&gt;&lt;/p&gt;
&lt;img src=&quot;../../img/Algorithm/排序算法分类.png&quot; width=&quot;100%&quot; height</summary>
      
    
    
    
    <category term="Algorithm" scheme="https://escapeey.github.io/categories/Algorithm/"/>
    
    
    <category term="Algorithm" scheme="https://escapeey.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Unity-NGUI之基础及组合控件</title>
    <link href="https://escapeey.github.io/post/f24ad560.html"/>
    <id>https://escapeey.github.io/post/f24ad560.html</id>
    <published>2024-01-05T19:49:55.000Z</published>
    <updated>2024-05-22T06:03:05.833Z</updated>
    
    <content type="html"><![CDATA[<img src="../../../img/Unity/NGUI_Root_缩放模式设置.bmp" width="70%" height="50%"><h1>基础控件</h1><h2 id="Sprite">Sprite</h2><h3 id="Sprite作用">Sprite作用</h3><p>NGUI中所有中小尺寸图片显示都用Sprite显示<br>使用它来显示图集中的单个图片资源</p><h3 id="创建Sprite">创建Sprite</h3><ul><li>Scene窗口红框内右键</li><li>上方工具栏<strong>NGUI</strong>中创建</li></ul><h3 id="Sprite参数">Sprite参数</h3><p>略</p><h3 id="代码设置图片">代码设置图片</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.改变为当前图集中选择的图片</span></span><br><span class="line">sprite.spriteName = <span class="string">&quot;bk&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.改变为其它图集中的图片</span></span><br><span class="line"><span class="comment">//先加载图集</span></span><br><span class="line">NGUIAtlas atlas = Resources.Load&lt;NGUIAtlas&gt;(<span class="string">&quot;Atlas/login&quot;</span>);</span><br><span class="line">sprite.atlas = atlas;</span><br><span class="line"><span class="comment">//再设置图片</span></span><br><span class="line">sprite.spriteName = <span class="string">&quot;ui_DL_anniuxiao_01&quot;</span>;</span><br></pre></td></tr></table></figure><h2 id="Label">Label</h2><ul><li>文本(支持富文本)</li></ul><h2 id="Texture">Texture</h2><ul><li>一般图片，不能放到atlas 中的图片</li></ul><h1>组合控件</h1><h2 id=""></h2>]]></content>
    
    
      
      
    <summary type="html">&lt;img src=&quot;../../../img/Unity/NGUI_Root_缩放模式设置.bmp&quot; width=&quot;70%&quot; height=&quot;50%&quot;&gt;
&lt;h1&gt;基础控件&lt;/h1&gt;
&lt;h2 id=&quot;Sprite&quot;&gt;Sprite&lt;/h2&gt;
&lt;h3 id=&quot;Sprite作用&quot;&gt;Spr</summary>
      
    
    
    
    <category term="Unity" scheme="https://escapeey.github.io/categories/Unity/"/>
    
    
    <category term="C#" scheme="https://escapeey.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>OS-文件管理</title>
    <link href="https://escapeey.github.io/post/331e8fa6.html"/>
    <id>https://escapeey.github.io/post/331e8fa6.html</id>
    <published>2024-01-05T16:46:13.000Z</published>
    <updated>2024-05-22T06:03:05.833Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>OS-IO设备管理</title>
    <link href="https://escapeey.github.io/post/346f634c.html"/>
    <id>https://escapeey.github.io/post/346f634c.html</id>
    <published>2024-01-05T16:46:06.000Z</published>
    <updated>2024-05-22T06:03:05.833Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>OS-存储器管理</title>
    <link href="https://escapeey.github.io/post/3d04630d.html"/>
    <id>https://escapeey.github.io/post/3d04630d.html</id>
    <published>2024-01-05T16:44:32.000Z</published>
    <updated>2024-05-22T06:03:05.833Z</updated>
    
    <content type="html"><![CDATA[<p>存储管理是指存储器资源（主要指内存并涉及外存）的管理。</p><ul><li><strong>存储器资源的组织</strong>（如内存的组织方式）</li><li><strong>地址变换</strong>（逻辑地址与物理地址的对应关系维护）</li><li><strong>虚拟存储的调度算法</strong></li></ul><h1>存储管理的功能</h1><ol><li><strong>主存分配和回收</strong><br>分配和回收算法及相应的数据结构。</li><li><strong>地址变换</strong><ul><li>可执行文件生成中的链接技术</li><li>程序加载(装入)时的重定位技术</li><li>进程运行时硬件和软件的地址变换技术和机构</li></ul></li><li><strong>存储共享和保护</strong><ul><li>代码和数据共享</li><li>地址空间访问权限（读、写、执行）</li></ul></li><li><strong>主存容量扩充</strong>(存储器的逻辑组织和物理组织)<ul><li>由应用程序控制：覆盖；</li><li>由OS控制：交换（整个进程空间），虚拟存储的请求调入和预调入（部分进程空间）</li><li>提高主存利用率</li></ul></li></ol><h1>程序的装入和链接</h1><h2 id="程序的装入-重定位-地址映射">程序的装入(重定位)(地址映射)</h2><h3 id="重定位">重定位</h3><ul><li><strong>重定位</strong>: 程序运行装入主存时，要将程序中的虚拟地址转换为主存中的物理地址，这个转化过程就是重定位。</li><li>程序成为进程前的准备工作:<ul><li><strong>编辑</strong>：形成源文件(符号地址)</li><li><strong>编译</strong>：形成目标模块(模块内符号地址解析)</li><li><strong>链接</strong>：由多个目标模块或程序库生成可执行文件(模块间符号地址解析)</li><li><strong>装入</strong>：构造PCB，形成进程(使用物理地址)</li></ul></li></ul><h3 id="重定位方法">重定位方法</h3><h4 id="可重定位装入-静态重定位">可重定位装入(静态重定位)</h4><ul><li>内容<ul><li>编写程序时可以采用相对地址</li><li>作业（用户程序）在装入内存时才确定它的物理地址，并且将相对地址转换为物理地址</li><li>作业一旦装入就不能移动、改变空间或者被换出主存。</li><li>在程序运行之前，由<strong>链接</strong>装入程序进行的一次重定位。</li><li>在程序运行之前已经<strong>完成了逻辑地址到物理地址的转换</strong>(只要完成链接装入)</li></ul></li><li>优点：<strong>不需硬件变换机构</strong>支持，可以装入有限多道程序</li><li>缺点：一个程序通常需要占用连续的内存空间，程序装入内存后<strong>在运行期间不能移动</strong>，不易实现共享。</li></ul><h4 id="动态运行时装入-动态重定位">动态运行时装入(动态重定位)</h4><ul><li>内容<ul><li>动态重定位是在程序<strong>执行的过程</strong>中，每当访问指令或数据时，才将要访问的<strong>指令或数据</strong>的<strong>逻辑地址转换成物理地址</strong>。</li><li>在程序<strong>装入时不对地址做任何操作</strong>，也就是保留逻辑地址不变。</li><li><strong>运行时重定位</strong>：可以使程序载入后还可以移动</li><li>每个进程有各自的<strong>基地址,放在PCB</strong></li></ul></li></ul><h1>连续分配方式</h1><h2 id="分配方式">分配方式</h2><ul><li><p><strong>固定分区</strong>: 把内存划分为若干个固定大小的连续分区。</p><ul><li>分区大小可以相等也可以不同</li><li><strong>固定分区可能存在内碎片</strong></li><li>系统通过<strong>分区说明表</strong>对内存进行管理和控制。</li></ul></li><li><p><strong>动态分区</strong>：在装入程序时按其初始要求分配，或在其执行过程中通过系统调用进行分配或改变分区大小。</p><ul><li>没有内碎片；有外碎片，如果大小不是任意的，也可能出现内碎片。</li><li><strong>内存紧缩</strong>：将空闲分区合并，需要移动多个段(复制内容)：</li></ul></li></ul><h2 id="分区分配数据结构">分区分配数据结构</h2><h3 id="空闲分区表">空闲分区表</h3><ul><li>用于为内存中每个<strong>尚未分配</strong>的分区设置一个表项，每个分区的表项包含<strong>分区序号</strong>、<strong>分区始址</strong>及<strong>分区大小</strong>；</li></ul><h3 id="空闲分区链">空闲分区链</h3><ul><li>通过前、后向指针将所有的分区链接成一个双向链</li></ul><h2 id="分区分配算法">分区分配算法</h2><h3 id="首次适应算法FF">首次适应算法FF</h3><ol><li>内容<br>内存分配时，从<strong>链首开始顺序查找</strong>，直至找到一个能满足其大小要求的空闲分区为止。然后按作业大小划出一块内存空间分配给请求者，余下的空闲分区仍留在空闲链中。</li><li>优点<ul><li>优先利用内存中<strong>低址</strong>部分的空闲分区，在<strong>高址</strong>部分的空闲分区很少被利用，从而保留了高址部分的大空闲区，为后到的大作业分配大的内存空间创造了条件。</li></ul></li><li>缺点<ul><li><strong>低址部分不断被划分</strong>，形成碎片；</li><li>每次查找都从低址部分开始，这<strong>增加了查找可用空闲分区的开销</strong>。</li></ul></li></ol><h3 id="循环首次适应算法">循环首次适应算法</h3><ol><li>内容<ul><li>内存分配时，从<strong>上次找到的空闲分区的下一个空闲分区</strong>开始查找，直至找到第一个能满足要求的空闲分区，并从中划出一块与请求的大小相等的内存空间分配给作业</li><li>设置一起始查寻指针，并采用<strong>循环查找</strong>方式。</li></ul></li><li>优点<ul><li>使内存中的空闲分区分布得更均匀</li><li>减少查找空闲分区的开销</li></ul></li><li>缺点<ul><li>缺乏大的空闲分区</li></ul></li></ol><h3 id="最佳适应算法">最佳适应算法</h3><ol><li>内容<ul><li>“最佳”是指每次为作业分配内存时，总把<strong>既能满足要求</strong>、<strong>又是最小</strong>的空闲分区分配给作业，避免了“大材小用”。</li><li>为了加速寻找，该算法要求将所有的空闲区，<strong>按其大小以递增</strong>的顺序形成<strong>空闲区链</strong>。</li></ul></li></ol><h2 id="分区分配和回收操作">分区分配和回收操作</h2><h3 id="动态分区分配内存">动态分区分配内存</h3><blockquote><ul><li>首先系统要利用某种分配算法，从空闲分区链(表)中找到所需的分区;</li><li>设<strong>请求的分区大小为u.size</strong>，表中每个空闲分区的大小可表示为m.size;</li><li>if(<strong>m.size-u.size&lt;=size</strong>)<br>- // size是事先规定的不再切割的剩余分区的大小<br>- 说明多余部分太小,可不再切割，<strong>将整个分区分配给请求者</strong>;</li><li>else<br>- 从该分区中划分出与请求的大小相等的内存空间分配出去，余下的部分仍留在空闲分区链或空闲分区表中。最后，将分配区的首址返回给调用者;</li></ul></blockquote><h3 id="回收内存">回收内存</h3><h4 id="内存紧缩">内存紧缩</h4><ul><li>内容：将各个占用分区向内存一端移动。使各个空闲分区聚集在另一端，然后将各个空闲分区合并成为一个空闲分区。</li><li>这过程涉及到了<strong>动态重定位</strong></li><li>紧缩时机：每个分区释放后，或内存分配找不到满足条件的空闲分区时</li></ul><h3 id="可重定位分区分配-增加了内存紧凑">可重定位分区分配(增加了内存紧凑)</h3><img src="..\..\img\OS\动态重定位分区分配算法.png" width="50%" height="70%" align="middle"><h2 id="对换">对换</h2><h3 id="对换的定义">对换的定义</h3><ul><li>指把内存中<strong>暂时不能运行的进程</strong>或者<strong>暂时不用的程序和数据</strong>，调出到<strong>外存</strong>上，以便腾出足够的内存空间，再把已具备运行条件的进程或进程所需要的程序和数据，调入内存</li><li>对换是提高内存利用率的有效措施</li><li>整体对换(进程对换): 对换是以整个进程为单位</li><li>部分对换(页面对换/分段对换): 对换是以“<strong>页</strong>”或“<strong>段</strong>”为单位进行</li><li>为了实现进程对换，系统必须能实现三方面的功能：<ul><li>对换空间的管理</li><li>进程的换出</li><li>进程的换入</li></ul></li></ul><h3 id="对换空间的管理">对换空间的管理</h3><ul><li>数据结构: 空闲分区表或空闲分区链</li><li><strong>空闲分区表</strong>中的每个表目中应<strong>包含两项</strong>， 即<strong>对换区</strong>的<strong>首址</strong>及其<strong>大小</strong>，它们的单位是<strong>盘块号</strong>和<strong>盘块数</strong>。</li></ul><blockquote><p><strong>外存空间分类</strong><br><strong>文件区</strong>：用于<strong>存放文件</strong>，由于通常的文件都是较长久地驻留在外存上，故对文件区管理的主要目标是<strong>提高文件存储空间的利用率</strong>，为此系统采取<strong>离散分配</strong>方式。<br><strong>对换区</strong>：用于<strong>存放从内存换出的进程</strong>，由于这些进程在对换区中驻留的时间是短暂的，而对换操作又较频繁，故对对换空间管理的主要目标是<strong>提高进程的换入、换出速度</strong>，为此所应采取的管理策略是<strong>用连续分配方式</strong>，较少考虑外存中的碎片问题。</p></blockquote><h3 id="进程的换出与换入">进程的换出与换入</h3><h4 id="进程的换出">进程的换出</h4><ul><li>每一进程由于创建子进程而需要更多的内存空间，但又无足够的内存空间等情况发生时，系统应将某进程换出</li><li>换出过程:<ul><li>系统首先选择处于<strong>阻塞状态</strong>且<strong>优先级最低</strong>的进程作为换出进程;</li><li>启动盘块，将该进程的程序和数据传送到磁盘的对换区上;</li><li>若传送过程未出现错误，便可<strong>回收该进程所占用的内存空间</strong>，并对该进程的PCB做相应的修改。</li></ul></li></ul><h4 id="进程的换入">进程的换入</h4><ul><li>系统应<strong>定时地查看</strong>所有进程的状态;</li><li>从中找出“<strong>就绪</strong>”状态但已换出的进程，将其中<strong>换出时间(换出到磁盘上)最久的进程</strong>作为换入进程，将之换入;</li><li>直至已无可换入的进程或无可换出的进程为止。</li></ul><h1>离散分配方式</h1><ul><li>思想：将<strong>一个进程</strong>直接<strong>分散地分配到许多不相邻接的分区中</strong>，就不必再进行“紧凑”。</li><li>离散分配种类：<ul><li>分页存储管理</li><li>分段存储管理</li><li>段页式存储管理</li></ul></li></ul><h1>基本分页存储管理方式</h1><h2 id="页面和物理块">页面和物理块</h2><ul><li><strong>页面</strong>:<ul><li>将一个进程的<strong>逻辑地址空间</strong>分成若干个<strong>大小相等</strong>的片，称为<strong>页面</strong>或<strong>页</strong>，并为各页加以编号，从0开始，如第0页、第1页等。</li></ul></li><li><strong>物理块(页框)</strong>:<ul><li>把<strong>内存空间</strong>分成与<strong>页面相同大小</strong>的若干个存储块</li></ul></li><li>分配时<strong>主存块可以不连续</strong>; 而<strong>页内逻辑地址是连续的</strong></li><li><strong>分页存储器的逻辑地址</strong>: 页号和页内地址(位移量)<ul><li>假设地址总长度为15位，其中页号占5位，页内地址占10位;那么逻辑地址可有32页，编号为0－31;页内地址占10位，则块的大小为1024个字节。编号为0－1023。</li><li>若给定一个逻辑地址空间中的地址为A，页面的大小为L，则页号P和页内地址d可按下式求得:</li></ul><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>P</mi><mo>=</mo><mi>I</mi><mi>N</mi><mi>T</mi><mo stretchy="false">[</mo><mi>A</mi><mi mathvariant="normal">/</mi><mi>L</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">P=INT[A/L]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mord mathnormal" style="margin-right:0.13889em;">NT</span><span class="mopen">[</span><span class="mord mathnormal">A</span><span class="mord">/</span><span class="mord mathnormal">L</span><span class="mclose">]</span></span></span></span></span></p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>d</mi><mo>=</mo><mi>A</mi><mi>m</mi><mi>o</mi><mi>d</mi><mo stretchy="false">(</mo><mi>L</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">d=A mod(L)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">d</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">A</span><span class="mord mathnormal">m</span><span class="mord mathnormal">o</span><span class="mord mathnormal">d</span><span class="mopen">(</span><span class="mord mathnormal">L</span><span class="mclose">)</span></span></span></span></span></p></li></ul><h2 id="页表-地址变换机构">页表(地址变换机构)</h2><ul><li><p>作用：实现<strong>逻辑地址</strong>到<strong>物理地址</strong>的转换(将<strong>逻辑地址中的页号</strong>转换为<strong>内存中的物理块号</strong>)</p></li><li><p>地址转换的公式为：<strong>绝对地址＝块号*块长+页内地址</strong><br><img src="..\..\img\OS\页表变换地址.png" width="50%" height="70%" align="middle"></p></li><li><p>页表控制寄存器–系统中只有一个</p></li></ul><h2 id="引入快表-TLB-的地址变换机构">引入快表(TLB)的地址变换机构</h2><ul><li>引入原因：由于页表是存放在内存中的，这使CPU每次要存取一个数据时，都要两次访问内存。<ul><li>第一次是访问内存中的<strong>页表</strong>，从中找到该页的物理块号，将此块号与页内偏移量w拼接以形成物理地址</li><li>第二次访问内存时，才是从第一步所得地址中<strong>获得所需数据</strong>(或向此地址中写入数据)</li></ul></li><li>TLB是一组相联快速存储，是寄存器，类似<strong>Cache</strong></li><li><em><em>有效访问时间 = HitR</em>(TLB+MA) + (1-HitR)*(TLB+2MA)</em>*</li><li>原理：<ul><li>程序的地址访问存在局部性</li><li>空间局部性(程序多体现为循环、顺序结构)<br><img src="..\..\img\OS\具有块表的页表地址变换.png" width="50%" height="70%" align="middle"></li></ul></li></ul><h2 id="两级和多级页表">两级和多级页表</h2><ul><li>引入原因: 现代的大多数计算机系统，都支持非常大的逻辑地址空间。在这样的环境下，页表就变得非常大，要占用相当大的内存空间。并且为连续的。</li><li>解决方法：<ul><li>采用<strong>离散分配方式</strong>来解决难以找到一块连续的大内存空间的问题；</li><li>将<strong>当前需要的部分页表项调入内存</strong>，其余的<strong>页表项驻留在磁盘上</strong>，需要时再调入</li></ul></li></ul><h3 id="两级页表">两级页表</h3><ul><li>将页表也进行分页的办法，使每个页面的大小与内存物理块的大小相同，并为它们进行编号，即依次为0页，1页，…，n页。可以离散地将各个页面分别放在不同的物理块中</li><li>外层页表：为离散分配的页表再建立一张页表，称为外层页表(Outer Page Table)，在每个页表项中记录了页表页面的物理块号。</li></ul><h1>基本分段存储管理方式</h1><ul><li>引入：为了满足用户和程序员的下述一系列需要：<ul><li><strong>方便编程</strong>：通常采用分段，汇编。。。</li><li><strong>信息共享</strong>：通常，在实现程序和数据的共享时，都是以信息的逻辑单位为基础的；<ul><li>比如，共享某个例程和函数。而在分页系统中的每一页都只是存放信息的物理单位，其本身并无完整的意义，因而不便于实现信息共享；然而段却是信息的逻辑单位。</li></ul></li><li><strong>信息保护</strong></li><li><strong>动态增长</strong></li><li><strong>动态链接</strong></li></ul></li></ul><h2 id="分段">分段</h2><ul><li>内容：<ul><li>作业的地址空间被划分为若干个段，每个段定义了一组逻辑信息。</li><li>将程序的地址空间划分为若干个段(segment)，程序加载时，分配其所需的所有段（内存分区），这些段不必连续；物理内存的管理采用动态分区。需要CPU的硬件支持。</li></ul></li><li>优点：<ul><li>没有内碎片，外碎片可以通过内存紧缩来消除</li><li>便于改变进程占用空间的大小</li></ul></li></ul><h2 id="段表">段表</h2><p>段表实现从逻辑段到物理内存区的映射。<br><img src="..\..\img\OS\段表变换地址.png" width="50%" height="70%" align="middle"></p><h2 id="分页和分段的主要区别">分页和分段的主要区别</h2><h3 id="相同点">相同点</h3><ul><li>都采用离散分配方式；</li><li>都要通过地址映射机构来实现地址变换</li></ul><h3 id="不同点">不同点</h3><ul><li><strong>分页是出于系统管理</strong>的需要，<strong>分段是出于用户应用</strong>的需要<ul><li>一条指令或一个操作数可能会跨越两个页的分界处，而不会跨越两个段的分界处。</li></ul></li><li>页大小是系统固定的，而段大小则通常不固定</li><li><strong>逻辑地址表示</strong>：<ul><li>分页是一维的，各个模块在链接时必须组织成同一个地址空间；</li><li>分段是二维的，各个模块在链接时可以每个段组织成一个地址空间</li></ul></li><li>通常<strong>段比页大</strong>，因而段表比页表短，可以缩短查找时间，提高访问速度。</li><li>分页系统能有效地<strong>提高内存利用率</strong>，而分段系统则能很好地<strong>满足用户需要</strong>。</li></ul><h1>段页式存储管理方式</h1><h2 id="优点：">优点：</h2><ul><li>段页式既具有分段系统<strong>便于实现、分段可共享、易于保护、可动态链接</strong>等一系列优点；</li><li>也具有分页系统那样很好地<strong>解决内存的外部碎片问题</strong>，以及为各个分段<strong>可离散地</strong>分配内存等问题</li></ul><h2 id="基本原理">基本原理</h2><p>把用户程序分成若干段，再把每个段分成若干页<br><img src="..\..\img\OS\段页式地址变换.png" width="50%" height="70%" align="middle"></p><ul><li>在段页式系统中，为了获取一条指令或数据，须3次访问内存。<ul><li>第一次：访问内存中的段表，从中取得页表地址；</li><li>第二次：访问内存中的页表，从中取出该页所在的物    理块号，同时和页内地址相加求出物理地址；</li><li>第三次：从地址中取出指令或数据；</li></ul></li></ul><h1>虚拟存储器的基本概念</h1><ul><li>引入原因：<ul><li>作业很大：<br>其所要求的内存空间超过了内存总容量，作业不能全部被装入内存，致使该作业无法运行；</li><li>大量作业要求运行：<br>但由于内存容量不足以容纳所有这些作业，只能将少数作业装入内存让它们先运行，而将其它大量的作业留在外存上等待。</li></ul></li><li>解决方法：<ul><li>从<strong>物理上</strong>增加内存容量。</li><li>从<strong>逻辑上</strong>扩充内存容量。这正是<strong>虚拟存储技术</strong>所要解决的主要问题。</li></ul></li></ul><h2 id="定义">定义</h2><ul><li>所谓<strong>虚拟存储器</strong>，是指具有<strong>请求调入功能</strong>和<strong>置换功能</strong>，能从<strong>逻辑上</strong>对<strong>内存容量加以扩充</strong>的一种存储器系统。</li><li>其<strong>逻辑容量</strong>受限于计算机的<strong>地址结构</strong>和<strong>可用磁盘容量</strong>，其运行速度<strong>接近于内存速度</strong>。</li></ul><h2 id="基本原理-2">基本原理</h2><ul><li>在程序装入时，不必将其全部读入到内存，而只需<strong>将当前需要执行的部分页或段读入到内存</strong>，就可让程序开始执行。</li><li>在程序执行过程中，如果需执行的指令或访问的数据尚未在内存（称为<strong>缺页或缺段</strong>），则由处理器通知操作系统将相应的页或段<strong>调入到内存</strong>，然后继续执行程序。</li><li>另一方面，操作系统将内存中<strong>暂时不使用的页或段调出保存在外存</strong>上，从而腾出空间存放将要装入的程序以及将要调入的页或段。只需程序的一部分在内存就可执行。</li></ul><h2 id="优点">优点</h2><ul><li><strong>大程序</strong>：可在较小的可用内存中执行较大的用户程序；</li><li><strong>大的用户空间</strong>：提供给用户可用的虚拟内存空间通常大于物理内存(real memory)</li><li><strong>并发</strong>：可在内存中容纳更多程序并发执行；</li><li><strong>易于开发</strong>：与覆盖技术比较，不必影响编程时的程序结构</li></ul><h2 id="实现方式">实现方式</h2><ul><li>虚拟存储器的实现，是建立在<strong>离散分配</strong>的存储管理方式基础上</li><li>常见方法有：<ul><li>分页请求系统</li><li>分段请求系统</li></ul></li></ul><h1>请求分页存储管理方式</h1><h1>页面置换算法</h1><h1>请求分段存储管理方式</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;存储管理是指存储器资源（主要指内存并涉及外存）的管理。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;存储器资源的组织&lt;/strong&gt;（如内存的组织方式）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;地址变换&lt;/strong&gt;（逻辑地址与物理地址的对应关系维护）&lt;/li&gt;
&lt;li&gt;&lt;s</summary>
      
    
    
    
    <category term="操作系统" scheme="https://escapeey.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="操作系统" scheme="https://escapeey.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>OS-进程管理</title>
    <link href="https://escapeey.github.io/post/18614213.html"/>
    <id>https://escapeey.github.io/post/18614213.html</id>
    <published>2024-01-05T16:43:12.000Z</published>
    <updated>2024-05-22T06:03:05.833Z</updated>
    
    <content type="html"><![CDATA[<h1>进程的描述与控制</h1><h2 id="程序的顺序执行及其特征">程序的顺序执行及其特征</h2><p>程序顺序执行时的特征:</p><ul><li><strong>顺序性</strong>: 按照程序结构所指定的次序</li><li><strong>封闭性</strong>: 运行时候独占处理机资源，运行结果不受外界影响</li><li><strong>可再现性</strong>: 初始条件相同，结果相同</li></ul><h2 id="程序的并发执行及其特征">程序的并发执行及其特征</h2><p><strong>定义</strong>：程序的并发执行是指一组在逻辑上互相独立的程序或程序段在执行时间上客观上互相重叠，即一个程序或程序段的执行尚未结束，另一个程序（段）的执行已经开始的执行方式<br>程序并发执行时的特征:</p><ul><li><strong>间断性(相互制约性)</strong>:－ “走走停停”，一个程序可能走到中途停下来，失去原有的时序关系；</li><li><strong>失去封闭性</strong>：多个程序共享系统中的各种资源，因而这些资源的状态将由多个程序来改变, 致使程序的运行已失去了封闭性。</li><li><strong>不可再现性</strong>：程序在并发执行时，由于失去了封闭性，也将导致失去其可再现性</li></ul><h2 id="进程">进程</h2><h3 id="进程的定义">进程的定义</h3><ul><li>简：进程是程序的一次执行；</li><li>详：一个具有一定独立功能的<strong>程序</strong>在一个<strong>数据集合</strong>上的一次<strong>动态执行</strong>过程</li><li>进程是系统进行<strong>资源分配和调度</strong>的一个<strong>独立单位</strong></li></ul><h3 id="进程的特征">进程的特征</h3><ul><li><strong>动态性</strong>:<ul><li>进程是程序产生的：创建-&gt;运行-&gt;消亡</li><li>进程在生命周期中在三种基本状态之间转换</li></ul></li><li><strong>独立性</strong>:<br>各进程的<strong>地址相互独立</strong>，除非采用进程间通信手段</li><li><strong>并发性</strong>:<br>多个进程实体同时存于内存中，能在一段时间内并发进行</li><li><strong>异步性</strong>:<br>每个进程都以其相对独立的不可预知的速度向前推进</li><li><strong>结构化</strong>:<br>进程 = 代码块 + 数据块 + <strong>PCB</strong></li></ul><h3 id="进程的组成">进程的组成</h3><p><strong>进程 = 程序 + 数据 + 进程控制块PCB</strong></p><ul><li><strong>程序</strong>是进程的不可缺少的组成部分；如果一个程序段允许被共享，则它应该是可重入的，或纯代码段</li><li><strong>数据</strong>是进程处理的对象</li><li><strong>进程控制块</strong>是进程的<strong>控制结构</strong>，包含了进程的<strong>描述信息</strong>、<strong>控制信息</strong>和<strong>资源信息</strong>以及<strong>现场保护区</strong>，是进程的<font color=red><strong>唯一标识</strong></font>，系统通过PCB管理和控制进程。</li></ul><h3 id="进程控制块PCB">进程控制块PCB</h3><ul><li>进程控制块是由OS维护的用来记录进程相关信息和管理进程而设置的一个专门的<strong>数据结构</strong></li><li>PCB结构的全部或部分<strong>常驻内存</strong>；</li><li>PCB随进程的创建而填写，随进程的撤消而释放,有生命周期；</li><li>系统利用PCB来控制和管理进程，所以PCB是系统感知进程存在的唯一标志</li><li>进程与PCB是一一对应的</li><li><strong>OS是根据PCB来对并发执行的进程进行控制和管理的。</strong></li><li><strong>所谓创建进程是指创建进程实体中的PCB，撤销亦如此。</strong></li></ul><h4 id="PCB的内容">PCB的内容</h4><ul><li><strong>进程标识符</strong>:<ul><li>内部进程标识符(process ID)，唯一，通常是一个整数</li><li>进程名(外部标识符)，通常基于可执行文件名（不唯一）</li><li>用户标识符(user ID)；进程组关系(process group)</li></ul></li><li><strong>进程调度信息</strong>：<br>进程状态、进程优先级、资源信息等</li><li><strong>处理机状态</strong>：<br>寄存器值（通用、程序计数器PC、状态PSW，地址包括栈指针）</li><li><strong>进程控制信息</strong>:<ul><li>当前状态；</li><li>优先级(priority)；</li><li>代码执行入口地址；</li><li>程序的外存地址；</li><li>运行统计信息（执行时间、页面调度）；</li><li>进程间同步和通信；阻塞原因</li></ul></li></ul><h4 id="PCB的组织方式">PCB的组织方式</h4><ul><li><strong>链表</strong>：同一状态的进程其PCB成一链表，多个状态对应多个不同的链表<ul><li>各状态的进程形成不同的链表：就绪链表、阻塞链表</li></ul></li><li><strong>索引表</strong>：同一状态的进程归入一个index表（由index指向PCB），多个状态对应多个不同的index表<ul><li>各状态的进行形成不同的索引表：就绪索引表、阻塞索引表</li></ul></li></ul><h3 id="进程与程序的区别">进程与程序的区别</h3><ul><li>进程是动态的，程序是静态的：炒菜菜谱</li><li>进程是暂时的，程序的永久的：进程是一个状态变化的过程，程序可长久保存。</li><li>进程与程序的组成不同：进程的组成包括程序、数据和进程控制块（即进程状态信息）。</li><li>进程与程序的对应关系：通过多次执行，一个程序可对应多个进程；通过调用关系，一个进程可包括多个程序。</li><li>进程具有并行特征，程序没有。</li><li>进程是竞争计算机资源的基本单位。</li></ul><h2 id="进程的状态及其转换">进程的状态及其转换</h2><h3 id="进程的三种基本状态">进程的三种基本状态</h3><ul><li><strong>就绪状态(Ready)</strong>：已分配到<strong>除CPU以外</strong>的所有必要的资源，只要能再获得处理机，便可立即执行的状态。多个排成一队称为就绪队列。</li><li><strong>执行状态(Running)</strong>：指进程已获得处理机，其程序正在执行;<ul><li>在单处理机系统中，只能有一个进程处于执行状态;</li><li>在多处理机系统中，则可能多个进程处于执行状态。 </li></ul></li><li><strong>阻塞状态(Blocked)</strong>：进程因<strong>发生某事件</strong>(如请求I／O、申请缓冲空间等)而暂停执行时的状态，亦即进程的执行受到阻塞，故称这种暂停状态为阻塞状态，有时也称为“等待”状态或“睡眠”状态。<ul><li>通常将处于阻塞状态的进程排成一个队列，称为阻塞队列。在有的系统中，按阻塞原因的不同而将处于阻塞状态的进程排成多个队列。</li></ul></li></ul><h3 id="进程的三种基本状态转换">进程的三种基本状态转换</h3><img src="..\..\img\OS\进程三状态.png" width="50%" height="70%" align="middle"><ul><li><strong>就绪-&gt;运行</strong>：调度程序选择一个新的进程运行</li><li><strong>运行-&gt;就绪</strong>：<ul><li>运行进程用完了时间片</li><li>运行进程被中断，因为一高优先级进程处于就绪状态</li></ul></li><li><strong>运行-&gt;等待</strong>：当一进程等待某一事件的发生时，如<ul><li>请求系统服务</li><li>无新工作可做</li></ul></li><li><strong>等待-&gt;就绪</strong>：当所等待的事件发生时</li></ul><h3 id="进程的五状态进程转换">进程的五状态进程转换</h3><img src="..\..\img\OS\进程五状态.png" width="50%" height="70%" align="middle"><ul><li><strong>创建状态(New)</strong>：创建新状态<ul><li>OS 已完成为创建一进程所必要的工作<ul><li>已构造了进程标识符</li><li>已创建了管理进程所需的表格</li></ul></li></ul></li><li><strong>终止状态(Exit)</strong><ul><li>终止后进程移入该状态</li><li>它不再有执行资格</li><li>表格和其它信息暂时保留</li><li>实用程序为了分析性能和利用率，可能要提取程序的历史信息</li></ul></li></ul><h3 id="带挂起的进程转换模型">带挂起的进程转换模型</h3><h4 id="新增状态">新增状态</h4><ul><li><strong>就绪挂起状态(Ready,suspend)</strong>：进程在外存，但只要进入内存，即可运行；</li><li><strong>阻塞挂起状态(Blocked,suspend)</strong>：进程在外存并等待某事件的出现；</li></ul><h4 id="新增事件">新增事件</h4><ul><li><strong>挂起(Suspend)</strong>：把一个进程从内存转到外存；可能有以下几种情况：<ul><li><strong>阻塞到阻塞挂起</strong>：没有进程处于就绪状态或就绪进程要求更多内存资源时，会进行这种转换，以纳入新进程或运行就绪进程；</li><li><strong>就绪到就绪挂起</strong>：当有高优先级阻塞（系统认为会很快就绪的）进程和低优先级就绪进程时，系统会选择挂起低优先级就绪进程；</li><li><strong>运行到就绪挂起</strong>：对抢先式分时系统，当有高优先级阻塞挂起进程因事件出现而进入就绪挂起时，系统可能会把运行进程转到就绪挂起状态；</li></ul></li><li><strong>激活(Activate)</strong>：把一个进程从外存转到内存；可能有以下几种情况：<ul><li><strong>就绪挂起到就绪</strong>：没有就绪进程或挂起就绪进程优先级高于就绪进程时，会进行这种转换；</li><li><strong>阻塞挂起到阻塞</strong>：当一个进程释放足够内存时，系统会把一个高优先级阻塞挂起（系统认为会很快出现所等待的事件）进程转为阻塞状态；较少出现。</li></ul></li><li><strong>事件出现(Event Occurs)</strong>：进程等待的事件出现；如：操作完成、申请成功等；可能的情况有：<ul><li><strong>阻塞到就绪</strong>：针对内存进程的事件出现；</li><li><strong>阻塞挂起到就绪挂起</strong>：针对外存进程的事件出现；</li></ul></li><li><strong>收容(Admit)</strong>：收容一个新进程，进入就绪状态或就绪挂起状态。</li><li><strong>各种状态-&gt;退出</strong>：被父进程终止或父进程本身终止。</li></ul><h4 id="挂起进程目的是">挂起进程目的是:</h4><ul><li><strong>提高处理机效率</strong>：就绪进程表为空时，OS将阻塞进程从内存中“挂起”到磁盘的“挂起队列”，再从该队列选另一进程进入内存，或接受一个新进程的请求。</li><li><strong>为运行进程提供足够内存</strong>：资源紧张时，暂停某些进程，如：CPU繁忙（或实时任务执行）,内存紧张</li><li><strong>用于调试</strong>：在调试时，挂起被调试进程（从而对其地址空间进行读写）</li></ul><h4 id="单挂起进程模型">单挂起进程模型</h4><img src="..\..\img\OS\单挂起进程模型.png" width="50%" height="70%" align="middle"><h4 id="双挂起进程模型">双挂起进程模型</h4><img src="..\..\img\OS\双挂起进程模型.png" width="50%" height="70%" align="middle"><h2 id="进程控制的功能">进程控制的功能</h2><h3 id="原语-primitive">原语(primitive)</h3><ul><li>由若干条指令构成的“原子操作(atomic operation)”过程，作为一个整体而不可分割－－要么全都完成，要么全都不做。许多系统调用就是原语。</li></ul><h3 id="进程创建原语">进程创建原语</h3><p>子进程的创建的3种形式</p><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">产生新进程</th><th style="text-align:center">不产生新进程</th></tr></thead><tbody><tr><td style="text-align:center">复制现有进程的上下文</td><td style="text-align:center"><strong>fork</strong>(新进程的系统上下文会有不同)</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">加载程序</td><td style="text-align:center"><strong>spawn</strong>(创建新进程并加载新程序)</td><td style="text-align:center"><strong>exec</strong>(加载新程序并覆盖自身)</td></tr></tbody></table><h3 id="进程撤销原语">进程撤销原语</h3><p><strong>Destroy</strong></p><ul><li>释放资源：<ul><li>释放内外存空间</li><li>关闭所有打开文件</li><li>释放共享内存段和各种锁定lock</li></ul></li></ul><h3 id="进程阻塞原语">进程阻塞原语</h3><p><strong>Block</strong></p><ul><li>阻塞原因：当进程期待的某事件尚未出现时，该进程调用阻塞原语把自己阻塞起来</li><li>进程的阻塞是进程自身的一种主动行为</li></ul><h3 id="进程唤醒原语">进程唤醒原语</h3><p><strong>Wakeup</strong></p><ul><li>唤醒原因：<ul><li>进程等待的事件发生，等待队列中的进程唤醒。</li></ul></li><li>唤醒进程的两种方法：<ul><li><strong>由系统进程唤醒</strong>: 系统进程统一控制事件的发生，并将“事件发生”这一消息通知等待进程。等待的是公共资源。</li><li><strong>由事件发生进程唤醒</strong>: 事件发生进程与被唤醒的进程是合作关系，等待私有资源。</li></ul></li></ul><h3 id="进程挂起原语">进程挂起原语</h3><p><strong>Suspend</strong></p><ul><li>引起进程挂起的事件:<ul><li>用户进程请求将自己挂起;</li><li>或父进程请求将自己的某个子进程挂起，</li><li>系统将利用挂起原语suspend( )将指定进程或处于阻塞状态的进程挂起。</li></ul></li></ul><h3 id="进程激活原语">进程激活原语</h3><p><strong>Active</strong></p><ul><li>进程的激活过程<ul><li>系统将利用激活原语active( )将指定进程激活。 激活原语先将进程从外存调入内存，检查该进程的现行状态，若是就绪挂起，便将之改为活动就绪；若为阻塞挂起便将之改为活动阻塞。</li></ul></li></ul><h1>进程同步</h1><h2 id="1-一组并发进程执行时存在两种相互制约关系：">1.一组并发进程执行时存在两种相互制约关系：</h2><ul><li><strong>进程互斥</strong> (打印机)<ul><li><strong>资源共享关系</strong>（间接相互制约关系）</li><li>进程本身之间<strong>不存在直接联系</strong>。</li><li>例如:在仅有一台打印机的系统中，有两个进程A和B，如果在A进程提出打印请求时，系统已将打印机分配给进程B，则系统让A进程等待，直至B将打印机用完并释放后，系统才将打印机分配给进程A。</li></ul></li><li><strong>进程同步</strong> (接力棒)<ul><li><strong>相互合作关系</strong>（直接相互制约关系）</li><li>进程本身之间<strong>存在着相互制约的关系</strong>。</li><li>例如：有一输入进程A通过单缓冲向进程B提供数据。当该缓冲空时，计算进程B因不能获得所需数据而等待。当进程A把数据送入缓冲时，便应向进程B发送一信号，将它唤醒</li></ul></li></ul><h2 id="2-临界资源">2.临界资源</h2><ul><li>临界资源: 在一段时间内只允许<strong>一个进程访问</strong>的资源。诸进程间应采取<strong>互斥方式</strong>，实现对资源的共享。</li><li>共享变量，打印机 等均属于此类资源。</li></ul><h2 id="3-临界区">3.临界区</h2><h3 id="临界区的定义与进入">临界区的定义与进入</h3><ul><li><strong>临界区</strong>(critical section)：<br>在每个进程中访问临界资源的那段代码</li><li><strong>进入区</strong>：<br>在临界区前面增加一段用于进行临界资源检查的代码</li><li><strong>退出区</strong>：<br>将临界区正被访问的标志恢复为未被访问的标志。</li><li><strong>剩余区</strong>：其余部分。</li></ul><h3 id="使用临界区遵循的原则">使用临界区遵循的原则</h3><ul><li><strong>空闲则入</strong>：其他进程均不处于临界区；</li><li><strong>忙则等待</strong>：已有进程处于其临界区；</li><li><strong>有限等待</strong>：等待进入临界区的进程不能&quot;死等&quot;；</li><li><strong>让权等待</strong>：不能进入临界区的进程，应释放CPU(如转换到阻塞状态)</li></ul><h3 id="解决诸进程互斥进入临界区的方法">解决诸进程互斥进入临界区的方法</h3><ul><li>硬件同步机制</li><li>软件同步机制</li></ul><h2 id="4-硬件同步机制">4.硬件同步机制</h2><p>目的：解决诸进程互斥进入临界区。<br>目前许多计算机已提供了一些特殊的硬件指令来解决临界区问题。</p><ul><li>关中断；<ul><li>关中断是实现互斥的最简单的方法之一。在进入锁测试之前关闭中断，直到完成锁测试并上锁之后才能打开中断。</li><li>关中断的方法存在许多缺点：<ul><li>滥用关中断权力可能导致严重后果；</li><li>关中断时间过长，会影响系统效率，限制了处理器交叉执行程序的能力；</li><li>关中断方法也不适用于多CPU 系统，因为在一个处理器上关中断并不能防止进程在其它处理器上执行相同的临界段代码。</li></ul></li></ul></li><li>利用Test-and-Set指令实现互斥；</li><li>利用Swap指令实现进程互斥；</li></ul><h2 id="5-软件同步机制-进程互斥的软件方法">5.软件同步机制(进程互斥的软件方法)</h2><h3 id="利用信号量机制实现进程互斥">利用信号量机制实现进程互斥</h3><h2 id="6-管程-monitor">6.管程(monitor)</h2><h1>进程通信及线程</h1><h1>处理机调度与死锁–完成进程状态的转换</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;进程的描述与控制&lt;/h1&gt;
&lt;h2 id=&quot;程序的顺序执行及其特征&quot;&gt;程序的顺序执行及其特征&lt;/h2&gt;
&lt;p&gt;程序顺序执行时的特征:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;顺序性&lt;/strong&gt;: 按照程序结构所指定的次序&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;封闭性&lt;</summary>
      
    
    
    
    <category term="操作系统" scheme="https://escapeey.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="操作系统" scheme="https://escapeey.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>OS-概述</title>
    <link href="https://escapeey.github.io/post/e50618fb.html"/>
    <id>https://escapeey.github.io/post/e50618fb.html</id>
    <published>2024-01-05T16:40:21.000Z</published>
    <updated>2024-05-22T06:03:05.833Z</updated>
    
    <content type="html"><![CDATA[<h1>操作系统定义</h1><p><strong>操作系统</strong>：是管理计算机系统资源、控制程序执行、改善人机界面和为应用软件提供支持的一种系统<font color=red>软件</font>。</p><h2 id="多道程序设计：">多道程序设计：</h2><p>现代操作系统一般都采用多道程序设计技术，其基本思想是在主存中同时存放多个用户的作业，使之同时处于运行状态而共享系统资源。</p><p>多道程序设计——多个程序同时进入主存并发执行。</p><h1>操作系统的作用</h1><h2 id="OS作为用户与计算机硬件系统之间的接口">OS作为用户与计算机硬件系统之间的接口</h2><ul><li>OS是一个系统软件，因而这种接口是<strong>软件接口</strong>。</li></ul><h2 id="OS作为计算机系统资源的管理者">OS作为计算机系统资源的管理者</h2><p>OS的<strong>主要功能</strong>为:</p><ul><li><strong>处理机管理</strong>：用于分配和控制处理机；</li><li><strong>存储器管理</strong>：主要负责内存的分配与回收；</li><li><strong>I/O设备管理</strong>：负责I/O设备的分配与操纵；</li><li><strong>文件管理</strong>：负责文件的存取、共享和保护。可见，OS确是计算机系统资源的管理者。</li></ul><h2 id="OS实现了对计算机资源的抽象">OS实现了对计算机资源的抽象</h2><ul><li>通常把覆盖了软件的机器称为扩充机器或虚机器。</li></ul><h1>操作系统的基本特性</h1><h2 id="并发">并发</h2><ul><li><strong>并行性</strong>：指两个或多个事件在同一时刻发生</li><li><strong>并发性</strong>：指两个或多个事件在同一时间间隔内发生<ul><li>在多道程序环境下，并发性是指在一段时间内，宏观上有多个程序在同时运行，但在单处理机系统中，每一时刻却仅能有一道程序执行，故微观上这些程序只能是分时地交替执行。</li></ul></li></ul><h2 id="共享">共享</h2><ul><li><strong>共享</strong>的概念：指系统中的资源，可供内存中多个并发执行的进程(线程)共同使用 。</li><li>进程对资源共享的方式：<ul><li><strong>互斥共享</strong>：当某一进程访问完并释放该资源后，才允许另一进程进行访问。这种资源称为<font color=red>临界资源</font>或独占资源,如打印机；</li><li><strong>同时共享</strong>：允许在一段时间内由多个进程同时访问，如磁盘设备</li></ul></li></ul><h2 id="虚拟">虚拟</h2><h3 id="定义">定义</h3><ul><li>操作系统中的所谓“<strong>虚拟</strong>”，是指通过某种技术把一个物理实体变为若干个逻辑上的对应物。</li><li>在OS中利用了多种虚拟技术，分别用来实现虚拟处理机、虚拟内存(设置：我的电脑、属性、高级、性能选项)、 虚拟外部设备(虚拟光驱、盘符D：等)和虚拟信道等。</li></ul><h3 id="OS中采用的2种虚拟技术">OS中采用的2种虚拟技术</h3><ul><li><strong>时分复用技术</strong> -多设备分时使用物理设备<ul><li>利用该技术可以实现虚拟处理机、虚拟设备等，以<strong>提高资源利用率</strong>。</li><li>虚拟处理机：是通过多道程序设计技术，让多道程序并发执行的方法，来分时使用一台处理机的。</li><li>虚拟设备技术：将一台物理I/O设备虚拟为多台逻辑上的I/O设备。 如虚拟打印机。</li></ul></li><li><strong>空分复用技术</strong><ul><li>利用该技术可以实现虚拟磁盘技术、虚拟存储器技术等，以<strong>提高存储空间利用率</strong>。</li><li>虚拟磁盘技术：一个硬盘划分为1、2、3、4四个卷，分别安装在C、D、E、F四个逻辑驱动器上，成为四个虚拟磁盘。</li><li>虚拟存储器技术：一个100M的程序可以运行在20M的内存空间</li></ul></li></ul><h2 id="异步性">异步性</h2><ul><li>在多道程序环境下，允许多个进程并发执行。使进程的执行是以“走走停停”的方式运行；</li><li><strong>进程的异步性</strong>: 每个程序在何时执行，多个程序间的执行顺序以及完成每道程序所需的时间都是不确定和不可预知的。进程是以人们不可预知的速度向前推进</li></ul><h1>操作系统结构设计</h1><ul><li>第一代：无结构OS；</li><li>第二代：模块化结构OS；</li><li>分层式操作系统；</li></ul><h2 id="模块化结构OS">模块化结构OS</h2><ul><li>模块之间直接调用函数，除了函数调用的开销外，没有额外开销</li><li>庞大的操作系统有数以千计的函数</li></ul><h2 id="微内核-Micro-Kelnel-结构OS-现代结构">微内核(Micro Kelnel)结构OS -现代结构</h2><h3 id="微内核技术">微内核技术</h3><ul><li><p><strong>微内核技术</strong>: 指精心设计的、能实现现代OS核心功能的小型内核，它与一般的OS(程序)不同，它更小更精炼，它不仅运行在核心态，而且<strong>开机后常驻内存</strong>。</p></li><li><p>微内核<strong>并非</strong>是一个完整的OS， 而只是为构建通用OS提供一个重要基础。在微内核OS结构中，通常都采用了<strong>客户/服务器模式</strong>。<br><img src="..\..\img\OS\os微内核.png" width="50%" height="70%" align="middle"></p></li><li><p><strong>优缺点</strong></p><ul><li>内核与各个服务器之间通过通信机制进行交互，这使得微内核结构的效率大打折扣</li><li>因为各个服务器模块的相对独立性，使得其维护相对容易。</li></ul></li></ul><h3 id="客户-服务器模式">客户/服务器模式</h3><p>客户/服务器系统主要由<strong>客户机</strong>、<strong>服务器</strong>和<strong>网络系统</strong>三个部分组成。</p><ul><li>客户机：平时处理本地业务，也可发送一个消息给服务器，以请求某项服务</li><li>服务器：通常是一台规模较大的机器，在其上驻留有网络文件系统或数据库系统等，为用户提供多种服务。</li></ul><h3 id="面向对象的程序设计技术">面向对象的程序设计技术</h3><ul><li>在OS中的各类实体如进程、线程、消息、存储器和文件等，都使用了对象这一概念，相应地，便有了进程对象、线程对象、存储器对象和文件对象等</li><li>操作系统是一个极其复杂的大型软件系统，面向对象技术被广泛应用于现代操作系统的设计中。</li></ul><h3 id="微内核的基本功能">微内核的基本功能</h3><p>通常都是一些最基本的功能：</p><ul><li>进程(线程)管理。</li><li>低级存储器管理。</li><li>中断和陷入处理。<br>将OS中<strong>最基本</strong>的部分放入内核中，而把OS的<strong>绝大部分功能</strong>放在微内核**外面的一组服务器（进程）**中实现。</li></ul><h3 id="微内核操作系统存在的问题">微内核操作系统存在的问题</h3><p>微内核OS的<strong>运行效率有所降低：</strong><br>会引起更多的上下文切换。例如某个服务器自身尚无能力完成客户请求，而需其它服务器帮助时，如图1-11中所示，其中的文件服务器还需要磁盘服务器的帮助，这时就需要进行八次上下文的切换。<br><img src="..\..\img\OS\os微内核缺点.png" width="50%" height="70%" align="middle"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;操作系统定义&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;操作系统&lt;/strong&gt;：是管理计算机系统资源、控制程序执行、改善人机界面和为应用软件提供支持的一种系统&lt;font color=red&gt;软件&lt;/font&gt;。&lt;/p&gt;
&lt;h2 id=&quot;多道程序设计：&quot;&gt;多道程序设计：&lt;/h2&gt;</summary>
      
    
    
    
    <category term="操作系统" scheme="https://escapeey.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="操作系统" scheme="https://escapeey.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>深度学习-梯度下降</title>
    <link href="https://escapeey.github.io/post/33115a55.html"/>
    <id>https://escapeey.github.io/post/33115a55.html</id>
    <published>2023-12-31T18:49:30.000Z</published>
    <updated>2024-05-22T06:03:05.833Z</updated>
    
    <content type="html"><![CDATA[<h1>反向传播算法</h1><img src="../../img/DeepLearning/bp推导.jpg" width="70%" height="70%" align="middle"><h1>梯度下降及其变体</h1><h2 id="批量梯度下降">批量梯度下降</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">do_gradient_descent</span>():</span><br><span class="line">    w,b,eta,max_epochs = -<span class="number">2</span>,-<span class="number">2</span>,<span class="number">1.0</span>,<span class="number">1000</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(max_epochs):</span><br><span class="line">        dw,db = <span class="number">0</span>,<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> x,y <span class="keyword">in</span> <span class="built_in">zip</span>(X,Y):</span><br><span class="line">            dw += grad_w(w,b,x,y)</span><br><span class="line">            db += grad_b(w,b,x,y)</span><br><span class="line">        w -= eta*dw</span><br><span class="line">        b -= eta*db</span><br></pre></td></tr></table></figure><h2 id="SGD">SGD</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">do_stochastic_gradient_descent</span>():</span><br><span class="line">w,b,eta,max_epochs = -<span class="number">2</span>,-<span class="number">2</span>,<span class="number">1.0</span>,<span class="number">1000</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(max_epochs):</span><br><span class="line">        dw,db = <span class="number">0</span>,<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> x,y <span class="keyword">in</span> <span class="built_in">zip</span>(X,Y):</span><br><span class="line">            dw = grad_w(w,b,x,y)</span><br><span class="line">            db = grad_b(w,b,x,y)</span><br><span class="line">            w -= eta*dw</span><br><span class="line">            b -= eta*db</span><br></pre></td></tr></table></figure><h2 id="MiniBatch">MiniBatch</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">do_mini_batch_gradient_descent</span>():</span><br><span class="line">    w,b,eta = -<span class="number">2</span>,-<span class="number">2</span>,<span class="number">1.0</span></span><br><span class="line">    mini_batch_size,num_points_seen = <span class="number">2</span>,<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(max_epochs):</span><br><span class="line">        dw,db,num_points = <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> x,y <span class="keyword">in</span> <span class="built_in">zip</span>(X,Y):</span><br><span class="line">            dw += grad_w(w,b,x,y)</span><br><span class="line">            db += grad_b(w,b,x,y)</span><br><span class="line">            num_points_seen += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> num_points_seen%mini_batch_size == <span class="number">0</span>:</span><br><span class="line">                w -= eta*dw</span><br><span class="line">                b -= eta*db</span><br><span class="line">                dw,db = <span class="number">0</span>,<span class="number">0</span></span><br></pre></td></tr></table></figure><h2 id="Momentum">Momentum</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">do_momentum_gradient_descent</span>():</span><br><span class="line">    w,b,eta = init_w,init_b,<span class="number">1.0</span></span><br><span class="line">    prev_v_w,prev_v_b,gamma = <span class="number">0</span>,<span class="number">0</span>,<span class="number">0.9</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(max_epochs):</span><br><span class="line">        dw,db = <span class="number">0</span>,<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> x,y <span class="keyword">in</span> <span class="built_in">zip</span>(X,Y):</span><br><span class="line">            dw += grad_w(w,b,x,y)</span><br><span class="line">            db += grad_b(w,b,x,y)</span><br><span class="line">        v_w = gamma * prev_v_w + eta*dw</span><br><span class="line">        v_b = gamma * prev_v_b + eta*db</span><br><span class="line">        w -= v_w</span><br><span class="line">        b -= v_b</span><br><span class="line">        prev_v_w = v_w</span><br><span class="line">        prev_v_b = v_b</span><br></pre></td></tr></table></figure><h2 id="NAGD">NAGD</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">do_nesterov_accelerated_gradient_descent</span>():</span><br><span class="line">    w,b,eta = init_w,init_b,<span class="number">1.0</span></span><br><span class="line">    prev_v_w,prev_v_b,gamma = <span class="number">0</span>,<span class="number">0</span>,<span class="number">0.9</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(max_epochs):</span><br><span class="line">        dw,db=<span class="number">0</span>,<span class="number">0</span></span><br><span class="line">       v_w = gamma * prev_v_w</span><br><span class="line">        v_b = gamma * prev_v_b</span><br><span class="line">        <span class="keyword">for</span> x,y <span class="keyword">in</span> <span class="built_in">zip</span>(X,Y):</span><br><span class="line">            dw += grad_w(w-v_w,b-v_b,x,y)</span><br><span class="line">            db += grad_b(w-v_w,b-v_b,x,y)</span><br><span class="line">        v_w = gamma*prev_v_w + eta*dw</span><br><span class="line">        v_b = gamma*prev_v_b + eta*db</span><br><span class="line">        w -= v_w</span><br><span class="line">        b -= v_b</span><br><span class="line">        prev_v_w = v_w</span><br><span class="line">        prev_v_b = v_b</span><br></pre></td></tr></table></figure><h2 id="Adagrad">Adagrad</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">do_adagrad</span>():</span><br><span class="line">    w,b,eta = init_w,init_b,<span class="number">0.1</span></span><br><span class="line">    v_w,v_b,eps = <span class="number">0</span>,<span class="number">0</span>,<span class="number">1e-8</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(max_epochs):</span><br><span class="line">        dw,db = <span class="number">0</span>,<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> x,y <span class="keyword">in</span> <span class="built_in">zip</span>(X,Y):</span><br><span class="line">            dw += grad_w(w,b,x,y)</span><br><span class="line">            db += grad_b(w,b,x,y)</span><br><span class="line">        v_w += dw**<span class="number">2</span></span><br><span class="line">        v_b += db**<span class="number">2</span></span><br><span class="line">        w -= (eta/np.sqrt(v_w+eps)) * dw</span><br><span class="line">        b -= (eta/np.sqrt(v_b+eps)) * db</span><br></pre></td></tr></table></figure><h2 id="RMSProp">RMSProp</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">do_rmsprop</span>():</span><br><span class="line">    w,b,eta = init_w,init_b,<span class="number">0</span>,<span class="number">1</span></span><br><span class="line">    v_w,v_b,eps,beta1 = <span class="number">0</span>,<span class="number">0</span>,<span class="number">1e-8</span>,<span class="number">0.9</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(max_epochs):</span><br><span class="line">        dw,db = <span class="number">0</span>,<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> x,y <span class="keyword">in</span> <span class="built_in">zip</span>(X,Y):</span><br><span class="line">            dw += grad_w(w,b,x,y)</span><br><span class="line">            db += grad_b(w,b,x,y)</span><br><span class="line">        v_w = beta1*v_w + (<span class="number">1</span>-beta1) * dw**<span class="number">2</span></span><br><span class="line">        v_b = beta1*v_b + (<span class="number">1</span>-beta1) * db**<span class="number">2</span></span><br><span class="line">        w -= (eta / np.sqrt(v_w+eps)) * dw</span><br><span class="line">        b -= (eta / np.sqrt(v_b+eps)) * db</span><br></pre></td></tr></table></figure><h2 id="Adam">Adam</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">do_adam</span>():</span><br><span class="line">    w,b,eta = init_w,init_b,<span class="number">0.1</span></span><br><span class="line">    m_w,m_b,v_w,v_b,m_w_hat,m_b_hat,v_w_hat,v_b_hat,eps,beta1,beta2 = <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1e-8</span>,<span class="number">0.9</span>,<span class="number">0.999</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(max_epochs):</span><br><span class="line">        dw,db = <span class="number">0</span>,<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> x,y <span class="keyword">in</span> <span class="built_in">zip</span>(X,Y):</span><br><span class="line">            dw += grad_w(w,b,x,y)</span><br><span class="line">            db += grad_b(w,b,x,y)</span><br><span class="line">        m_w = beta1*m_w + (<span class="number">1</span>-beta1) * dw</span><br><span class="line">        m_b = beta1*m_b + (<span class="number">1</span>-beta1) * db</span><br><span class="line">        v_w = beta2*v_w + (<span class="number">1</span>-beta2) * dw**<span class="number">2</span></span><br><span class="line">        v_b = beta2*v_b + (<span class="number">1</span>-beta2) * db**<span class="number">2</span></span><br><span class="line">        m_w_hat = m_w / (<span class="number">1</span>-math.<span class="built_in">pow</span>(beta1, i+<span class="number">1</span>))</span><br><span class="line">        m_b_hat = m_b / (<span class="number">1</span>-math.<span class="built_in">pow</span>(beta1, i+<span class="number">1</span>))</span><br><span class="line">        v_w_hat = v_w / (<span class="number">1</span>-math.<span class="built_in">pow</span>(beta2, i+<span class="number">1</span>))</span><br><span class="line">        v_b_hat = v_b / (<span class="number">1</span>-math.<span class="built_in">pow</span>(beta2, i+<span class="number">1</span>))</span><br><span class="line">        w -= (eta / np.sqrt(v_w_hat+eps)) * m_w_hat</span><br><span class="line">        b -= (eta / np.sqrt(v_b_hat+eps)) * m_b_hat</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;反向传播算法&lt;/h1&gt;
&lt;img src=&quot;../../img/DeepLearning/bp推导.jpg&quot; width=&quot;70%&quot; height=&quot;70%&quot; align=&quot;middle&quot;&gt;
&lt;h1&gt;梯度下降及其变体&lt;/h1&gt;
&lt;h2 id=&quot;批量梯度下降&quot;&gt;批量梯度下降</summary>
      
    
    
    
    
    <category term="深度学习" scheme="https://escapeey.github.io/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Unity-NGUI之三大基础组件</title>
    <link href="https://escapeey.github.io/post/b9d856e4.html"/>
    <id>https://escapeey.github.io/post/b9d856e4.html</id>
    <published>2023-12-30T10:48:47.000Z</published>
    <updated>2024-05-22T06:03:05.833Z</updated>
    
    <content type="html"><![CDATA[<h1>NGUI概述</h1><p>NGUI全称 下一代用户界面（Next-Gen UI）<br>它是第三方提供的Unity付费插件<br>专门用于制作Unity中游戏UI的第三方工具<br>相对于GUI它更适用于制作游戏UI功能<br>更方便使用，性能和效率更高</p><h1>Root组件</h1><h2 id="作用">作用</h2><ul><li>Root是用于 <strong>分辨率自适应</strong> 的 根对象</li><li>可以设置 基本分辨率,相当于设置 UI显示区域</li><li>并且管理所有UI控件的 分辨率自适应<br>可以简单理解 它管理一个 UI画布 所有的UI都是显示在这个画布上的<br>它会管理 UI画布 和 不同屏幕分辨率的 适应关系</li></ul><h2 id="Root参数相关">Root参数相关</h2><p>主要包含三种缩放模式</p><ol><li><p><strong>Flexible</strong> 适用于可以手动拖窗口改变分辨率的设备 比如pc端</p></li><li><p><strong>Constrained</strong> 适用于移动设备<br>因为移动设备都是全屏应用 不会频繁改变分辨率 只用适配不同分辨率的设备<br>一般使用：<strong>横屏勾选 高fit</strong> ; <strong>竖屏勾选 宽fit</strong><br>需要注意的是: <strong>背景图</strong> 一定要考虑 <strong>极限宽高比</strong>来出 <strong>最大宽高比</strong>  19.9:9</p></li><li><p><strong>Constrained On Mobiles</strong> 是上面两者的综合体 适用于多平台发布的游戏和应用</p></li></ol><img src="../../../img/Unity/NGUI_Root_缩放模式设置.bmp" width="70%" height="50%"><h1>Panel组件</h1><h2 id="作用-2">作用</h2><ul><li>管理一个UI面板的渲染顺序</li><li>管理一个UI面板上的所有子控件</li></ul><p><strong>tips</strong>:</p><ol><li>在Root下创建多个Panel对象(挂载着Panel组件的空对象), <strong>设置不同的depth</strong>, 一般一个Panel管理一个面板, 可以理解为 Panel的depth 控制 Panel与Panel之间的层级关系，<strong>类似于文件夹</strong></li><li>同一Panel下的对象通过<strong>自身的widget中的depth</strong>来控制在<strong>当前Panel下</strong>的层级，<strong>类似于文件夹中的文件</strong></li><li>没有Panel父对象 UI控件看不到</li></ol><h2 id="Panel参数相关">Panel参数相关</h2><img src="../../../img/Unity/NGUI_Panel参数.bmp" width="70%" height="50%"><h1>EventSystem组件</h1><p>也称为 <strong>UICamera</strong></p><h2 id="作用-3">作用</h2><p>主要作用是让摄像机渲染出来的物体 能接收到NGUI的<strong>输入事件</strong><br>大部分设置不需要我们去修改<br>有了它我们通过鼠标 触碰 键盘 控制器 操作UI 响应玩家的输入</p><p><strong>tips</strong>:</p><ol><li>EventSystem很重要，如果没有它，我们没有办法监听玩家输入</li><li>创建UI时的 2DUI 和3DUI 主要就是<strong>摄像机的模式</strong> (正交或透视) 不一样</li><li>EventSystem的2D和3D主要是 采用2D<strong>碰撞器</strong> 还是3D碰撞器, <strong>不能直接改变摄像机模式</strong></li></ol><h2 id="EventSystem参数相关">EventSystem参数相关</h2><img src="../../../img/Unity/NGUI_EventSystem参数1.bmp" width="70%" height="50%"><img src="../../../img/Unity/NGUI_EventSystem参数2.bmp" width="50%" height="50%"><h1>图集 Atlas</h1><h2 id="图集作用">图集作用</h2><p>NGUI中的最小图片控件<strong>Sprite</strong>要使用图集中的图片进行显示<br>图集 就是把很多单独的小图 合并为 一张大图 合并后的大图就是图集<br><strong>目的</strong>：提高渲染性能</p><h2 id="打开图集制作工具">打开图集制作工具</h2><ul><li>方法一：<strong>Project</strong>右键打开</li><li>方法二：上方工具栏<strong>NGUI——Open——Atlas Maker</strong></li></ul><h2 id="图集关键文件">图集关键文件</h2><ol><li>图集文件 (配置文件,包含小图在图集中的位置等信息)</li><li>图集材质球</li><li>图集图片</li></ol><h2 id="新建图集-及-创建修改删除图集元素">新建图集 及 创建修改删除图集元素</h2><ul><li>在图集工具<strong>Atlas Maker</strong>中操作</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;NGUI概述&lt;/h1&gt;
&lt;p&gt;NGUI全称 下一代用户界面（Next-Gen UI）&lt;br&gt;
它是第三方提供的Unity付费插件&lt;br&gt;
专门用于制作Unity中游戏UI的第三方工具&lt;br&gt;
相对于GUI它更适用于制作游戏UI功能&lt;br&gt;
更方便使用，性能和效率更高&lt;/p</summary>
      
    
    
    
    <category term="Unity" scheme="https://escapeey.github.io/categories/Unity/"/>
    
    
    <category term="C#" scheme="https://escapeey.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>形式语言与自动机</title>
    <link href="https://escapeey.github.io/post/b01f06ff.html"/>
    <id>https://escapeey.github.io/post/b01f06ff.html</id>
    <published>2023-12-28T11:22:09.000Z</published>
    <updated>2024-05-22T06:03:05.833Z</updated>
    
    <content type="html"><![CDATA[<h1>前言</h1><ul><li>形式语言理论：<font color="red">乔姆斯基发现文法</font>，用<strong>文法产生语言</strong>的每个句子。</li><li>自动机理论：<font color="red">克林建立了有穷状态自动机</font>,为识别语言的系统</li><li>文法与自动机是<strong>等价</strong>的</li><li>文法与自动机的运算对象：<strong>集合</strong></li></ul><img src="..\img\FL&FA\5方转换图.png" width="70%" height="70%" align="middle"><h1>文法</h1><h2 id="文法构造">文法构造</h2><ul><li><p>例1<br><img src="..\img\FL&FA\文法例1.png" width="40%" height="70%" align="middle"></p></li><li><p>例2<br><img src="..\img\FL&FA\文法例2.png" width="70%" height="70%" align="middle"></p></li><li><p>例3<br><img src="..\img\FL&FA\文法例3.png" width="70%" height="70%" align="middle"></p></li><li><p>例4<br><img src="..\img\FL&FA\文法例4.png" width="70%" height="70%" align="middle"><br><img src="..\img\FL&FA\文法例4_1.png" width="70%" height="70%" align="middle"></p></li><li><p>例5<br><img src="..\img\FL&FA\文法例5.png" width="70%" height="70%" align="middle"></p></li><li><p>例6<br><img src="..\img\FL&FA\文法例6_1.png" width="70%" height="70%" align="middle"><br><img src="..\img\FL&FA\文法例6_2.png" width="40%" height="70%" align="middle"></p></li></ul><h2 id="文法分类">文法分类</h2><ul><li><p>标准<br><img src="..\img\FL&FA\文法分类.png" width="70%" height="70%" align="middle"><br><img src="..\img\FL&FA\文法分类定义.png" width="70%" height="70%" align="middle"></p></li><li><p>例子<br><img src="..\img\FL&FA\文法分类例子.png" width="70%" height="70%" align="middle"></p></li></ul><h1>线性文法与FA的转换</h1><h2 id="右线性文法">右线性文法</h2><h3 id="FA-文法">FA -&gt; 文法</h3><img src="..\img\FL&FA\FA转右线性文法.png" width="70%" height="70%" align="middle"><h3 id="文法-FA">文法 -&gt; FA</h3><img src="..\img\FL&FA\右线性文法转FA.png" width="70%" height="70%" align="middle"><h2 id="左线性文法">左线性文法</h2><h3 id="FA-文法-2">FA -&gt; 文法</h3><ul><li><p>先预处理<br><img src="..\img\FL&FA\FA转左线性文法_预处理.png" width="70%" height="70%" align="middle"></p></li><li><p>规则：<br><img src="..\img\FL&FA\FA转左线性文法_规则.png" width="70%" height="70%" align="middle"></p></li><li><p>例子<br><img src="..\img\FL&FA\FA转左线性文法_例子.png" width="70%" height="70%" align="middle"></p></li></ul><h3 id="文法-FA-2">文法 -&gt; FA</h3><ul><li><p>规则<br><img src="..\img\FL&FA\左线性文法转FA_规则.png" width="70%" height="70%" align="middle"></p></li><li><p>例子<br><img src="..\img\FL&FA\左线性文法转FA_例子.png" width="70%" height="70%" align="middle"></p></li></ul><h1>DFA、NFA、ε-NFA转换</h1><h2 id="ε-NFA-NFA">ε-NFA -&gt; NFA</h2><h3 id="前置知识">前置知识</h3><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϵ</mi><mo>−</mo><mi>C</mi><mi>L</mi><mi>O</mi><mi>S</mi><mi>U</mi><mi>R</mi><mi>E</mi><mo stretchy="false">(</mo><msub><mi>q</mi><mn>0</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\epsilon-CLOSURE(q_0)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">ϵ</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord mathnormal">L</span><span class="mord mathnormal" style="margin-right:0.05764em;">OS</span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="mord mathnormal" style="margin-right:0.05764em;">RE</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> = { p | 从<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>q</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">q_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span></span></span></span>有一条标记为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">ϵ</span></span></span></span> 的路}</li><li>ε-NFA 的 状态转移函数<br><img src="..\img\FL&FA\epsilonNFA的状态转移函数.png" width="70%" height="70%" align="middle"></li></ul><h3 id="转换过程">转换过程</h3><ul><li><p>终止状态<br>F 为 ε-NFA 的<br>F2 为转化后NFA的<br><img src="..\img\FL&FA\epsilonNFA转NFA_终止状态.png" width="70%" height="70%" align="middle"></p></li><li><p>转化后NFA的 转移函数</p><ul><li>为 去除 <font color='red'>ε列</font> 的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>δ</mi><mo>^</mo></mover></mrow><annotation encoding="application/x-tex">\hat\delta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9579em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9579em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal" style="margin-right:0.03785em;">δ</span></span><span style="top:-3.2634em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.1944em;"><span class="mord">^</span></span></span></span></span></span></span></span></span></span></li></ul></li></ul><h3 id="例子">例子</h3><img src="..\img\FL&FA\epsilonNFA转NFA_例子0.png" width="70%" height="70%" align="middle"><img src="..\img\FL&FA\epsilonNFA转NFA_例子1.png" width="70%" height="70%" align="middle"><h2 id="NFA-DFA">NFA -&gt; DFA</h2><ul><li>带 NFA 中 终止状态 的 状态簇 为 新DFA 的终止状态</li><li>例子<br><img src="..\img\FL&FA\NFA转DFA_例子0.png" width="70%" height="70%" align="middle"><br><img src="..\img\FL&FA\NFA转DFA_例子1.png" width="70%" height="70%" align="middle"><br><img src="..\img\FL&FA\NFA转DFA_例子2.png" width="70%" height="70%" align="middle"></li></ul><h1>FA 与 RE 的转化</h1><h2 id="RE-ε-NFA">RE -&gt; ε-NFA</h2><ul><li><p>n = 0<br><img src="..\img\FL&FA\RE转NFA_0.png" width="70%" height="70%" align="middle"></p></li><li><p>n = k+1<br><img src="..\img\FL&FA\RE转NFA_1.png" width="60%" height="70%" align="middle"><br><img src="..\img\FL&FA\RE转NFA_2.png" width="60%" height="70%" align="middle"><br><img src="..\img\FL&FA\RE转NFA_3.png" width="60%" height="70%" align="middle"></p></li><li><p>例子<br><img src="..\img\FL&FA\RE转NFA_例子.png" width="60%" height="70%" align="middle"></p></li></ul><h2 id="DFA-RE">DFA -&gt; RE</h2><h3 id="例子-2">例子</h3><img src="..\img\FL&FA\DFA转RE_例子.png" width="60%" height="70%" align="middle"><ul><li><p>预处理：</p><ul><li>用标记为X和Y的状态将M“括起来”：<br>在状态转移图中增加标记为X和Y的状态, 从标记为X的状态到标记为q0的状态引一条标记为ε的弧；<br>从标记为q(q∈F)的状态到标记为Y的状态分别引一条标记为ε的弧。</li><li>去掉所有的不可达状态。<br><img src="..\img\FL&FA\DFA转RE_预处理.png" width="70%" height="70%" align="middle"></li></ul></li><li><p>去掉状态q3：<br><img src="..\img\FL&FA\DFA转RE_例子0.png" width="70%" height="70%" align="middle"></p></li><li><p>去掉状态q4<br><img src="..\img\FL&FA\DFA转RE_例子1.png" width="70%" height="70%" align="middle"></p></li><li><p>合并从标记为q2的状态到标记为Y的状态的两条并行弧。<br><img src="..\img\FL&FA\DFA转RE_例子2.png" width="70%" height="70%" align="middle"></p></li><li><p>去掉状态q0<br><img src="..\img\FL&FA\DFA转RE_例子3.png" width="70%" height="70%" align="middle"></p></li><li><p>并弧<br><img src="..\img\FL&FA\DFA转RE_例子4.png" width="70%" height="70%" align="middle"></p></li><li><p>去掉状态q1<br><img src="..\img\FL&FA\DFA转RE_例子5.png" width="70%" height="70%" align="middle"></p></li><li><p>去掉状态q2<br><img src="..\img\FL&FA\DFA转RE_例子6.png" width="70%" height="70%" align="middle"></p></li></ul><h3 id="注意事项">注意事项</h3><ul><li>不计算自身到自身的弧,如果状态q的入度为n,出度为m,则将状态q及其相关的弧去掉之后,需要添加n*m条新弧。</li></ul><h1>泵引理 与 封闭性</h1><h2 id="泵引理">泵引理</h2><h3 id="定理">定理</h3><img src="..\img\FL&FA\泵引理_定理.png" width="70%" height="70%" align="middle"><h3 id="应用">应用</h3><ul><li><p>例1<br><img src="..\img\FL&FA\泵引理_例1.png" width="70%" height="70%" align="middle"></p></li><li><p>例2<br><img src="..\img\FL&FA\泵引理_例2.png" width="70%" height="70%" align="middle"></p></li><li><p>例3<br><img src="..\img\FL&FA\泵引理_例3.png" width="70%" height="70%" align="middle"></p></li><li><p>例4<br><img src="..\img\FL&FA\泵引理_例4.png" width="70%" height="70%" align="middle"></p></li></ul><h2 id="封闭性">封闭性</h2><h3 id="定义">定义</h3><p><font color='red'>交、并、补、连接、闭包、反转、同态、逆同态 运算都具有封闭性</font></p><ul><li><p>补运算的封闭性<br>如果 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi></mrow><annotation encoding="application/x-tex">L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">L</span></span></span></span> 是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Σ</mi></mrow><annotation encoding="application/x-tex">\Sigma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">Σ</span></span></span></span> 上的RE, 那么 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>L</mi><mo stretchy="true">‾</mo></mover><mo>=</mo><msup><mi mathvariant="normal">Σ</mi><mo lspace="0em" rspace="0em">∗</mo></msup><mo>−</mo><mi>L</mi></mrow><annotation encoding="application/x-tex">\overline{L} = \Sigma^{*} - L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8833em;"></span><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8833em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">L</span></span></span><span style="top:-3.8033em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.772em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">Σ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6887em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">∗</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">L</span></span></span></span> 也是 正则的。</p></li><li><p>交运算的封闭性<br>如果 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi></mrow><annotation encoding="application/x-tex">L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">L</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span> 是 RE, 那么 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo>∩</mo><mi>M</mi></mrow><annotation encoding="application/x-tex">L\cap M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">L</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∩</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span> 也是 正则的。</p></li><li><p>同态 的定义<br><img src="..\img\FL&FA\同态的定义.png" width="70%" height="70%" align="middle"></p></li><li><p>逆同态 的定义<br><img src="..\img\FL&FA\逆同态的定义.png" width="70%" height="70%" align="middle"></p></li></ul><h3 id="例子-3">例子</h3><ul><li><p>例1<br><img src="..\img\FL&FA\封闭性_例1.png" width="70%" height="70%" align="middle"></p></li><li><p>例2<br><img src="..\img\FL&FA\封闭性_例2.png" width="70%" height="70%" align="middle"></p></li><li><p>例3<br><img src="..\img\FL&FA\封闭性_例3.png" width="70%" height="70%" align="middle"></p></li></ul><h1>Myhill-Nerode定理</h1><p>定理规定以下三个命题同时成立:</p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo>⊆</mo><msup><mi mathvariant="normal">Σ</mi><mo>∗</mo></msup></mrow><annotation encoding="application/x-tex">L \subseteq \Sigma^*</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.136em;"></span><span class="mord mathnormal">L</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⊆</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6887em;"></span><span class="mord"><span class="mord">Σ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6887em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span></span></span></span> 是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mi>L</mi></mrow><annotation encoding="application/x-tex">RL</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mord mathnormal">L</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi></mrow><annotation encoding="application/x-tex">L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">L</span></span></span></span> 是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi mathvariant="normal">Σ</mi><mo>∗</mo></msup></mrow><annotation encoding="application/x-tex">\Sigma^*</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6887em;"></span><span class="mord"><span class="mord">Σ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6887em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span></span></span></span>上的某一个具有 <font color='red'>有穷指数</font> 的<font color='red'> 右不变等价关系</font> 的 <font color='red'>并</font></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>R</mi><mi>L</mi></msub></mrow><annotation encoding="application/x-tex">R_L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">L</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>具有有穷指数</li></ul><h2 id="右不变等价关系">右不变等价关系</h2><p><strong>定义</strong>：设<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span>是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi mathvariant="normal">Σ</mi><mo lspace="0em" rspace="0em">∗</mo></msup></mrow><annotation encoding="application/x-tex">\Sigma^{*}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6887em;"></span><span class="mord"><span class="mord">Σ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6887em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">∗</span></span></span></span></span></span></span></span></span></span></span></span>上的等价关系，对于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∀</mi><mrow><mi>x</mi><mo separator="true">,</mo><mi>y</mi></mrow><mo>∈</mo><msup><mi mathvariant="normal">Σ</mi><mo lspace="0em" rspace="0em">∗</mo></msup></mrow><annotation encoding="application/x-tex">\forall{x,y} \in \Sigma^{*}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord">∀</span><span class="mord"><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6887em;"></span><span class="mord"><span class="mord">Σ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6887em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">∗</span></span></span></span></span></span></span></span></span></span></span></span>, 如果<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mi>R</mi><mi>y</mi></mrow><annotation encoding="application/x-tex">xRy</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">x</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span>成立，则<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mi>z</mi><mi>R</mi><mi>y</mi><mi>z</mi></mrow><annotation encoding="application/x-tex">xzRyz</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">x</span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mord mathnormal" style="margin-right:0.04398em;">yz</span></span></span></span>也成立，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>z</mi><mo>∈</mo><msup><mi mathvariant="normal">Σ</mi><mo lspace="0em" rspace="0em">∗</mo></msup></mrow><annotation encoding="application/x-tex">z\in\Sigma^{*}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6887em;"></span><span class="mord"><span class="mord">Σ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6887em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">∗</span></span></span></span></span></span></span></span></span></span></span></span>, 则<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span>被称为 右不变等价关系</p><ul><li>关系<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>R</mi><mi>m</mi></msub></mrow><annotation encoding="application/x-tex">R_m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>R</mi><mi>L</mi></msub></mrow><annotation encoding="application/x-tex">R_L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">L</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>是 右不变等价关系</li></ul><h3 id="关系RM">关系RM</h3><ul><li>设DFA M，M所确定的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi mathvariant="normal">Σ</mi><mo>∗</mo></msup></mrow><annotation encoding="application/x-tex">Σ^*</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6887em;"></span><span class="mord"><span class="mord">Σ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6887em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span></span></span></span>上的关系 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>R</mi><mi>M</mi></msub></mrow><annotation encoding="application/x-tex">R_M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">M</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 定义为：<br>对于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∀</mi><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo>∈</mo><mi mathvariant="normal">Σ</mi><mo>∗</mo></mrow><annotation encoding="application/x-tex">∀x,y∈Σ*</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord">∀</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">Σ</span><span class="mord">∗</span></span></span></span><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><msub><mi>R</mi><mi>M</mi></msub><mi>y</mi><mo>⇔</mo><mi>δ</mi><mo stretchy="false">(</mo><mi>q</mi><mn>0</mn><mo separator="true">,</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>δ</mi><mo stretchy="false">(</mo><mi>q</mi><mn>0</mn><mo separator="true">,</mo><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">x R_M y ⇔ δ(q0,x)=δ(q0,y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">x</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">M</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⇔</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03785em;">δ</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03785em;">δ</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span></li><li>也就是说： <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><msub><mi>R</mi><mi>M</mi></msub><mi>y</mi><mo>⇔</mo><mi mathvariant="normal">∃</mi><mi>q</mi><mo>∈</mo><mi>Q</mi><mtext>，</mtext><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo>∈</mo><mi>s</mi><mi>e</mi><mi>t</mi><mo stretchy="false">(</mo><mi>q</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">x R_M y ⇔ ∃q∈Q，x,y∈set(q)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">x</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">M</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⇔</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord">∃</span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">Q</span><span class="mord cjk_fallback">，</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">se</span><span class="mord mathnormal">t</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="mclose">)</span></span></span></span>。</li><li>或者说：<font color='red'>M从<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>q</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">q_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>开始读入x和y以后进入同一个状态。</font></li></ul></li></ul><h3 id="关系RL：">关系RL：</h3><ul><li>设<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo>⊆</mo><mi mathvariant="normal">Σ</mi><mo>∗</mo></mrow><annotation encoding="application/x-tex">L ⊆ Σ*</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.136em;"></span><span class="mord mathnormal">L</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⊆</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">Σ</span><span class="mord">∗</span></span></span></span>，L确定的Σ*上的关系 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>R</mi><mi>L</mi></msub></mrow><annotation encoding="application/x-tex">R_L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">L</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 定义为：<br>对于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∀</mi><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo>∈</mo><mi mathvariant="normal">Σ</mi><mo>∗</mo></mrow><annotation encoding="application/x-tex">∀x,y∈Σ*</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord">∀</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">Σ</span><span class="mord">∗</span></span></span></span><br><font color='red'><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><msub><mi>R</mi><mi>L</mi></msub><mi>y</mi><mo>⇔</mo><mo stretchy="false">(</mo><mi mathvariant="normal">∀</mi><mi>z</mi><mo>∈</mo><msup><mi mathvariant="normal">Σ</mi><mo>∗</mo></msup><mtext>，</mtext><mi>x</mi><mi>z</mi><mo>∈</mo><mi>L</mi><mo>⇔</mo><mi>y</mi><mi>z</mi><mo>∈</mo><mi>L</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">x R_L y ⇔ (∀z∈Σ^*，xz∈L ⇔ yz∈L)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">x</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">L</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⇔</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">∀</span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0391em;"></span><span class="mord"><span class="mord">Σ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6887em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span><span class="mord cjk_fallback">，</span><span class="mord mathnormal">x</span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">L</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⇔</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7335em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.04398em;">yz</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class="mclose">)</span></span></span></span></font></li></ul><h3 id="二者关系">二者关系</h3><ul><li>如果<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><msub><mi>R</mi><mi>M</mi></msub><mi>y</mi></mrow><annotation encoding="application/x-tex">x R_M y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">x</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">M</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span>，则 <font color='red'>一定有</font> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><msub><mi>R</mi><mrow><mi>L</mi><mo stretchy="false">(</mo><mi>M</mi><mo stretchy="false">)</mo></mrow></msub><mi>y</mi></mrow><annotation encoding="application/x-tex">x R_{L(M)} y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0385em;vertical-align:-0.3552em;"></span><span class="mord mathnormal">x</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.5198em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">L</span><span class="mopen mtight">(</span><span class="mord mathnormal mtight" style="margin-right:0.10903em;">M</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3552em;"><span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span></li><li>如果<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><msub><mi>R</mi><mrow><mi>L</mi><mo stretchy="false">(</mo><mi>M</mi><mo stretchy="false">)</mo></mrow></msub><mi>y</mi></mrow><annotation encoding="application/x-tex">x R_{L(M)} y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0385em;vertical-align:-0.3552em;"></span><span class="mord mathnormal">x</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.5198em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">L</span><span class="mopen mtight">(</span><span class="mord mathnormal mtight" style="margin-right:0.10903em;">M</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3552em;"><span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span>，则 <font color='red'>不一定有</font> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><msub><mi>R</mi><mi>M</mi></msub><mi>y</mi></mrow><annotation encoding="application/x-tex">x R_M y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">x</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">M</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span></li><li><font color='red'><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><msup><mi mathvariant="normal">Σ</mi><mo lspace="0em" rspace="0em">∗</mo></msup><mi mathvariant="normal">/</mi><msub><mi>R</mi><mrow><mi>L</mi><mo stretchy="false">(</mo><mi>M</mi><mo stretchy="false">)</mo></mrow></msub><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">|\Sigma^{*}/R_{L(M)}|</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1052em;vertical-align:-0.3552em;"></span><span class="mord">∣</span><span class="mord"><span class="mord">Σ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6887em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">∗</span></span></span></span></span></span></span></span></span><span class="mord">/</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.5198em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">L</span><span class="mopen mtight">(</span><span class="mord mathnormal mtight" style="margin-right:0.10903em;">M</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3552em;"><span></span></span></span></span></span></span><span class="mord">∣</span></span></span></span> ≤ <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><msup><mi mathvariant="normal">Σ</mi><mo lspace="0em" rspace="0em">∗</mo></msup><mi mathvariant="normal">/</mi><msub><mi>R</mi><mi>M</mi></msub><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">|\Sigma^{*}/R_M|</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord"><span class="mord">Σ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6887em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">∗</span></span></span></span></span></span></span></span></span><span class="mord">/</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">M</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">∣</span></span></span></span> ≤ <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Q</mi></mrow><annotation encoding="application/x-tex">Q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">Q</span></span></span></span></font>, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>R</mi><mi>M</mi></msub></mrow><annotation encoding="application/x-tex">R_M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">M</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>R</mi><mrow><mi>L</mi><mo stretchy="false">(</mo><mi>M</mi><mo stretchy="false">)</mo></mrow></msub></mrow><annotation encoding="application/x-tex">R_{L(M)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0385em;vertical-align:-0.3552em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.5198em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">L</span><span class="mopen mtight">(</span><span class="mord mathnormal mtight" style="margin-right:0.10903em;">M</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3552em;"><span></span></span></span></span></span></span></span></span></span> 的 <font color='red'>加细</font></li></ul><h3 id="例子-4">例子</h3><img src="..\img\FL&FA\RM和RL例子.png" width="70%" height="70%" align="middle"><h2 id="关系的指数">关系的指数</h2><h3 id="R-的指数"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span> 的指数</h3><p>设<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span>是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi mathvariant="normal">Σ</mi><mo lspace="0em" rspace="0em">∗</mo></msup></mrow><annotation encoding="application/x-tex">\Sigma^{*}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6887em;"></span><span class="mord"><span class="mord">Σ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6887em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">∗</span></span></span></span></span></span></span></span></span></span></span></span>上的等价关系,则称 <font color='red'><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><msup><mi mathvariant="normal">Σ</mi><mo lspace="0em" rspace="0em">∗</mo></msup><mi mathvariant="normal">/</mi><mi>R</mi><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">|\Sigma^{*} / R|</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord"><span class="mord">Σ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6887em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">∗</span></span></span></span></span></span></span></span></span><span class="mord">/</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mord">∣</span></span></span></span></font> 是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span> 关于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi mathvariant="normal">Σ</mi><mo lspace="0em" rspace="0em">∗</mo></msup></mrow><annotation encoding="application/x-tex">\Sigma^{*}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6887em;"></span><span class="mord"><span class="mord">Σ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6887em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">∗</span></span></span></span></span></span></span></span></span></span></span></span>的指数。</p><h3 id="R-的一个等价类"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span> 的一个等价类</h3><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi mathvariant="normal">Σ</mi><mo lspace="0em" rspace="0em">∗</mo></msup></mrow><annotation encoding="application/x-tex">\Sigma^{*}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6887em;"></span><span class="mord"><span class="mord">Σ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6887em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">∗</span></span></span></span></span></span></span></span></span></span></span></span>的关于R的一个等价类,也就是<font color='red'><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi mathvariant="normal">Σ</mi><mo lspace="0em" rspace="0em">∗</mo></msup><mi mathvariant="normal">/</mi><mi>R</mi></mrow><annotation encoding="application/x-tex">\Sigma^{*}/R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord">Σ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6887em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">∗</span></span></span></span></span></span></span></span></span><span class="mord">/</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span></font>的任意一个<strong>元素</strong></p><h1>极小化</h1><h2 id="定义-2">定义</h2><p>最小状态DFA的含义:</p><ul><li><p>没有多余状态(死状态)</p><ul><li>如何消除多余状态？删除即可。<br><img src="..\img\FL&FA\极小化_定义.png" width="70%" height="70%" align="middle"></li></ul></li><li><p>没有两个状态是互相等价（不可区别）</p><ul><li>兼容性（一致性）条件——同是终态或同是非终态</li><li>传播性（蔓延性）条件——对于所有输入符号，状态s和状态t必须转换到等价的状态里。</li></ul></li></ul><h2 id="例子：">例子：</h2><p><strong>最小化下图所示的DFA</strong><br><img src="..\img\FL&FA\极小化_例1.png" width="60%" height="70%" align="middle"></p><ol><li>分成终态和非终态：</li></ol><ul><li>将Ｍ的状态分为两个子集一个由终态 k1=｛Ｃ，Ｄ，Ｅ，Ｆ｝组成，一个由非终态 k2=｛Ｓ，Ａ，Ｂ｝组成。</li></ul><ol start="2"><li><p>考察｛Ｓ，Ａ，Ｂ｝是否可分。<br><img src="..\img\FL&FA\极小化_例2.png" width="20%" height="10%" align="middle"><br>因为Ａ经过a到达C属于k1.而S经过a到达A属于k2。B经过a到达A属于k2，所以K2继续划分为{S，B}，{A}。</p></li><li><p>考察｛Ｓ，Ｂ｝是否可再分：<br>B经过b到达D属于k1。S经过b到达B属于k2，所以S，B可以划分。划分为{S},{B}</p></li><li><p>考察｛Ｃ，Ｄ，Ｅ，Ｆ｝是否可再分：<br>因为Ｃ，Ｄ，Ｅ，Ｆ经过 a和b 到达的状态都属于｛Ｃ，Ｄ，Ｅ，Ｆ｝=k1 所以相同，所以不可再分。</p></li><li><p>｛Ｃ，Ｄ，Ｅ，Ｆ｝以｛Ｄ｝来代替则，因为CDEF相同，你也可以用C来代替。无所谓的最小化的DFA如图：<br><img src="..\img\FL&FA\极小化_例3.png" width="50%" height="70%" align="middle" alt="极小化_例3"></p></li></ol><h1>RE运算</h1><h2 id="定义-3">定义</h2><p>正则表达式(regular expression,RE)</p><ol><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Φ</mi></mrow><annotation encoding="application/x-tex">\Phi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">Φ</span></span></span></span> 是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Σ</mi></mrow><annotation encoding="application/x-tex">\Sigma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">Σ</span></span></span></span>上的RE,它表示语言 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Φ</mi></mrow><annotation encoding="application/x-tex">\Phi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">Φ</span></span></span></span>；</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">ϵ</span></span></span></span> 是∑上的RE,它表示语言<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">{</mo><mi>ϵ</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\{\epsilon\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord mathnormal">ϵ</span><span class="mclose">}</span></span></span></span>；</li><li>对于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∀</mi><mi>a</mi><mo>∈</mo><mi mathvariant="normal">Σ</mi></mrow><annotation encoding="application/x-tex">\forall{a}\in \Sigma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7335em;vertical-align:-0.0391em;"></span><span class="mord">∀</span><span class="mord"><span class="mord mathnormal">a</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">Σ</span></span></span></span>, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">{a}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord"><span class="mord mathnormal">a</span></span></span></span></span>是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Σ</mi></mrow><annotation encoding="application/x-tex">\Sigma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">Σ</span></span></span></span>上的RE,它表示语言<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">{</mo><mi>a</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\{a\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord mathnormal">a</span><span class="mclose">}</span></span></span></span>；</li><li>如果r和s分别是∑上表示语言R和S的RE,则：<ul><li>r与s的“和” (r+s)是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Σ</mi></mrow><annotation encoding="application/x-tex">\Sigma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">Σ</span></span></span></span>上的RE,(r+s)表达的语言为R∪S；</li><li>r与s的“乘积” (rs)是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Σ</mi></mrow><annotation encoding="application/x-tex">\Sigma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">Σ</span></span></span></span>上的RE,(rs)表达的语言为RS；</li><li>r的克林闭包(r*)是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Σ</mi></mrow><annotation encoding="application/x-tex">\Sigma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">Σ</span></span></span></span>上的RE,(r*)表达的语言为R*。</li></ul></li><li>只有满足1、2、3、4的才是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Σ</mi></mrow><annotation encoding="application/x-tex">\Sigma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">Σ</span></span></span></span>上的RE。</li></ol><h2 id="表示">表示</h2><ul><li>0,表示语言{0}</li><li>1,表示语言{1}</li><li>(0+1),表示语言{0,1}</li><li>(01),表示语言{01}</li><li>((0+1)*),表示语言{0,1}*</li></ul><h2 id="运算">运算</h2><ul><li>结合律：<br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>r</mi><mi>s</mi><mo stretchy="false">)</mo><mi>t</mi><mo>=</mo><mi>r</mi><mo stretchy="false">(</mo><mi>s</mi><mi>t</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(rs)t=r(st)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">rs</span><span class="mclose">)</span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mopen">(</span><span class="mord mathnormal">s</span><span class="mord mathnormal">t</span><span class="mclose">)</span></span></span></span><br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>r</mi><mo>+</mo><mi>s</mi><mo stretchy="false">)</mo><mo>+</mo><mi>t</mi><mo>=</mo><mi>r</mi><mo>+</mo><mo stretchy="false">(</mo><mi>s</mi><mo>+</mo><mi>t</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(r+s)+t=r+(s+t)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">s</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6151em;"></span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">t</span><span class="mclose">)</span></span></span></span></li><li>分配律：<br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mo stretchy="false">(</mo><mi>s</mi><mo>+</mo><mi>t</mi><mo stretchy="false">)</mo><mo>=</mo><mi>r</mi><mi>s</mi><mo>+</mo><mi>r</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">r(s+t)=rs+rt</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mopen">(</span><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">t</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">rs</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6151em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">t</span></span></span></span><br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>s</mi><mo>+</mo><mi>t</mi><mo stretchy="false">)</mo><mi>r</mi><mo>=</mo><mi>s</mi><mi>r</mi><mo>+</mo><mi>t</mi><mi>r</mi></mrow><annotation encoding="application/x-tex">(s+t)r=sr+tr</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">t</span><span class="mclose">)</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">sr</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6151em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span></span></span></span></li><li>交换律：<br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mo>+</mo><mi>s</mi><mo>=</mo><mi>s</mi><mo>+</mo><mi>r</mi></mrow><annotation encoding="application/x-tex">r+s=s+r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span></span></span></span></li><li>幂等律：<br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mo>+</mo><mi>r</mi><mo>=</mo><mi>r</mi></mrow><annotation encoding="application/x-tex">r+r=r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span></span></span></span></li><li>加法运算零元素：<br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mo>+</mo><mi mathvariant="normal">Φ</mi><mo>=</mo><mi>r</mi></mrow><annotation encoding="application/x-tex">r+Φ=r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">Φ</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span></span></span></span></li><li>乘法运算单位元：<br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mi>ε</mi><mo>=</mo><mi>ε</mi><mi>r</mi><mo>=</mo><mi>r</mi></mrow><annotation encoding="application/x-tex">rε=εr=r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">ε</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">ε</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span></span></span></span></li><li>乘法运算零元素：<br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mi mathvariant="normal">Φ</mi><mo>=</mo><mi mathvariant="normal">Φ</mi><mi>r</mi><mo>=</mo><mi mathvariant="normal">Φ</mi></mrow><annotation encoding="application/x-tex">rΦ=Φr=Φ</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord">Φ</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">Φ</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">Φ</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo stretchy="false">(</mo><mi mathvariant="normal">Φ</mi><mo stretchy="false">)</mo><mo>=</mo><mi mathvariant="normal">Φ</mi></mrow><annotation encoding="application/x-tex">L(Φ)=Φ</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class="mopen">(</span><span class="mord">Φ</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">Φ</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo stretchy="false">(</mo><mi>ε</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">{</mo><mi>ε</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">L(ε)=\{ε\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class="mopen">(</span><span class="mord mathnormal">ε</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord mathnormal">ε</span><span class="mclose">}</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo stretchy="false">(</mo><mi>a</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">{</mo><mi>a</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">L(a)=\{a\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord mathnormal">a</span><span class="mclose">}</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo stretchy="false">(</mo><mi>r</mi><mi>s</mi><mo stretchy="false">)</mo><mo>=</mo><mi>L</mi><mo stretchy="false">(</mo><mi>r</mi><mo stretchy="false">)</mo><mi>L</mi><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">L(rs)=L(r)L(s)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class="mopen">(</span><span class="mord mathnormal">rs</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mclose">)</span><span class="mord mathnormal">L</span><span class="mopen">(</span><span class="mord mathnormal">s</span><span class="mclose">)</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo stretchy="false">(</mo><mi>r</mi><mo>+</mo><mi>s</mi><mo stretchy="false">)</mo><mo>=</mo><mi>L</mi><mo stretchy="false">(</mo><mi>r</mi><mo stretchy="false">)</mo><mo>∪</mo><mi>L</mi><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">L(r+s)=L(r)∪L(s)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">s</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∪</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class="mopen">(</span><span class="mord mathnormal">s</span><span class="mclose">)</span></span></span></span></li><li>$L(r*)=(L®)^* $</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo stretchy="false">(</mo><msup><mi mathvariant="normal">Φ</mi><mo>∗</mo></msup><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">{</mo><mi>ε</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">L(Φ^*)=\{ε\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class="mopen">(</span><span class="mord"><span class="mord">Φ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6887em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord mathnormal">ε</span><span class="mclose">}</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo stretchy="false">(</mo><mo stretchy="false">(</mo><mi>r</mi><mo>+</mo><mi>ε</mi><msup><mo stretchy="false">)</mo><mo>∗</mo></msup><mo stretchy="false">)</mo><mo>=</mo><mi>L</mi><mo stretchy="false">(</mo><msup><mi>r</mi><mo>∗</mo></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">L((r+ε)^*)=L(r^*)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class="mopen">((</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">ε</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6887em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6887em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo stretchy="false">(</mo><mo stretchy="false">(</mo><msup><mi>r</mi><mo>∗</mo></msup><msup><mo stretchy="false">)</mo><mo>∗</mo></msup><mo stretchy="false">)</mo><mo>=</mo><mi>L</mi><mo stretchy="false">(</mo><msup><mi>r</mi><mo>∗</mo></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">L((r^*)^*)=L(r^*)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class="mopen">((</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6887em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6887em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6887em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo stretchy="false">(</mo><mo stretchy="false">(</mo><msup><mi>r</mi><mo>∗</mo></msup><msup><mi>s</mi><mo>∗</mo></msup><msup><mo stretchy="false">)</mo><mo>∗</mo></msup><mo stretchy="false">)</mo><mo>=</mo><mi>L</mi><mo stretchy="false">(</mo><mo stretchy="false">(</mo><mi>r</mi><mo>+</mo><mi>s</mi><msup><mo stretchy="false">)</mo><mo>∗</mo></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">L((r^*s^*)^*)=L((r+s)^*)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class="mopen">((</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6887em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6887em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6887em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class="mopen">((</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">s</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6887em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></li><li>如果<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo stretchy="false">(</mo><mi>r</mi><mo stretchy="false">)</mo><mo>⊆</mo><mi>L</mi><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">L(r) \subseteq L(s)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⊆</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class="mopen">(</span><span class="mord mathnormal">s</span><span class="mclose">)</span></span></span></span>,则<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mo>+</mo><mi>s</mi><mo>=</mo><mi>s</mi></mrow><annotation encoding="application/x-tex">r+s=s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">s</span></span></span></span></li><li>$L(rn)=(L®)^n $</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>r</mi><mi>n</mi></msup><msup><mi>r</mi><mi>m</mi></msup><mo>=</mo><msup><mi>r</mi><mrow><mi>n</mi><mo>+</mo><mi>m</mi></mrow></msup></mrow><annotation encoding="application/x-tex">r^n r^m=r^{n+m}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6644em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7713em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7713em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">+</span><span class="mord mathnormal mtight">m</span></span></span></span></span></span></span></span></span></span></span></span><br>一般地, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mo>+</mo><mi>ε</mi><mo mathvariant="normal">≠</mo><mi>r</mi><mo separator="true">,</mo><mo stretchy="false">(</mo><mi>r</mi><mi>s</mi><msup><mo stretchy="false">)</mo><mi>n</mi></msup><mo mathvariant="normal">≠</mo><msup><mi>r</mi><mi>n</mi></msup><msup><mi>s</mi><mi>n</mi></msup><mo separator="true">,</mo><mi>r</mi><mi>s</mi><mo mathvariant="normal">≠</mo><mi>s</mi><mi>r</mi></mrow><annotation encoding="application/x-tex">r+ε≠r,(rs)^n ≠r^ns^n,rs≠sr</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">ε</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel"><span class="mrel"><span class="mord vbox"><span class="thinbox"><span class="rlap"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="inner"><span class="mord"><span class="mrel"></span></span></span><span class="fix"></span></span></span></span></span><span class="mrel">=</span></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mopen">(</span><span class="mord mathnormal">rs</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel"><span class="mrel"><span class="mord vbox"><span class="thinbox"><span class="rlap"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="inner"><span class="mord"><span class="mrel"></span></span></span><span class="fix"></span></span></span></span></span><span class="mrel">=</span></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">rs</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel"><span class="mrel"><span class="mord vbox"><span class="thinbox"><span class="rlap"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="inner"><span class="mord"><span class="mrel"></span></span></span><span class="fix"></span></span></span></span></span><span class="mrel">=</span></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">sr</span></span></span></span></li><li>幂<br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>r</mi><mn>0</mn></msup><mo>=</mo><mi>ε</mi></mrow><annotation encoding="application/x-tex">r^0=ε</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">ε</span></span></span></span><br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>r</mi><mi>n</mi></msup><mo>=</mo><msup><mi>r</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msup><mi>r</mi></mrow><annotation encoding="application/x-tex">r^n=r^{n-1}r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6644em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span></span></span></span></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;前言&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;形式语言理论：&lt;font color=&quot;red&quot;&gt;乔姆斯基发现文法&lt;/font&gt;，用&lt;strong&gt;文法产生语言&lt;/strong&gt;的每个句子。&lt;/li&gt;
&lt;li&gt;自动机理论：&lt;font color=&quot;red&quot;&gt;克林建立了有穷状态自动机&lt;/</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Unity-物理系统之刚体加力</title>
    <link href="https://escapeey.github.io/post/3912f0e7.html"/>
    <id>https://escapeey.github.io/post/3912f0e7.html</id>
    <published>2023-12-27T21:39:19.000Z</published>
    <updated>2024-05-22T06:03:05.833Z</updated>
    
    <content type="html"><![CDATA[<h2 id="刚体自带添加力的方法">刚体自带添加力的方法</h2><p>给刚体加力的目标是 让其有一个<strong>速度</strong> 朝向<strong>某一个方向移动</strong></p><h3 id="获取刚体组件">获取刚体组件</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Rigidbody rigidBody = <span class="keyword">this</span>.GetComponent&lt;Rigidbody&gt;();</span><br></pre></td></tr></table></figure><h3 id="添加力">添加力</h3><p>相对世界坐标 <font color="green">rigidBody.AddForce()</font></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rigidBody.AddForce(Vector3.forward * <span class="number">10</span>);</span><br></pre></td></tr></table></figure><p>相对本地坐标 <font color="green">rigidBody.AddRelativeForce()</font></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rigidBody.AddRelativeForce(Vector3.forward * <span class="number">10</span>);</span><br></pre></td></tr></table></figure><h3 id="添加扭矩力">添加扭矩力</h3><p>相对世界坐标 <font color="green">rigidBody.AddTorque()</font></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rigidBody.AddTorque(Vector3.up * <span class="number">10</span>);</span><br></pre></td></tr></table></figure><p>相对本地坐标 <font color="green">rigidBody.AddRelativeTorque()</font></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rigidBody.AddRelativeTorque(Vector3.up * <span class="number">10</span>);</span><br></pre></td></tr></table></figure><h3 id="直接改变速度">直接改变速度</h3><p><font color="green">rigidBody.velocity</font></p><p>这个速度方向 是相对于 世界坐标系的</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rigidBody.velocity = Vector3.forward * <span class="number">5</span>;</span><br></pre></td></tr></table></figure><h3 id="模拟爆炸效果">模拟爆炸效果</h3><p><font color="green">rigidBody.AddExplosionForce()</font></p><ul><li>模拟爆炸的力 一定是 <strong>所有希望产生爆炸效果影响的对象都需要得到他们的刚体</strong> 来执行这个方法 才能都有效果</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rigidBody.AddExplosionForce(<span class="number">100</span>, Vector3.zero, <span class="number">10</span>);</span><br></pre></td></tr></table></figure><h2 id="力的几种模式">力的几种模式</h2><ul><li>第二个参数 力的模式 主要的作用 就是 计算方式不同</li><li>由于4中计算方式的不同 最终的移动速度就会不同</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rigidBody.AddForce(Vector3.forward * <span class="number">10</span>, ForceMode.Acceleration);</span><br></pre></td></tr></table></figure><h3 id="Acceleration">Acceleration</h3><ul><li>给物体增加一个持续的加速度，忽略其质量</li><li>v = Ft/m</li><li>F:(0,0,10)</li><li>t:0.02s</li><li>m:默认为1</li><li>v = 10*0.02/ 1 = 0.2m/s</li><li>每物理帧移动0.2m/s*0.02 = 0.004m</li></ul><h3 id="Force">Force</h3><ul><li>给物体添加一个持续的力，与物体的质量有关</li><li>v = Ft/m</li><li>F:(0,0,10)</li><li>t:0.02s</li><li>m:2kg</li><li>v = 10*0.02/ 2 = 0.1m/s</li><li>每物理帧移动0.1m/s*0.02 = 0.002m</li></ul><h3 id="Impulse">Impulse</h3><ul><li>给物体添加一个瞬间的力，与物体的质量有关,忽略时间 默认为1</li><li>v = Ft/m</li><li>F:(0,0,10)</li><li>t:默认为1</li><li>m:2kg</li><li>v = 10*1/ 2 = 5m/s</li><li>每物理帧移动5m/s*0.02 = 0.1m</li></ul><h3 id="VelocityChange">VelocityChange</h3><ul><li>给物体添加一个瞬时速度，忽略质量，忽略时间</li><li>v = Ft/m</li><li>F:(0,0,10)</li><li>t:默认为1</li><li>m:默认为1</li><li>v = 10*1/ 1 = 10m/s</li><li>每物理帧移动10m/s*0.02 = 0.2m</li></ul><h2 id="立场脚本">立场脚本</h2><figure class="highlight plaintext"><figcaption><span>Force```组件</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">添加恒定力</span><br><span class="line"></span><br><span class="line">## 补充 刚体的休眠</span><br><span class="line">Unity为了**节约性能**，会对一些最近没改变的刚体进行休眠，可能会影响后续操作</span><br><span class="line">获取刚体是否处于休眠状态</span><br><span class="line">```C#</span><br><span class="line">if (rigidBody.IsSleeping())</span><br><span class="line">&#123;</span><br><span class="line">    //就唤醒它</span><br><span class="line">    rigidBody.WakeUp();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;刚体自带添加力的方法&quot;&gt;刚体自带添加力的方法&lt;/h2&gt;
&lt;p&gt;给刚体加力的目标是 让其有一个&lt;strong&gt;速度&lt;/strong&gt; 朝向&lt;strong&gt;某一个方向移动&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;获取刚体组件&quot;&gt;获取刚体组件&lt;/h3&gt;
&lt;figure</summary>
      
    
    
    
    <category term="Unity" scheme="https://escapeey.github.io/categories/Unity/"/>
    
    
    <category term="C#" scheme="https://escapeey.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Unity-物理系统之射线检测</title>
    <link href="https://escapeey.github.io/post/4d19935.html"/>
    <id>https://escapeey.github.io/post/4d19935.html</id>
    <published>2023-12-26T16:34:42.000Z</published>
    <updated>2024-05-22T06:03:05.833Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是射线检测">什么是射线检测</h2><p>解决以下问题：</p><ul><li>鼠标选择场景上一物体</li><li>FPS射击游戏（无弹道-不产生实际的子弹对象进行移动）</li><li>等需要判断一条线和物体的碰撞情况<br>它可以在<strong>指定点</strong>发射一个<strong>指定方向</strong>的射线<br>判断该射线与哪些<strong>碰撞器</strong>相交，得到对应对象</li></ul><h2 id="射线对象">射线对象</h2><p>单独的射线对于我们来说没有实际的意义,我们需要用它<strong>结合物理系统</strong>进行<strong>射线碰撞判断</strong></p><h3 id="3D世界中的射线">3D世界中的射线</h3><ul><li>参数一：起点</li><li>参数二：方向</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ray r = <span class="keyword">new</span> Ray(Vector3.right, Vector3.forward);</span><br></pre></td></tr></table></figure><h3 id="摄像机发射出的射线">摄像机发射出的射线</h3><p><strong>屏幕位置</strong> 为起点<br><strong>摄像机视口方向</strong> 为方向</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ray r2 = Camera.main.ScreenPointToRay(Input.mousePosition);</span><br></pre></td></tr></table></figure><h2 id="碰撞检测-API">碰撞检测 API</h2><p>射线检测也是<strong>瞬时</strong>的<br>执行代码时进行<strong>一次射线检测</strong></p><h3 id="最原始的射线检测">最原始的射线检测</h3><p>准备一条射线</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ray r = <span class="keyword">new</span> Ray(Vector3.zero, Vector3.forward);</span><br></pre></td></tr></table></figure><p><font color='green'>Physics.Raycast()</font></p><ul><li>参数一：射线</li><li>参数二: 检测的最大距离 超出这个距离不检测</li><li>参数三：检测指定层级（不填检测所有层）</li><li>参数四：是否忽略触发器 <code>UseGlobal</code>-使用全局设置 <code>Collide</code>-检测触发器<br><code>Ignore</code>-忽略触发器  不填使用<code>UseGlobal</code></li><li>返回值：bool 当碰撞到对象时 返回 true 没有 返回false</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (Physics.Raycast(r, <span class="number">1000</span>, <span class="number">1</span> &lt;&lt; LayerMask.NameToLayer(<span class="string">&quot;Monster&quot;</span>), </span><br><span class="line">    QueryTriggerInteraction.UseGlobal))</span><br><span class="line">&#123;</span><br><span class="line">    print(<span class="string">&quot;碰撞到了对象&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有一种重载 不用传入 射线 直接传入起点 和 方向 也可以用于判断</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (Physics.Raycast(Vector3.zero, Vector3.forward, <span class="number">1000</span>, </span><br><span class="line">    <span class="number">1</span> &lt;&lt; LayerMask.NameToLayer(<span class="string">&quot;Monster&quot;</span>),QueryTriggerInteraction.UseGlobal))</span><br><span class="line">&#123;</span><br><span class="line">    print(<span class="string">&quot;碰撞到了对象&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="获取相交的单个物体信息">获取相交的单个物体信息</h3><p>物体信息类<br>通过<font color='green'>RaycastHit</font>类 我们得到得到 <strong>碰撞到的对象信息</strong><br>还可以得到一些 碰撞的点 距离 法线等等的信息</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RaycastHit hitInfo;</span><br></pre></td></tr></table></figure><ul><li>参数一：射线</li><li>参数二：<code>RaycastHit</code>是结构体 是<strong>值类型</strong> Unity会通过<strong>out</strong><br>在函数内部处理后 得到碰撞数据后返回到该参数中</li><li>参数三：距离</li><li>参数四：检测指定层级</li><li>参数五：是否忽略触发器</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>( Physics.Raycast(r, <span class="keyword">out</span> hitInfo, <span class="number">1000</span>, <span class="number">1</span>&lt;&lt;LayerMask.NameToLayer(<span class="string">&quot;Monster&quot;</span>), </span><br><span class="line">    QueryTriggerInteraction.UseGlobal) )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//碰撞器信息</span></span><br><span class="line">    print(<span class="string">&quot;碰撞到物体的名字&quot;</span> + hitInfo.collider.gameObject.name);</span><br><span class="line">    <span class="comment">//碰撞到的点</span></span><br><span class="line">    print(hitInfo.point);</span><br><span class="line">    <span class="comment">//法线信息</span></span><br><span class="line">    print(hitInfo.normal);</span><br><span class="line">    <span class="comment">//得到碰撞到对象的位置</span></span><br><span class="line">    print(hitInfo.transform.position);</span><br><span class="line">    <span class="comment">//得到碰撞到对象 离自己的距离</span></span><br><span class="line">    print(hitInfo.distance);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同理 还有一种重载 不用传入 射线 直接传入起点 和 方向 也可以用于判断</p><h3 id="获取相交的多个物体">获取相交的多个物体</h3><p><font color='green'>Physics.RaycastAll()</font></p><p>可以得到<strong>碰撞到的多个对象</strong>，如果没有 就是容量为0的数组</p><ul><li>参数一：射线</li><li>参数二：距离</li><li>参数三：检测指定层级</li><li>参数四：是否忽略触发器</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">RaycastHit[] hits = Physics.RaycastAll(r, <span class="number">1000</span>, <span class="number">1</span> &lt;&lt; LayerMask.NameToLayer(<span class="string">&quot;Monster&quot;</span>),</span><br><span class="line">                                       QueryTriggerInteraction.UseGlobal);</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; hits.Length; i++)</span><br><span class="line">&#123;</span><br><span class="line">    print(<span class="string">&quot;碰到的所有物体 名字分别是&quot;</span> + hits[i].collider.gameObject.name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有一种NonAlloc型的函数 返回的碰撞的数量 通过out得到数据<br><font color='green'>Physics.RaycastNonAlloc()</font></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RaycastHit[] hits;</span><br><span class="line"><span class="keyword">if</span>(Physics.RaycastNonAlloc(r, hits, <span class="number">1000</span>, <span class="number">1</span> &lt;&lt; LayerMask.NameToLayer(<span class="string">&quot;Monster&quot;</span>), </span><br><span class="line">                           QueryTriggerInteraction.UseGlobal) &gt; <span class="number">0</span> )&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用时注意的问题">使用时注意的问题</h3><p><strong>注意</strong>：<br><strong>距离</strong>、<strong>层级</strong>两个参数 都是<strong>int类型</strong><br>当我们传入参数时 一定要明确传入的参数代表的是距离还是层级</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;什么是射线检测&quot;&gt;什么是射线检测&lt;/h2&gt;
&lt;p&gt;解决以下问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;鼠标选择场景上一物体&lt;/li&gt;
&lt;li&gt;FPS射击游戏（无弹道-不产生实际的子弹对象进行移动）&lt;/li&gt;
&lt;li&gt;等需要判断一条线和物体的碰撞情况&lt;br&gt;
它可以在&lt;str</summary>
      
    
    
    
    <category term="Unity" scheme="https://escapeey.github.io/categories/Unity/"/>
    
    
    <category term="C#" scheme="https://escapeey.github.io/tags/C/"/>
    
  </entry>
  
</feed>
