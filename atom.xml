<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Escapeey`Blog</title>
  
  <subtitle>岂能尽如人意，但求无愧我心。</subtitle>
  <link href="https://escapeey.github.io/atom.xml" rel="self"/>
  
  <link href="https://escapeey.github.io/"/>
  <updated>2024-04-03T04:37:57.880Z</updated>
  <id>https://escapeey.github.io/</id>
  
  <author>
    <name>Escapeey</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>DFS和BFS</title>
    <link href="https://escapeey.github.io/post/f5273844.html"/>
    <id>https://escapeey.github.io/post/f5273844.html</id>
    <published>2024-04-03T11:31:37.000Z</published>
    <updated>2024-04-03T04:37:57.880Z</updated>
    
    <content type="html"><![CDATA[<h1>DFS</h1><p>回溯算法，其实就是dfs的过程，这里给出dfs的代码框架：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(参数)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (终止条件) &#123;</span><br><span class="line">        存放结果;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (选择：本节点所连接的其他节点) &#123;</span><br><span class="line">        处理节点;</span><br><span class="line">        <span class="built_in">dfs</span>(图，选择的节点); <span class="comment">// 递归</span></span><br><span class="line">        回溯，撤销处理结果</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>深搜代码模板，该模板针对的是四方格的地图：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> dir[<span class="number">4</span>][<span class="number">2</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;; <span class="comment">// 四个方向</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; grid, vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt;&amp; visited, <span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        <span class="type">int</span> nextx = x + dir[i][<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> nexty = y + dir[i][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (nextx &lt; <span class="number">0</span> || nextx &gt;= grid.<span class="built_in">size</span>() || nexty &lt; <span class="number">0</span> || nexty &gt;= grid[<span class="number">0</span>].<span class="built_in">size</span>()) <span class="keyword">continue</span>;  <span class="comment">// 越界了，直接跳过</span></span><br><span class="line">        <span class="keyword">if</span> (!visited[nextx][nexty]) &#123; <span class="comment">// 没有访问过的</span></span><br><span class="line">            visited[nextx][nexty] = <span class="literal">true</span>; </span><br><span class="line">            <span class="built_in">dfs</span>(grid, visited, nextx, nexty);</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>BFS</h1><p>广搜代码模板，该模板针对的是四方格的地图：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> dir[<span class="number">4</span>][<span class="number">2</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;; <span class="comment">// 表示四个方向</span></span><br><span class="line"><span class="comment">// grid 是地图，也就是一个二维数组</span></span><br><span class="line"><span class="comment">// visited标记访问过的节点，不要重复访问</span></span><br><span class="line"><span class="comment">// x,y 表示开始搜索节点的下标</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; grid, vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt;&amp; visited, <span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; que; <span class="comment">// 定义队列</span></span><br><span class="line">    que.<span class="built_in">push</span>(&#123;x, y&#125;); <span class="comment">// 起始节点加入队列</span></span><br><span class="line">    visited[x][y] = <span class="literal">true</span>; <span class="comment">// 只要加入队列，立刻标记为访问过的节点</span></span><br><span class="line">    <span class="keyword">while</span>(!que.<span class="built_in">empty</span>()) &#123; <span class="comment">// 开始遍历队列里的元素</span></span><br><span class="line">        pair&lt;<span class="type">int</span> ,<span class="type">int</span>&gt; cur = que.<span class="built_in">front</span>(); </span><br><span class="line">        que.<span class="built_in">pop</span>(); <span class="comment">// 从队列取元素</span></span><br><span class="line">        <span class="type">int</span> curx = cur.first;</span><br><span class="line">        <span class="type">int</span> cury = cur.second; <span class="comment">// 当前节点坐标</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123; <span class="comment">// 开始想当前节点的四个方向左右上下去遍历</span></span><br><span class="line">            <span class="type">int</span> nextx = curx + dir[i][<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> nexty = cury + dir[i][<span class="number">1</span>]; <span class="comment">// 获取周边四个方向的坐标</span></span><br><span class="line">            <span class="keyword">if</span> (nextx &lt; <span class="number">0</span> || nextx &gt;= grid.<span class="built_in">size</span>() || nexty &lt; <span class="number">0</span> || nexty &gt;= grid[<span class="number">0</span>].<span class="built_in">size</span>())</span><br><span class="line">                <span class="keyword">continue</span>;<span class="comment">// 坐标越界了，直接跳过</span></span><br><span class="line">            <span class="keyword">if</span> (!visited[nextx][nexty]) &#123; <span class="comment">// 如果节点没被访问过</span></span><br><span class="line">                que.<span class="built_in">push</span>(&#123;nextx, nexty&#125;);  <span class="comment">// 队列添加该节点为下一轮要遍历的节点</span></span><br><span class="line">                visited[nextx][nexty] = <span class="literal">true</span>; <span class="comment">// 只要加入队列立刻标记，避免重复访问</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;DFS&lt;/h1&gt;
&lt;p&gt;回溯算法，其实就是dfs的过程，这里给出dfs的代码框架：&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/spa</summary>
      
    
    
    
    <category term="Algorithm" scheme="https://escapeey.github.io/categories/Algorithm/"/>
    
    
    <category term="Algorithm" scheme="https://escapeey.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>C++-仿函数与函数指针</title>
    <link href="https://escapeey.github.io/post/7b13e28b.html"/>
    <id>https://escapeey.github.io/post/7b13e28b.html</id>
    <published>2024-04-02T22:02:04.000Z</published>
    <updated>2024-04-03T04:37:57.880Z</updated>
    
    <content type="html"><![CDATA[<h1>函数指针</h1><h2 id="指向函数存储内存地址的指针">指向函数存储内存地址的指针</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个 无参返回值为int 的函数指针</span></span><br><span class="line"><span class="built_in">int</span> (*funcPtr)();</span><br></pre></td></tr></table></figure><h2 id="把函数赋值给函数指针">把函数赋值给函数指针</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">func1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">int</span> (*funcPtr)() = func1; </span><br><span class="line">    <span class="comment">// C++会隐式得把func1 转换成 &amp;func1, 无需加入&amp;</span></span><br><span class="line">    funcPtr = func2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="通过函数指针调用函数">通过函数指针调用函数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">func3</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">int</span> (*funcPtr1)(<span class="type">int</span>) = func3;</span><br><span class="line">(*funcPtr1)(<span class="number">5</span>);</span><br><span class="line"><span class="built_in">funcPtr1</span>(<span class="number">5</span>);   <span class="comment">//也可以这么使用，在一些古老的编译器上可能不行</span></span><br></pre></td></tr></table></figure><h2 id="把函数作为参数传入另一个函数">把函数作为参数传入另一个函数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sub</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a-b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> e, <span class="type">int</span> d, <span class="type">int</span>(*func)(<span class="type">int</span> a, <span class="type">int</span> b))</span></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">func</span>(e,d)&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">func</span>(<span class="number">2</span>,<span class="number">3</span>,add);</span><br><span class="line">    <span class="built_in">func</span>(<span class="number">2</span>,<span class="number">3</span>,sub);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>仿函数</h1><h2 id="仿函数由来">仿函数由来</h2><ul><li>是代替 <strong>函数指针</strong> 的手段</li><li>定义一个类，类里面重载函数运算符()，将该类的对象作为函数的入参，那么在函数中同样能调用重载符()里面的方法</li><li>所以说，仿函数就是仿造的函数，它并不是一个真正意义上的函数。它是一个类中的运算符()重载，但它具有函数的功能。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Compare</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_Number;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Compare</span>(<span class="type">int</span> num) : <span class="built_in">m_Number</span>(num)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> other)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_Number &gt; other;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//定义对象调用</span></span><br><span class="line">    <span class="function">Compare <span class="title">cmp</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    cout&lt;&lt; <span class="built_in">cmp</span>(<span class="number">11</span>);</span><br><span class="line">    <span class="comment">//通过临时对象调用</span></span><br><span class="line">    cout&lt;&lt; <span class="built_in">Compare</span>(<span class="number">10</span>)();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="作用">作用</h2><ul><li>在STL库中十分常见</li></ul><h3 id="sort-与-priority-queue-中的用法">sort() 与 priority_queue 中的用法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> pair&lt;string, <span class="type">int</span>&gt; PAIR;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmpfunc</span><span class="params">(<span class="type">const</span> PAIR&amp; lhs, <span class="type">const</span> PAIR&amp; rhs)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> lhs.second &lt; rhs.second;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Compare</span> &#123;  </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> PAIR&amp; lhs, <span class="type">const</span> PAIR&amp; rhs)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> lhs.second &lt; rhs.second;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 仿函数 并且是临时对象</span></span><br><span class="line">    <span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), <span class="built_in">Compare</span>());  </span><br><span class="line">    <span class="comment">// 直接传入函数指针 隐式将cmpfunc 转为 &amp;cmpfunc</span></span><br><span class="line">    <span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), cmpfunc);</span><br><span class="line">    <span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), <span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">    <span class="comment">// 对priority_queue 只能传 结构体或类的 名称，不是对象！！！</span></span><br><span class="line">    <span class="comment">// 因为是定义 而不是像sort一样直接使用 仿函数 greater&lt;int&gt;()</span></span><br><span class="line">    priority_queue&lt;PAIR, vector&lt;PAIR&gt;, Compare &gt; que;</span><br><span class="line">    priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt; &gt; que;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="greater-int-源码">greater<int> 源码</h3><p>是一个仿函数<br><img src="../../img/C++/greater源码.png" width="100%" height="100%"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;函数指针&lt;/h1&gt;
&lt;h2 id=&quot;指向函数存储内存地址的指针&quot;&gt;指向函数存储内存地址的指针&lt;/h2&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;</summary>
      
    
    
    
    <category term="C++" scheme="https://escapeey.github.io/categories/C/"/>
    
    
    <category term="C++" scheme="https://escapeey.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>排序算法</title>
    <link href="https://escapeey.github.io/post/735e5788.html"/>
    <id>https://escapeey.github.io/post/735e5788.html</id>
    <published>2024-04-01T16:36:10.000Z</published>
    <updated>2024-04-03T04:37:57.880Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/alzzw/article/details/98100378">参考博客</a></p><img src="../../img/Algorithm/排序算法分类.png" width="100%" height="100%"><h1>复杂度</h1><img src="../../img/Algorithm/排序算法复杂度对比.png" width="100%" height="100%"><ul><li>稳定性：<ul><li>指待排序的序列中有两元素相等,排序之后它们的先后顺序不变.</li><li>也可以理解为一切皆在掌握中,元素的位置处在你在控制中.而不稳定算法有时就有点碰运气,随机的成分.</li></ul></li></ul><h1>BubbleSort</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">BubbleSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; vec, <span class="type">int</span> l, <span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &lt; r)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;r; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(vec[i] &gt; vec[i+<span class="number">1</span>])</span><br><span class="line">                <span class="built_in">swap</span>(vec[i], vec[i+<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">BubbleSort</span>(vec, l, r<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>SelectionSort</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SelectionSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; vec, <span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(n &gt; <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="type">int</span> max = vec[<span class="number">0</span>], pos = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(max &lt; vec[i])&#123;</span><br><span class="line">                max = vec[i];</span><br><span class="line">                pos = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">swap</span>(vec[pos], vec[n<span class="number">-1</span>];)</span><br><span class="line">        n--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>InsertionSort</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">InsertionSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; vec, <span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;n; i++)&#123;</span><br><span class="line">        <span class="type">int</span> key = vec[i], j = i;</span><br><span class="line">        <span class="keyword">while</span>(vec[j<span class="number">-1</span>] &gt; key)&#123;</span><br><span class="line">            vec[j] = vec[j<span class="number">-1</span>];</span><br><span class="line">            j--;</span><br><span class="line">            <span class="keyword">if</span>(j==<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        vec[j] = key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>ShellSort</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ShellSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> gap = n / <span class="number">2</span>; gap &gt;= <span class="number">1</span> ; gap /= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = gap; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="type">int</span> j, key = nums[i];</span><br><span class="line">            <span class="keyword">for</span> (j = i - gap; j &gt;= <span class="number">0</span> &amp;&amp; key &lt; nums[j]; j -= gap) &#123;</span><br><span class="line">                <span class="comment">// 依次后移</span></span><br><span class="line">                nums[j + gap] = nums[j];</span><br><span class="line">            &#125;</span><br><span class="line">            nums[j + gap] = key;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>MergeSort</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Merge</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; vec, <span class="type">int</span> l, <span class="type">int</span> mid, <span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">helper</span><span class="params">(vec)</span></span>;</span><br><span class="line">    <span class="type">int</span> lp = l, rp = mid+<span class="number">1</span>, cp = l;</span><br><span class="line">    <span class="keyword">while</span>(lp&lt;=mid &amp;&amp; rp&lt;=r)&#123;</span><br><span class="line">        <span class="keyword">if</span>(helper[lp] &gt;= helper[rp])&#123;</span><br><span class="line">            vec[cp++] = helper[rp++];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            vec[cp++] = helper[lp++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(lp &lt;= mid)&#123;</span><br><span class="line">        vec[cp++] = helper[lp++];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MergeSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; vec, <span class="type">int</span> l, <span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &lt; r)&#123;</span><br><span class="line">        <span class="type">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">MergeSort</span>(vec, l, mid);</span><br><span class="line">        <span class="built_in">MergeSort</span>(vec, mid+<span class="number">1</span>, r);</span><br><span class="line">        <span class="built_in">Merge</span>(vec, l, mid, r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>QuickSort</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">QuickSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp;nums, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;    </span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) </span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> x = <span class="built_in">rand</span>() % (r - l + <span class="number">1</span>) + l;</span><br><span class="line">    <span class="built_in">swap</span>(nums[l], nums[x]);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> pivot = nums[l], lp = l, rp = r;</span><br><span class="line">    <span class="keyword">while</span> (lp &lt; rp) &#123;</span><br><span class="line">        <span class="keyword">while</span> (nums[rp] &gt;= pivot &amp;&amp; lp &lt; rp) </span><br><span class="line">            rp--;</span><br><span class="line">        <span class="keyword">if</span> (lp &lt; rp)</span><br><span class="line">            nums[lp] = nums[rp];</span><br><span class="line">        <span class="keyword">while</span> (nums[lp] &lt;= pivot &amp;&amp; lp &lt; rp) </span><br><span class="line">            lp++;</span><br><span class="line">        <span class="keyword">if</span> (lp &lt; rp)</span><br><span class="line">            nums[rp] = nums[lp];</span><br><span class="line">    &#125;</span><br><span class="line">    nums[lp] = pivot;</span><br><span class="line">    <span class="built_in">QuickSort</span>(nums, l, lp - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">QuickSort</span>(nums, lp + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>HeapSort</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">heapify</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; vec, <span class="type">int</span> i, <span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> lp = <span class="number">2</span>*i+<span class="number">1</span>, rp = <span class="number">2</span>*i+<span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> largestId = i;</span><br><span class="line">    <span class="keyword">if</span>(lp &lt; n &amp;&amp; vec[largestId] &lt; vec[lp]) </span><br><span class="line">        largestId = lp;</span><br><span class="line">    <span class="keyword">if</span>(rp &lt; n &amp;&amp; vec[largestId] &lt; vec[rp])</span><br><span class="line">        largestId = rp;</span><br><span class="line">    <span class="keyword">if</span>(largestId != i)&#123;</span><br><span class="line">        <span class="built_in">swap</span>(vec[largestId], vec[i]);</span><br><span class="line">        <span class="built_in">heapify</span>(vec, largestId, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HeapSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; vec)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n = vec.<span class="built_in">size</span>();</span><br><span class="line">    <span class="comment">// 建堆</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n/<span class="number">2</span><span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">        <span class="built_in">heapify</span>(vec, i, n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//排序</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n<span class="number">-1</span>; i&gt;<span class="number">0</span>; i--)&#123;</span><br><span class="line">        <span class="built_in">swap</span>(vec[i], vec[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">heapify</span>(vec, <span class="number">0</span>, i); </span><br><span class="line">        <span class="comment">// 这里的i是堆去掉排序好的元素后的长度</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>BucketSort</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置10个桶</span></span><br><span class="line"><span class="type">int</span> N = <span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BucketSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;vec)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n = vec.<span class="built_in">size</span>();</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">bucket</span>(N);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    bucket[vec[i] / <span class="number">10</span>].<span class="built_in">push_back</span>(vec[i]);</span><br><span class="line">    <span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++)&#123;</span><br><span class="line">    <span class="comment">//对每个桶进行排序</span></span><br><span class="line">    <span class="built_in">sort</span>(bucket[i].<span class="built_in">begin</span>(), bucket[i].<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;bucket[i].<span class="built_in">size</span>(); j++)</span><br><span class="line">        vec[k++] = bucket[i][j];<span class="comment">//放入原数组</span></span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;().<span class="built_in">swap</span>(bucket); <span class="comment">//释放空间</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>RadixSort</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_max</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; vec, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> max = vec[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">        <span class="keyword">if</span> (vec[i] &gt; max)</span><br><span class="line">            max = vec[i];</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对数组按照&quot;某个位数&quot;进行排序(桶排序)</span></span><br><span class="line"><span class="comment">// exp -- 指数 0, 10, 100, ...</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">count_sort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; vec, <span class="type">int</span> n, <span class="type">int</span> exp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">output</span><span class="params">(n)</span></span>;             <span class="comment">// 存储&quot;被排序数据&quot;的临时数组</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">buckets</span><span class="params">(<span class="number">10</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="comment">// 将数据出现的次数存储在buckets中</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        buckets[(vec[i]/exp)%<span class="number">10</span>]++;</span><br><span class="line">    <span class="comment">// 更改buckets[i]。目的是让更改后的buckets[i]的值，是该数据在output[]中的位置。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">        buckets[i] += buckets[i - <span class="number">1</span>];</span><br><span class="line">    <span class="comment">// 将数据存储到临时数组output中</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        output[buckets[(vec[i]/exp)%<span class="number">10</span>] - <span class="number">1</span>] = vec[i];</span><br><span class="line">        buckets[(vec[i]/exp)%<span class="number">10</span>]--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将排序好的数据赋值给vec</span></span><br><span class="line">    vec.<span class="built_in">swap</span>(output);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RadixSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; vec, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> max = <span class="built_in">get_max</span>(vec, n);    </span><br><span class="line">    <span class="comment">// 从个位开始，对数组a按&quot;指数&quot;进行排序</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> exp = <span class="number">1</span>; max/exp &gt; <span class="number">0</span>; exp *= <span class="number">10</span>)</span><br><span class="line">        <span class="built_in">count_sort</span>(vec, n, exp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/alzzw/article/details/98100378&quot;&gt;参考博客&lt;/a&gt;&lt;/p&gt;
&lt;img src=&quot;../../img/Algorithm/排序算法分类.png&quot; width=&quot;100%&quot; height</summary>
      
    
    
    
    <category term="Algorithm" scheme="https://escapeey.github.io/categories/Algorithm/"/>
    
    
    <category term="Algorithm" scheme="https://escapeey.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Unity-NGUI之基础及组合控件</title>
    <link href="https://escapeey.github.io/post/f24ad560.html"/>
    <id>https://escapeey.github.io/post/f24ad560.html</id>
    <published>2024-01-05T19:49:55.000Z</published>
    <updated>2024-04-03T04:37:57.884Z</updated>
    
    <content type="html"><![CDATA[<img src="../../../img/Unity/NGUI_Root_缩放模式设置.bmp" width="70%" height="50%"><h1>基础控件</h1><h2 id="Sprite">Sprite</h2><h3 id="Sprite作用">Sprite作用</h3><p>NGUI中所有中小尺寸图片显示都用Sprite显示<br>使用它来显示图集中的单个图片资源</p><h3 id="创建Sprite">创建Sprite</h3><ul><li>Scene窗口红框内右键</li><li>上方工具栏<strong>NGUI</strong>中创建</li></ul><h3 id="Sprite参数">Sprite参数</h3><p>略</p><h3 id="代码设置图片">代码设置图片</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.改变为当前图集中选择的图片</span></span><br><span class="line">sprite.spriteName = <span class="string">&quot;bk&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.改变为其它图集中的图片</span></span><br><span class="line"><span class="comment">//先加载图集</span></span><br><span class="line">NGUIAtlas atlas = Resources.Load&lt;NGUIAtlas&gt;(<span class="string">&quot;Atlas/login&quot;</span>);</span><br><span class="line">sprite.atlas = atlas;</span><br><span class="line"><span class="comment">//再设置图片</span></span><br><span class="line">sprite.spriteName = <span class="string">&quot;ui_DL_anniuxiao_01&quot;</span>;</span><br></pre></td></tr></table></figure><h2 id="Label">Label</h2><ul><li>文本(支持富文本)</li></ul><h2 id="Texture">Texture</h2><ul><li>一般图片，不能放到atlas 中的图片</li></ul><h1>组合控件</h1><h2 id=""></h2>]]></content>
    
    
      
      
    <summary type="html">&lt;img src=&quot;../../../img/Unity/NGUI_Root_缩放模式设置.bmp&quot; width=&quot;70%&quot; height=&quot;50%&quot;&gt;
&lt;h1&gt;基础控件&lt;/h1&gt;
&lt;h2 id=&quot;Sprite&quot;&gt;Sprite&lt;/h2&gt;
&lt;h3 id=&quot;Sprite作用&quot;&gt;Spr</summary>
      
    
    
    
    <category term="Unity" scheme="https://escapeey.github.io/categories/Unity/"/>
    
    
    <category term="C#" scheme="https://escapeey.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>OS-文件管理</title>
    <link href="https://escapeey.github.io/post/331e8fa6.html"/>
    <id>https://escapeey.github.io/post/331e8fa6.html</id>
    <published>2024-01-05T16:46:13.000Z</published>
    <updated>2024-04-03T04:37:57.880Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>OS-IO设备管理</title>
    <link href="https://escapeey.github.io/post/346f634c.html"/>
    <id>https://escapeey.github.io/post/346f634c.html</id>
    <published>2024-01-05T16:46:06.000Z</published>
    <updated>2024-04-03T04:37:57.880Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>OS-存储器管理</title>
    <link href="https://escapeey.github.io/post/3d04630d.html"/>
    <id>https://escapeey.github.io/post/3d04630d.html</id>
    <published>2024-01-05T16:44:32.000Z</published>
    <updated>2024-04-03T04:37:57.880Z</updated>
    
    <content type="html"><![CDATA[<p>存储管理是指存储器资源（主要指内存并涉及外存）的管理。</p><ul><li><strong>存储器资源的组织</strong>（如内存的组织方式）</li><li><strong>地址变换</strong>（逻辑地址与物理地址的对应关系维护）</li><li><strong>虚拟存储的调度算法</strong></li></ul><h1>存储管理的功能</h1><ol><li><strong>主存分配和回收</strong><br>分配和回收算法及相应的数据结构。</li><li><strong>地址变换</strong><ul><li>可执行文件生成中的链接技术</li><li>程序加载(装入)时的重定位技术</li><li>进程运行时硬件和软件的地址变换技术和机构</li></ul></li><li><strong>存储共享和保护</strong><ul><li>代码和数据共享</li><li>地址空间访问权限（读、写、执行）</li></ul></li><li><strong>主存容量扩充</strong>(存储器的逻辑组织和物理组织)<ul><li>由应用程序控制：覆盖；</li><li>由OS控制：交换（整个进程空间），虚拟存储的请求调入和预调入（部分进程空间）</li><li>提高主存利用率</li></ul></li></ol><h1>程序的装入和链接</h1><h2 id="程序的装入-重定位-地址映射">程序的装入(重定位)(地址映射)</h2><h3 id="重定位">重定位</h3><ul><li><strong>重定位</strong>: 程序运行装入主存时，要将程序中的虚拟地址转换为主存中的物理地址，这个转化过程就是重定位。</li><li>程序成为进程前的准备工作:<ul><li><strong>编辑</strong>：形成源文件(符号地址)</li><li><strong>编译</strong>：形成目标模块(模块内符号地址解析)</li><li><strong>链接</strong>：由多个目标模块或程序库生成可执行文件(模块间符号地址解析)</li><li><strong>装入</strong>：构造PCB，形成进程(使用物理地址)</li></ul></li></ul><h3 id="重定位方法">重定位方法</h3><h4 id="可重定位装入-静态重定位">可重定位装入(静态重定位)</h4><ul><li>内容<ul><li>编写程序时可以采用相对地址</li><li>作业（用户程序）在装入内存时才确定它的物理地址，并且将相对地址转换为物理地址</li><li>作业一旦装入就不能移动、改变空间或者被换出主存。</li><li>在程序运行之前，由<strong>链接</strong>装入程序进行的一次重定位。</li><li>在程序运行之前已经<strong>完成了逻辑地址到物理地址的转换</strong>(只要完成链接装入)</li></ul></li><li>优点：<strong>不需硬件变换机构</strong>支持，可以装入有限多道程序</li><li>缺点：一个程序通常需要占用连续的内存空间，程序装入内存后<strong>在运行期间不能移动</strong>，不易实现共享。</li></ul><h4 id="动态运行时装入-动态重定位">动态运行时装入(动态重定位)</h4><ul><li>内容<ul><li>动态重定位是在程序<strong>执行的过程</strong>中，每当访问指令或数据时，才将要访问的<strong>指令或数据</strong>的<strong>逻辑地址转换成物理地址</strong>。</li><li>在程序<strong>装入时不对地址做任何操作</strong>，也就是保留逻辑地址不变。</li><li><strong>运行时重定位</strong>：可以使程序载入后还可以移动</li><li>每个进程有各自的<strong>基地址,放在PCB</strong></li></ul></li></ul><h1>连续分配方式</h1><h2 id="分配方式">分配方式</h2><ul><li><p><strong>固定分区</strong>: 把内存划分为若干个固定大小的连续分区。</p><ul><li>分区大小可以相等也可以不同</li><li><strong>固定分区可能存在内碎片</strong></li><li>系统通过<strong>分区说明表</strong>对内存进行管理和控制。</li></ul></li><li><p><strong>动态分区</strong>：在装入程序时按其初始要求分配，或在其执行过程中通过系统调用进行分配或改变分区大小。</p><ul><li>没有内碎片；有外碎片，如果大小不是任意的，也可能出现内碎片。</li><li><strong>内存紧缩</strong>：将空闲分区合并，需要移动多个段(复制内容)：</li></ul></li></ul><h2 id="分区分配数据结构">分区分配数据结构</h2><h3 id="空闲分区表">空闲分区表</h3><ul><li>用于为内存中每个<strong>尚未分配</strong>的分区设置一个表项，每个分区的表项包含<strong>分区序号</strong>、<strong>分区始址</strong>及<strong>分区大小</strong>；</li></ul><h3 id="空闲分区链">空闲分区链</h3><ul><li>通过前、后向指针将所有的分区链接成一个双向链</li></ul><h2 id="分区分配算法">分区分配算法</h2><h3 id="首次适应算法FF">首次适应算法FF</h3><ol><li>内容<br>内存分配时，从<strong>链首开始顺序查找</strong>，直至找到一个能满足其大小要求的空闲分区为止。然后按作业大小划出一块内存空间分配给请求者，余下的空闲分区仍留在空闲链中。</li><li>优点<ul><li>优先利用内存中<strong>低址</strong>部分的空闲分区，在<strong>高址</strong>部分的空闲分区很少被利用，从而保留了高址部分的大空闲区，为后到的大作业分配大的内存空间创造了条件。</li></ul></li><li>缺点<ul><li><strong>低址部分不断被划分</strong>，形成碎片；</li><li>每次查找都从低址部分开始，这<strong>增加了查找可用空闲分区的开销</strong>。</li></ul></li></ol><h3 id="循环首次适应算法">循环首次适应算法</h3><ol><li>内容<ul><li>内存分配时，从<strong>上次找到的空闲分区的下一个空闲分区</strong>开始查找，直至找到第一个能满足要求的空闲分区，并从中划出一块与请求的大小相等的内存空间分配给作业</li><li>设置一起始查寻指针，并采用<strong>循环查找</strong>方式。</li></ul></li><li>优点<ul><li>使内存中的空闲分区分布得更均匀</li><li>减少查找空闲分区的开销</li></ul></li><li>缺点<ul><li>缺乏大的空闲分区</li></ul></li></ol><h3 id="最佳适应算法">最佳适应算法</h3><ol><li>内容<ul><li>“最佳”是指每次为作业分配内存时，总把<strong>既能满足要求</strong>、<strong>又是最小</strong>的空闲分区分配给作业，避免了“大材小用”。</li><li>为了加速寻找，该算法要求将所有的空闲区，<strong>按其大小以递增</strong>的顺序形成<strong>空闲区链</strong>。</li></ul></li></ol><h2 id="分区分配和回收操作">分区分配和回收操作</h2><h3 id="动态分区分配内存">动态分区分配内存</h3><blockquote><ul><li>首先系统要利用某种分配算法，从空闲分区链(表)中找到所需的分区;</li><li>设<strong>请求的分区大小为u.size</strong>，表中每个空闲分区的大小可表示为m.size;</li><li>if(<strong>m.size-u.size&lt;=size</strong>)<br>- // size是事先规定的不再切割的剩余分区的大小<br>- 说明多余部分太小,可不再切割，<strong>将整个分区分配给请求者</strong>;</li><li>else<br>- 从该分区中划分出与请求的大小相等的内存空间分配出去，余下的部分仍留在空闲分区链或空闲分区表中。最后，将分配区的首址返回给调用者;</li></ul></blockquote><h3 id="回收内存">回收内存</h3><h4 id="内存紧缩">内存紧缩</h4><ul><li>内容：将各个占用分区向内存一端移动。使各个空闲分区聚集在另一端，然后将各个空闲分区合并成为一个空闲分区。</li><li>这过程涉及到了<strong>动态重定位</strong></li><li>紧缩时机：每个分区释放后，或内存分配找不到满足条件的空闲分区时</li></ul><h3 id="可重定位分区分配-增加了内存紧凑">可重定位分区分配(增加了内存紧凑)</h3><img src="..\..\img\OS\动态重定位分区分配算法.png" width="50%" height="70%" align="middle"><h2 id="对换">对换</h2><h3 id="对换的定义">对换的定义</h3><ul><li>指把内存中<strong>暂时不能运行的进程</strong>或者<strong>暂时不用的程序和数据</strong>，调出到<strong>外存</strong>上，以便腾出足够的内存空间，再把已具备运行条件的进程或进程所需要的程序和数据，调入内存</li><li>对换是提高内存利用率的有效措施</li><li>整体对换(进程对换): 对换是以整个进程为单位</li><li>部分对换(页面对换/分段对换): 对换是以“<strong>页</strong>”或“<strong>段</strong>”为单位进行</li><li>为了实现进程对换，系统必须能实现三方面的功能：<ul><li>对换空间的管理</li><li>进程的换出</li><li>进程的换入</li></ul></li></ul><h3 id="对换空间的管理">对换空间的管理</h3><ul><li>数据结构: 空闲分区表或空闲分区链</li><li><strong>空闲分区表</strong>中的每个表目中应<strong>包含两项</strong>， 即<strong>对换区</strong>的<strong>首址</strong>及其<strong>大小</strong>，它们的单位是<strong>盘块号</strong>和<strong>盘块数</strong>。</li></ul><blockquote><p><strong>外存空间分类</strong><br><strong>文件区</strong>：用于<strong>存放文件</strong>，由于通常的文件都是较长久地驻留在外存上，故对文件区管理的主要目标是<strong>提高文件存储空间的利用率</strong>，为此系统采取<strong>离散分配</strong>方式。<br><strong>对换区</strong>：用于<strong>存放从内存换出的进程</strong>，由于这些进程在对换区中驻留的时间是短暂的，而对换操作又较频繁，故对对换空间管理的主要目标是<strong>提高进程的换入、换出速度</strong>，为此所应采取的管理策略是<strong>用连续分配方式</strong>，较少考虑外存中的碎片问题。</p></blockquote><h3 id="进程的换出与换入">进程的换出与换入</h3><h4 id="进程的换出">进程的换出</h4><ul><li>每一进程由于创建子进程而需要更多的内存空间，但又无足够的内存空间等情况发生时，系统应将某进程换出</li><li>换出过程:<ul><li>系统首先选择处于<strong>阻塞状态</strong>且<strong>优先级最低</strong>的进程作为换出进程;</li><li>启动盘块，将该进程的程序和数据传送到磁盘的对换区上;</li><li>若传送过程未出现错误，便可<strong>回收该进程所占用的内存空间</strong>，并对该进程的PCB做相应的修改。</li></ul></li></ul><h4 id="进程的换入">进程的换入</h4><ul><li>系统应<strong>定时地查看</strong>所有进程的状态;</li><li>从中找出“<strong>就绪</strong>”状态但已换出的进程，将其中<strong>换出时间(换出到磁盘上)最久的进程</strong>作为换入进程，将之换入;</li><li>直至已无可换入的进程或无可换出的进程为止。</li></ul><h1>离散分配方式</h1><ul><li>思想：将<strong>一个进程</strong>直接<strong>分散地分配到许多不相邻接的分区中</strong>，就不必再进行“紧凑”。</li><li>离散分配种类：<ul><li>分页存储管理</li><li>分段存储管理</li><li>段页式存储管理</li></ul></li></ul><h1>基本分页存储管理方式</h1><h2 id="页面和物理块">页面和物理块</h2><ul><li><strong>页面</strong>:<ul><li>将一个进程的<strong>逻辑地址空间</strong>分成若干个<strong>大小相等</strong>的片，称为<strong>页面</strong>或<strong>页</strong>，并为各页加以编号，从0开始，如第0页、第1页等。</li></ul></li><li><strong>物理块(页框)</strong>:<ul><li>把<strong>内存空间</strong>分成与<strong>页面相同大小</strong>的若干个存储块</li></ul></li><li>分配时<strong>主存块可以不连续</strong>; 而<strong>页内逻辑地址是连续的</strong></li><li><strong>分页存储器的逻辑地址</strong>: 页号和页内地址(位移量)<ul><li>假设地址总长度为15位，其中页号占5位，页内地址占10位;那么逻辑地址可有32页，编号为0－31;页内地址占10位，则块的大小为1024个字节。编号为0－1023。</li><li>若给定一个逻辑地址空间中的地址为A，页面的大小为L，则页号P和页内地址d可按下式求得:</li></ul><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>P</mi><mo>=</mo><mi>I</mi><mi>N</mi><mi>T</mi><mo stretchy="false">[</mo><mi>A</mi><mi mathvariant="normal">/</mi><mi>L</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">P=INT[A/L]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mord mathnormal" style="margin-right:0.13889em;">NT</span><span class="mopen">[</span><span class="mord mathnormal">A</span><span class="mord">/</span><span class="mord mathnormal">L</span><span class="mclose">]</span></span></span></span></span></p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>d</mi><mo>=</mo><mi>A</mi><mi>m</mi><mi>o</mi><mi>d</mi><mo stretchy="false">(</mo><mi>L</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">d=A mod(L)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">d</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">A</span><span class="mord mathnormal">m</span><span class="mord mathnormal">o</span><span class="mord mathnormal">d</span><span class="mopen">(</span><span class="mord mathnormal">L</span><span class="mclose">)</span></span></span></span></span></p></li></ul><h2 id="页表-地址变换机构">页表(地址变换机构)</h2><ul><li><p>作用：实现<strong>逻辑地址</strong>到<strong>物理地址</strong>的转换(将<strong>逻辑地址中的页号</strong>转换为<strong>内存中的物理块号</strong>)</p></li><li><p>地址转换的公式为：<strong>绝对地址＝块号*块长+页内地址</strong><br><img src="..\..\img\OS\页表变换地址.png" width="50%" height="70%" align="middle"></p></li><li><p>页表控制寄存器–系统中只有一个</p></li></ul><h2 id="引入快表-TLB-的地址变换机构">引入快表(TLB)的地址变换机构</h2><ul><li>引入原因：由于页表是存放在内存中的，这使CPU每次要存取一个数据时，都要两次访问内存。<ul><li>第一次是访问内存中的<strong>页表</strong>，从中找到该页的物理块号，将此块号与页内偏移量w拼接以形成物理地址</li><li>第二次访问内存时，才是从第一步所得地址中<strong>获得所需数据</strong>(或向此地址中写入数据)</li></ul></li><li>TLB是一组相联快速存储，是寄存器，类似<strong>Cache</strong></li><li><em><em>有效访问时间 = HitR</em>(TLB+MA) + (1-HitR)*(TLB+2MA)</em>*</li><li>原理：<ul><li>程序的地址访问存在局部性</li><li>空间局部性(程序多体现为循环、顺序结构)<br><img src="..\..\img\OS\具有块表的页表地址变换.png" width="50%" height="70%" align="middle"></li></ul></li></ul><h2 id="两级和多级页表">两级和多级页表</h2><ul><li>引入原因: 现代的大多数计算机系统，都支持非常大的逻辑地址空间。在这样的环境下，页表就变得非常大，要占用相当大的内存空间。并且为连续的。</li><li>解决方法：<ul><li>采用<strong>离散分配方式</strong>来解决难以找到一块连续的大内存空间的问题；</li><li>将<strong>当前需要的部分页表项调入内存</strong>，其余的<strong>页表项驻留在磁盘上</strong>，需要时再调入</li></ul></li></ul><h3 id="两级页表">两级页表</h3><ul><li>将页表也进行分页的办法，使每个页面的大小与内存物理块的大小相同，并为它们进行编号，即依次为0页，1页，…，n页。可以离散地将各个页面分别放在不同的物理块中</li><li>外层页表：为离散分配的页表再建立一张页表，称为外层页表(Outer Page Table)，在每个页表项中记录了页表页面的物理块号。</li></ul><h1>基本分段存储管理方式</h1><ul><li>引入：为了满足用户和程序员的下述一系列需要：<ul><li><strong>方便编程</strong>：通常采用分段，汇编。。。</li><li><strong>信息共享</strong>：通常，在实现程序和数据的共享时，都是以信息的逻辑单位为基础的；<ul><li>比如，共享某个例程和函数。而在分页系统中的每一页都只是存放信息的物理单位，其本身并无完整的意义，因而不便于实现信息共享；然而段却是信息的逻辑单位。</li></ul></li><li><strong>信息保护</strong></li><li><strong>动态增长</strong></li><li><strong>动态链接</strong></li></ul></li></ul><h2 id="分段">分段</h2><ul><li>内容：<ul><li>作业的地址空间被划分为若干个段，每个段定义了一组逻辑信息。</li><li>将程序的地址空间划分为若干个段(segment)，程序加载时，分配其所需的所有段（内存分区），这些段不必连续；物理内存的管理采用动态分区。需要CPU的硬件支持。</li></ul></li><li>优点：<ul><li>没有内碎片，外碎片可以通过内存紧缩来消除</li><li>便于改变进程占用空间的大小</li></ul></li></ul><h2 id="段表">段表</h2><p>段表实现从逻辑段到物理内存区的映射。<br><img src="..\..\img\OS\段表变换地址.png" width="50%" height="70%" align="middle"></p><h2 id="分页和分段的主要区别">分页和分段的主要区别</h2><h3 id="相同点">相同点</h3><ul><li>都采用离散分配方式；</li><li>都要通过地址映射机构来实现地址变换</li></ul><h3 id="不同点">不同点</h3><ul><li><strong>分页是出于系统管理</strong>的需要，<strong>分段是出于用户应用</strong>的需要<ul><li>一条指令或一个操作数可能会跨越两个页的分界处，而不会跨越两个段的分界处。</li></ul></li><li>页大小是系统固定的，而段大小则通常不固定</li><li><strong>逻辑地址表示</strong>：<ul><li>分页是一维的，各个模块在链接时必须组织成同一个地址空间；</li><li>分段是二维的，各个模块在链接时可以每个段组织成一个地址空间</li></ul></li><li>通常<strong>段比页大</strong>，因而段表比页表短，可以缩短查找时间，提高访问速度。</li><li>分页系统能有效地<strong>提高内存利用率</strong>，而分段系统则能很好地<strong>满足用户需要</strong>。</li></ul><h1>段页式存储管理方式</h1><h2 id="优点：">优点：</h2><ul><li>段页式既具有分段系统<strong>便于实现、分段可共享、易于保护、可动态链接</strong>等一系列优点；</li><li>也具有分页系统那样很好地<strong>解决内存的外部碎片问题</strong>，以及为各个分段<strong>可离散地</strong>分配内存等问题</li></ul><h2 id="基本原理">基本原理</h2><p>把用户程序分成若干段，再把每个段分成若干页<br><img src="..\..\img\OS\段页式地址变换.png" width="50%" height="70%" align="middle"></p><ul><li>在段页式系统中，为了获取一条指令或数据，须3次访问内存。<ul><li>第一次：访问内存中的段表，从中取得页表地址；</li><li>第二次：访问内存中的页表，从中取出该页所在的物    理块号，同时和页内地址相加求出物理地址；</li><li>第三次：从地址中取出指令或数据；</li></ul></li></ul><h1>虚拟存储器的基本概念</h1><ul><li>引入原因：<ul><li>作业很大：<br>其所要求的内存空间超过了内存总容量，作业不能全部被装入内存，致使该作业无法运行；</li><li>大量作业要求运行：<br>但由于内存容量不足以容纳所有这些作业，只能将少数作业装入内存让它们先运行，而将其它大量的作业留在外存上等待。</li></ul></li><li>解决方法：<ul><li>从<strong>物理上</strong>增加内存容量。</li><li>从<strong>逻辑上</strong>扩充内存容量。这正是<strong>虚拟存储技术</strong>所要解决的主要问题。</li></ul></li></ul><h2 id="定义">定义</h2><ul><li>所谓<strong>虚拟存储器</strong>，是指具有<strong>请求调入功能</strong>和<strong>置换功能</strong>，能从<strong>逻辑上</strong>对<strong>内存容量加以扩充</strong>的一种存储器系统。</li><li>其<strong>逻辑容量</strong>受限于计算机的<strong>地址结构</strong>和<strong>可用磁盘容量</strong>，其运行速度<strong>接近于内存速度</strong>。</li></ul><h2 id="基本原理-2">基本原理</h2><ul><li>在程序装入时，不必将其全部读入到内存，而只需<strong>将当前需要执行的部分页或段读入到内存</strong>，就可让程序开始执行。</li><li>在程序执行过程中，如果需执行的指令或访问的数据尚未在内存（称为<strong>缺页或缺段</strong>），则由处理器通知操作系统将相应的页或段<strong>调入到内存</strong>，然后继续执行程序。</li><li>另一方面，操作系统将内存中<strong>暂时不使用的页或段调出保存在外存</strong>上，从而腾出空间存放将要装入的程序以及将要调入的页或段。只需程序的一部分在内存就可执行。</li></ul><h2 id="优点">优点</h2><ul><li><strong>大程序</strong>：可在较小的可用内存中执行较大的用户程序；</li><li><strong>大的用户空间</strong>：提供给用户可用的虚拟内存空间通常大于物理内存(real memory)</li><li><strong>并发</strong>：可在内存中容纳更多程序并发执行；</li><li><strong>易于开发</strong>：与覆盖技术比较，不必影响编程时的程序结构</li></ul><h2 id="实现方式">实现方式</h2><ul><li>虚拟存储器的实现，是建立在<strong>离散分配</strong>的存储管理方式基础上</li><li>常见方法有：<ul><li>分页请求系统</li><li>分段请求系统</li></ul></li></ul><h1>请求分页存储管理方式</h1><h1>页面置换算法</h1><h1>请求分段存储管理方式</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;存储管理是指存储器资源（主要指内存并涉及外存）的管理。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;存储器资源的组织&lt;/strong&gt;（如内存的组织方式）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;地址变换&lt;/strong&gt;（逻辑地址与物理地址的对应关系维护）&lt;/li&gt;
&lt;li&gt;&lt;s</summary>
      
    
    
    
    <category term="操作系统" scheme="https://escapeey.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="操作系统" scheme="https://escapeey.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>OS-进程管理</title>
    <link href="https://escapeey.github.io/post/18614213.html"/>
    <id>https://escapeey.github.io/post/18614213.html</id>
    <published>2024-01-05T16:43:12.000Z</published>
    <updated>2024-04-03T04:37:57.880Z</updated>
    
    <content type="html"><![CDATA[<h1>进程的描述与控制</h1><h2 id="程序的顺序执行及其特征">程序的顺序执行及其特征</h2><p>程序顺序执行时的特征:</p><ul><li><strong>顺序性</strong>: 按照程序结构所指定的次序</li><li><strong>封闭性</strong>: 运行时候独占处理机资源，运行结果不受外界影响</li><li><strong>可再现性</strong>: 初始条件相同，结果相同</li></ul><h2 id="程序的并发执行及其特征">程序的并发执行及其特征</h2><p><strong>定义</strong>：程序的并发执行是指一组在逻辑上互相独立的程序或程序段在执行时间上客观上互相重叠，即一个程序或程序段的执行尚未结束，另一个程序（段）的执行已经开始的执行方式<br>程序并发执行时的特征:</p><ul><li><strong>间断性(相互制约性)</strong>:－ “走走停停”，一个程序可能走到中途停下来，失去原有的时序关系；</li><li><strong>失去封闭性</strong>：多个程序共享系统中的各种资源，因而这些资源的状态将由多个程序来改变, 致使程序的运行已失去了封闭性。</li><li><strong>不可再现性</strong>：程序在并发执行时，由于失去了封闭性，也将导致失去其可再现性</li></ul><h2 id="进程">进程</h2><h3 id="进程的定义">进程的定义</h3><ul><li>简：进程是程序的一次执行；</li><li>详：一个具有一定独立功能的<strong>程序</strong>在一个<strong>数据集合</strong>上的一次<strong>动态执行</strong>过程</li><li>进程是系统进行<strong>资源分配和调度</strong>的一个<strong>独立单位</strong></li></ul><h3 id="进程的特征">进程的特征</h3><ul><li><strong>动态性</strong>:<ul><li>进程是程序产生的：创建-&gt;运行-&gt;消亡</li><li>进程在生命周期中在三种基本状态之间转换</li></ul></li><li><strong>独立性</strong>:<br>各进程的<strong>地址相互独立</strong>，除非采用进程间通信手段</li><li><strong>并发性</strong>:<br>多个进程实体同时存于内存中，能在一段时间内并发进行</li><li><strong>异步性</strong>:<br>每个进程都以其相对独立的不可预知的速度向前推进</li><li><strong>结构化</strong>:<br>进程 = 代码块 + 数据块 + <strong>PCB</strong></li></ul><h3 id="进程的组成">进程的组成</h3><p><strong>进程 = 程序 + 数据 + 进程控制块PCB</strong></p><ul><li><strong>程序</strong>是进程的不可缺少的组成部分；如果一个程序段允许被共享，则它应该是可重入的，或纯代码段</li><li><strong>数据</strong>是进程处理的对象</li><li><strong>进程控制块</strong>是进程的<strong>控制结构</strong>，包含了进程的<strong>描述信息</strong>、<strong>控制信息</strong>和<strong>资源信息</strong>以及<strong>现场保护区</strong>，是进程的<font color=red><strong>唯一标识</strong></font>，系统通过PCB管理和控制进程。</li></ul><h3 id="进程控制块PCB">进程控制块PCB</h3><ul><li>进程控制块是由OS维护的用来记录进程相关信息和管理进程而设置的一个专门的<strong>数据结构</strong></li><li>PCB结构的全部或部分<strong>常驻内存</strong>；</li><li>PCB随进程的创建而填写，随进程的撤消而释放,有生命周期；</li><li>系统利用PCB来控制和管理进程，所以PCB是系统感知进程存在的唯一标志</li><li>进程与PCB是一一对应的</li><li><strong>OS是根据PCB来对并发执行的进程进行控制和管理的。</strong></li><li><strong>所谓创建进程是指创建进程实体中的PCB，撤销亦如此。</strong></li></ul><h4 id="PCB的内容">PCB的内容</h4><ul><li><strong>进程标识符</strong>:<ul><li>内部进程标识符(process ID)，唯一，通常是一个整数</li><li>进程名(外部标识符)，通常基于可执行文件名（不唯一）</li><li>用户标识符(user ID)；进程组关系(process group)</li></ul></li><li><strong>进程调度信息</strong>：<br>进程状态、进程优先级、资源信息等</li><li><strong>处理机状态</strong>：<br>寄存器值（通用、程序计数器PC、状态PSW，地址包括栈指针）</li><li><strong>进程控制信息</strong>:<ul><li>当前状态；</li><li>优先级(priority)；</li><li>代码执行入口地址；</li><li>程序的外存地址；</li><li>运行统计信息（执行时间、页面调度）；</li><li>进程间同步和通信；阻塞原因</li></ul></li></ul><h4 id="PCB的组织方式">PCB的组织方式</h4><ul><li><strong>链表</strong>：同一状态的进程其PCB成一链表，多个状态对应多个不同的链表<ul><li>各状态的进程形成不同的链表：就绪链表、阻塞链表</li></ul></li><li><strong>索引表</strong>：同一状态的进程归入一个index表（由index指向PCB），多个状态对应多个不同的index表<ul><li>各状态的进行形成不同的索引表：就绪索引表、阻塞索引表</li></ul></li></ul><h3 id="进程与程序的区别">进程与程序的区别</h3><ul><li>进程是动态的，程序是静态的：炒菜菜谱</li><li>进程是暂时的，程序的永久的：进程是一个状态变化的过程，程序可长久保存。</li><li>进程与程序的组成不同：进程的组成包括程序、数据和进程控制块（即进程状态信息）。</li><li>进程与程序的对应关系：通过多次执行，一个程序可对应多个进程；通过调用关系，一个进程可包括多个程序。</li><li>进程具有并行特征，程序没有。</li><li>进程是竞争计算机资源的基本单位。</li></ul><h2 id="进程的状态及其转换">进程的状态及其转换</h2><h3 id="进程的三种基本状态">进程的三种基本状态</h3><ul><li><strong>就绪状态(Ready)</strong>：已分配到<strong>除CPU以外</strong>的所有必要的资源，只要能再获得处理机，便可立即执行的状态。多个排成一队称为就绪队列。</li><li><strong>执行状态(Running)</strong>：指进程已获得处理机，其程序正在执行;<ul><li>在单处理机系统中，只能有一个进程处于执行状态;</li><li>在多处理机系统中，则可能多个进程处于执行状态。 </li></ul></li><li><strong>阻塞状态(Blocked)</strong>：进程因<strong>发生某事件</strong>(如请求I／O、申请缓冲空间等)而暂停执行时的状态，亦即进程的执行受到阻塞，故称这种暂停状态为阻塞状态，有时也称为“等待”状态或“睡眠”状态。<ul><li>通常将处于阻塞状态的进程排成一个队列，称为阻塞队列。在有的系统中，按阻塞原因的不同而将处于阻塞状态的进程排成多个队列。</li></ul></li></ul><h3 id="进程的三种基本状态转换">进程的三种基本状态转换</h3><img src="..\..\img\OS\进程三状态.png" width="50%" height="70%" align="middle"><ul><li><strong>就绪-&gt;运行</strong>：调度程序选择一个新的进程运行</li><li><strong>运行-&gt;就绪</strong>：<ul><li>运行进程用完了时间片</li><li>运行进程被中断，因为一高优先级进程处于就绪状态</li></ul></li><li><strong>运行-&gt;等待</strong>：当一进程等待某一事件的发生时，如<ul><li>请求系统服务</li><li>无新工作可做</li></ul></li><li><strong>等待-&gt;就绪</strong>：当所等待的事件发生时</li></ul><h3 id="进程的五状态进程转换">进程的五状态进程转换</h3><img src="..\..\img\OS\进程五状态.png" width="50%" height="70%" align="middle"><ul><li><strong>创建状态(New)</strong>：创建新状态<ul><li>OS 已完成为创建一进程所必要的工作<ul><li>已构造了进程标识符</li><li>已创建了管理进程所需的表格</li></ul></li></ul></li><li><strong>终止状态(Exit)</strong><ul><li>终止后进程移入该状态</li><li>它不再有执行资格</li><li>表格和其它信息暂时保留</li><li>实用程序为了分析性能和利用率，可能要提取程序的历史信息</li></ul></li></ul><h3 id="带挂起的进程转换模型">带挂起的进程转换模型</h3><h4 id="新增状态">新增状态</h4><ul><li><strong>就绪挂起状态(Ready,suspend)</strong>：进程在外存，但只要进入内存，即可运行；</li><li><strong>阻塞挂起状态(Blocked,suspend)</strong>：进程在外存并等待某事件的出现；</li></ul><h4 id="新增事件">新增事件</h4><ul><li><strong>挂起(Suspend)</strong>：把一个进程从内存转到外存；可能有以下几种情况：<ul><li><strong>阻塞到阻塞挂起</strong>：没有进程处于就绪状态或就绪进程要求更多内存资源时，会进行这种转换，以纳入新进程或运行就绪进程；</li><li><strong>就绪到就绪挂起</strong>：当有高优先级阻塞（系统认为会很快就绪的）进程和低优先级就绪进程时，系统会选择挂起低优先级就绪进程；</li><li><strong>运行到就绪挂起</strong>：对抢先式分时系统，当有高优先级阻塞挂起进程因事件出现而进入就绪挂起时，系统可能会把运行进程转到就绪挂起状态；</li></ul></li><li><strong>激活(Activate)</strong>：把一个进程从外存转到内存；可能有以下几种情况：<ul><li><strong>就绪挂起到就绪</strong>：没有就绪进程或挂起就绪进程优先级高于就绪进程时，会进行这种转换；</li><li><strong>阻塞挂起到阻塞</strong>：当一个进程释放足够内存时，系统会把一个高优先级阻塞挂起（系统认为会很快出现所等待的事件）进程转为阻塞状态；较少出现。</li></ul></li><li><strong>事件出现(Event Occurs)</strong>：进程等待的事件出现；如：操作完成、申请成功等；可能的情况有：<ul><li><strong>阻塞到就绪</strong>：针对内存进程的事件出现；</li><li><strong>阻塞挂起到就绪挂起</strong>：针对外存进程的事件出现；</li></ul></li><li><strong>收容(Admit)</strong>：收容一个新进程，进入就绪状态或就绪挂起状态。</li><li><strong>各种状态-&gt;退出</strong>：被父进程终止或父进程本身终止。</li></ul><h4 id="挂起进程目的是">挂起进程目的是:</h4><ul><li><strong>提高处理机效率</strong>：就绪进程表为空时，OS将阻塞进程从内存中“挂起”到磁盘的“挂起队列”，再从该队列选另一进程进入内存，或接受一个新进程的请求。</li><li><strong>为运行进程提供足够内存</strong>：资源紧张时，暂停某些进程，如：CPU繁忙（或实时任务执行）,内存紧张</li><li><strong>用于调试</strong>：在调试时，挂起被调试进程（从而对其地址空间进行读写）</li></ul><h4 id="单挂起进程模型">单挂起进程模型</h4><img src="..\..\img\OS\单挂起进程模型.png" width="50%" height="70%" align="middle"><h4 id="双挂起进程模型">双挂起进程模型</h4><img src="..\..\img\OS\双挂起进程模型.png" width="50%" height="70%" align="middle"><h2 id="进程控制的功能">进程控制的功能</h2><h3 id="原语-primitive">原语(primitive)</h3><ul><li>由若干条指令构成的“原子操作(atomic operation)”过程，作为一个整体而不可分割－－要么全都完成，要么全都不做。许多系统调用就是原语。</li></ul><h3 id="进程创建原语">进程创建原语</h3><p>子进程的创建的3种形式</p><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">产生新进程</th><th style="text-align:center">不产生新进程</th></tr></thead><tbody><tr><td style="text-align:center">复制现有进程的上下文</td><td style="text-align:center"><strong>fork</strong>(新进程的系统上下文会有不同)</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">加载程序</td><td style="text-align:center"><strong>spawn</strong>(创建新进程并加载新程序)</td><td style="text-align:center"><strong>exec</strong>(加载新程序并覆盖自身)</td></tr></tbody></table><h3 id="进程撤销原语">进程撤销原语</h3><p><strong>Destroy</strong></p><ul><li>释放资源：<ul><li>释放内外存空间</li><li>关闭所有打开文件</li><li>释放共享内存段和各种锁定lock</li></ul></li></ul><h3 id="进程阻塞原语">进程阻塞原语</h3><p><strong>Block</strong></p><ul><li>阻塞原因：当进程期待的某事件尚未出现时，该进程调用阻塞原语把自己阻塞起来</li><li>进程的阻塞是进程自身的一种主动行为</li></ul><h3 id="进程唤醒原语">进程唤醒原语</h3><p><strong>Wakeup</strong></p><ul><li>唤醒原因：<ul><li>进程等待的事件发生，等待队列中的进程唤醒。</li></ul></li><li>唤醒进程的两种方法：<ul><li><strong>由系统进程唤醒</strong>: 系统进程统一控制事件的发生，并将“事件发生”这一消息通知等待进程。等待的是公共资源。</li><li><strong>由事件发生进程唤醒</strong>: 事件发生进程与被唤醒的进程是合作关系，等待私有资源。</li></ul></li></ul><h3 id="进程挂起原语">进程挂起原语</h3><p><strong>Suspend</strong></p><ul><li>引起进程挂起的事件:<ul><li>用户进程请求将自己挂起;</li><li>或父进程请求将自己的某个子进程挂起，</li><li>系统将利用挂起原语suspend( )将指定进程或处于阻塞状态的进程挂起。</li></ul></li></ul><h3 id="进程激活原语">进程激活原语</h3><p><strong>Active</strong></p><ul><li>进程的激活过程<ul><li>系统将利用激活原语active( )将指定进程激活。 激活原语先将进程从外存调入内存，检查该进程的现行状态，若是就绪挂起，便将之改为活动就绪；若为阻塞挂起便将之改为活动阻塞。</li></ul></li></ul><h1>进程同步</h1><h2 id="1-一组并发进程执行时存在两种相互制约关系：">1.一组并发进程执行时存在两种相互制约关系：</h2><ul><li><strong>进程互斥</strong> (打印机)<ul><li><strong>资源共享关系</strong>（间接相互制约关系）</li><li>进程本身之间<strong>不存在直接联系</strong>。</li><li>例如:在仅有一台打印机的系统中，有两个进程A和B，如果在A进程提出打印请求时，系统已将打印机分配给进程B，则系统让A进程等待，直至B将打印机用完并释放后，系统才将打印机分配给进程A。</li></ul></li><li><strong>进程同步</strong> (接力棒)<ul><li><strong>相互合作关系</strong>（直接相互制约关系）</li><li>进程本身之间<strong>存在着相互制约的关系</strong>。</li><li>例如：有一输入进程A通过单缓冲向进程B提供数据。当该缓冲空时，计算进程B因不能获得所需数据而等待。当进程A把数据送入缓冲时，便应向进程B发送一信号，将它唤醒</li></ul></li></ul><h2 id="2-临界资源">2.临界资源</h2><ul><li>临界资源: 在一段时间内只允许<strong>一个进程访问</strong>的资源。诸进程间应采取<strong>互斥方式</strong>，实现对资源的共享。</li><li>共享变量，打印机 等均属于此类资源。</li></ul><h2 id="3-临界区">3.临界区</h2><h3 id="临界区的定义与进入">临界区的定义与进入</h3><ul><li><strong>临界区</strong>(critical section)：<br>在每个进程中访问临界资源的那段代码</li><li><strong>进入区</strong>：<br>在临界区前面增加一段用于进行临界资源检查的代码</li><li><strong>退出区</strong>：<br>将临界区正被访问的标志恢复为未被访问的标志。</li><li><strong>剩余区</strong>：其余部分。</li></ul><h3 id="使用临界区遵循的原则">使用临界区遵循的原则</h3><ul><li><strong>空闲则入</strong>：其他进程均不处于临界区；</li><li><strong>忙则等待</strong>：已有进程处于其临界区；</li><li><strong>有限等待</strong>：等待进入临界区的进程不能&quot;死等&quot;；</li><li><strong>让权等待</strong>：不能进入临界区的进程，应释放CPU(如转换到阻塞状态)</li></ul><h3 id="解决诸进程互斥进入临界区的方法">解决诸进程互斥进入临界区的方法</h3><ul><li>硬件同步机制</li><li>软件同步机制</li></ul><h2 id="4-硬件同步机制">4.硬件同步机制</h2><p>目的：解决诸进程互斥进入临界区。<br>目前许多计算机已提供了一些特殊的硬件指令来解决临界区问题。</p><ul><li>关中断；<ul><li>关中断是实现互斥的最简单的方法之一。在进入锁测试之前关闭中断，直到完成锁测试并上锁之后才能打开中断。</li><li>关中断的方法存在许多缺点：<ul><li>滥用关中断权力可能导致严重后果；</li><li>关中断时间过长，会影响系统效率，限制了处理器交叉执行程序的能力；</li><li>关中断方法也不适用于多CPU 系统，因为在一个处理器上关中断并不能防止进程在其它处理器上执行相同的临界段代码。</li></ul></li></ul></li><li>利用Test-and-Set指令实现互斥；</li><li>利用Swap指令实现进程互斥；</li></ul><h2 id="5-软件同步机制-进程互斥的软件方法">5.软件同步机制(进程互斥的软件方法)</h2><h3 id="利用信号量机制实现进程互斥">利用信号量机制实现进程互斥</h3><h2 id="6-管程-monitor">6.管程(monitor)</h2><h1>进程通信及线程</h1><h1>处理机调度与死锁–完成进程状态的转换</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;进程的描述与控制&lt;/h1&gt;
&lt;h2 id=&quot;程序的顺序执行及其特征&quot;&gt;程序的顺序执行及其特征&lt;/h2&gt;
&lt;p&gt;程序顺序执行时的特征:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;顺序性&lt;/strong&gt;: 按照程序结构所指定的次序&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;封闭性&lt;</summary>
      
    
    
    
    <category term="操作系统" scheme="https://escapeey.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="操作系统" scheme="https://escapeey.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>OS-概述</title>
    <link href="https://escapeey.github.io/post/e50618fb.html"/>
    <id>https://escapeey.github.io/post/e50618fb.html</id>
    <published>2024-01-05T16:40:21.000Z</published>
    <updated>2024-04-03T04:37:57.880Z</updated>
    
    <content type="html"><![CDATA[<h1>操作系统定义</h1><p><strong>操作系统</strong>：是管理计算机系统资源、控制程序执行、改善人机界面和为应用软件提供支持的一种系统<font color=red>软件</font>。</p><h2 id="多道程序设计：">多道程序设计：</h2><p>现代操作系统一般都采用多道程序设计技术，其基本思想是在主存中同时存放多个用户的作业，使之同时处于运行状态而共享系统资源。</p><p>多道程序设计——多个程序同时进入主存并发执行。</p><h1>操作系统的作用</h1><h2 id="OS作为用户与计算机硬件系统之间的接口">OS作为用户与计算机硬件系统之间的接口</h2><ul><li>OS是一个系统软件，因而这种接口是<strong>软件接口</strong>。</li></ul><h2 id="OS作为计算机系统资源的管理者">OS作为计算机系统资源的管理者</h2><p>OS的<strong>主要功能</strong>为:</p><ul><li><strong>处理机管理</strong>：用于分配和控制处理机；</li><li><strong>存储器管理</strong>：主要负责内存的分配与回收；</li><li><strong>I/O设备管理</strong>：负责I/O设备的分配与操纵；</li><li><strong>文件管理</strong>：负责文件的存取、共享和保护。可见，OS确是计算机系统资源的管理者。</li></ul><h2 id="OS实现了对计算机资源的抽象">OS实现了对计算机资源的抽象</h2><ul><li>通常把覆盖了软件的机器称为扩充机器或虚机器。</li></ul><h1>操作系统的基本特性</h1><h2 id="并发">并发</h2><ul><li><strong>并行性</strong>：指两个或多个事件在同一时刻发生</li><li><strong>并发性</strong>：指两个或多个事件在同一时间间隔内发生<ul><li>在多道程序环境下，并发性是指在一段时间内，宏观上有多个程序在同时运行，但在单处理机系统中，每一时刻却仅能有一道程序执行，故微观上这些程序只能是分时地交替执行。</li></ul></li></ul><h2 id="共享">共享</h2><ul><li><strong>共享</strong>的概念：指系统中的资源，可供内存中多个并发执行的进程(线程)共同使用 。</li><li>进程对资源共享的方式：<ul><li><strong>互斥共享</strong>：当某一进程访问完并释放该资源后，才允许另一进程进行访问。这种资源称为<font color=red>临界资源</font>或独占资源,如打印机；</li><li><strong>同时共享</strong>：允许在一段时间内由多个进程同时访问，如磁盘设备</li></ul></li></ul><h2 id="虚拟">虚拟</h2><h3 id="定义">定义</h3><ul><li>操作系统中的所谓“<strong>虚拟</strong>”，是指通过某种技术把一个物理实体变为若干个逻辑上的对应物。</li><li>在OS中利用了多种虚拟技术，分别用来实现虚拟处理机、虚拟内存(设置：我的电脑、属性、高级、性能选项)、 虚拟外部设备(虚拟光驱、盘符D：等)和虚拟信道等。</li></ul><h3 id="OS中采用的2种虚拟技术">OS中采用的2种虚拟技术</h3><ul><li><strong>时分复用技术</strong> -多设备分时使用物理设备<ul><li>利用该技术可以实现虚拟处理机、虚拟设备等，以<strong>提高资源利用率</strong>。</li><li>虚拟处理机：是通过多道程序设计技术，让多道程序并发执行的方法，来分时使用一台处理机的。</li><li>虚拟设备技术：将一台物理I/O设备虚拟为多台逻辑上的I/O设备。 如虚拟打印机。</li></ul></li><li><strong>空分复用技术</strong><ul><li>利用该技术可以实现虚拟磁盘技术、虚拟存储器技术等，以<strong>提高存储空间利用率</strong>。</li><li>虚拟磁盘技术：一个硬盘划分为1、2、3、4四个卷，分别安装在C、D、E、F四个逻辑驱动器上，成为四个虚拟磁盘。</li><li>虚拟存储器技术：一个100M的程序可以运行在20M的内存空间</li></ul></li></ul><h2 id="异步性">异步性</h2><ul><li>在多道程序环境下，允许多个进程并发执行。使进程的执行是以“走走停停”的方式运行；</li><li><strong>进程的异步性</strong>: 每个程序在何时执行，多个程序间的执行顺序以及完成每道程序所需的时间都是不确定和不可预知的。进程是以人们不可预知的速度向前推进</li></ul><h1>操作系统结构设计</h1><ul><li>第一代：无结构OS；</li><li>第二代：模块化结构OS；</li><li>分层式操作系统；</li></ul><h2 id="模块化结构OS">模块化结构OS</h2><ul><li>模块之间直接调用函数，除了函数调用的开销外，没有额外开销</li><li>庞大的操作系统有数以千计的函数</li></ul><h2 id="微内核-Micro-Kelnel-结构OS-现代结构">微内核(Micro Kelnel)结构OS -现代结构</h2><h3 id="微内核技术">微内核技术</h3><ul><li><p><strong>微内核技术</strong>: 指精心设计的、能实现现代OS核心功能的小型内核，它与一般的OS(程序)不同，它更小更精炼，它不仅运行在核心态，而且<strong>开机后常驻内存</strong>。</p></li><li><p>微内核<strong>并非</strong>是一个完整的OS， 而只是为构建通用OS提供一个重要基础。在微内核OS结构中，通常都采用了<strong>客户/服务器模式</strong>。<br><img src="..\..\img\OS\os微内核.png" width="50%" height="70%" align="middle"></p></li><li><p><strong>优缺点</strong></p><ul><li>内核与各个服务器之间通过通信机制进行交互，这使得微内核结构的效率大打折扣</li><li>因为各个服务器模块的相对独立性，使得其维护相对容易。</li></ul></li></ul><h3 id="客户-服务器模式">客户/服务器模式</h3><p>客户/服务器系统主要由<strong>客户机</strong>、<strong>服务器</strong>和<strong>网络系统</strong>三个部分组成。</p><ul><li>客户机：平时处理本地业务，也可发送一个消息给服务器，以请求某项服务</li><li>服务器：通常是一台规模较大的机器，在其上驻留有网络文件系统或数据库系统等，为用户提供多种服务。</li></ul><h3 id="面向对象的程序设计技术">面向对象的程序设计技术</h3><ul><li>在OS中的各类实体如进程、线程、消息、存储器和文件等，都使用了对象这一概念，相应地，便有了进程对象、线程对象、存储器对象和文件对象等</li><li>操作系统是一个极其复杂的大型软件系统，面向对象技术被广泛应用于现代操作系统的设计中。</li></ul><h3 id="微内核的基本功能">微内核的基本功能</h3><p>通常都是一些最基本的功能：</p><ul><li>进程(线程)管理。</li><li>低级存储器管理。</li><li>中断和陷入处理。<br>将OS中<strong>最基本</strong>的部分放入内核中，而把OS的<strong>绝大部分功能</strong>放在微内核**外面的一组服务器（进程）**中实现。</li></ul><h3 id="微内核操作系统存在的问题">微内核操作系统存在的问题</h3><p>微内核OS的<strong>运行效率有所降低：</strong><br>会引起更多的上下文切换。例如某个服务器自身尚无能力完成客户请求，而需其它服务器帮助时，如图1-11中所示，其中的文件服务器还需要磁盘服务器的帮助，这时就需要进行八次上下文的切换。<br><img src="..\..\img\OS\os微内核缺点.png" width="50%" height="70%" align="middle"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;操作系统定义&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;操作系统&lt;/strong&gt;：是管理计算机系统资源、控制程序执行、改善人机界面和为应用软件提供支持的一种系统&lt;font color=red&gt;软件&lt;/font&gt;。&lt;/p&gt;
&lt;h2 id=&quot;多道程序设计：&quot;&gt;多道程序设计：&lt;/h2&gt;</summary>
      
    
    
    
    <category term="操作系统" scheme="https://escapeey.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="操作系统" scheme="https://escapeey.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>深度学习-梯度下降</title>
    <link href="https://escapeey.github.io/post/33115a55.html"/>
    <id>https://escapeey.github.io/post/33115a55.html</id>
    <published>2023-12-31T18:49:30.000Z</published>
    <updated>2024-04-03T04:37:57.880Z</updated>
    
    <content type="html"><![CDATA[<h1>反向传播算法</h1><img src="../../img/DeepLearning/bp推导.jpg" width="70%" height="70%" align="middle"><h1>梯度下降及其变体</h1><h2 id="批量梯度下降">批量梯度下降</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">do_gradient_descent</span>():</span><br><span class="line">    w,b,eta,max_epochs = -<span class="number">2</span>,-<span class="number">2</span>,<span class="number">1.0</span>,<span class="number">1000</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(max_epochs):</span><br><span class="line">        dw,db = <span class="number">0</span>,<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> x,y <span class="keyword">in</span> <span class="built_in">zip</span>(X,Y):</span><br><span class="line">            dw += grad_w(w,b,x,y)</span><br><span class="line">            db += grad_b(w,b,x,y)</span><br><span class="line">        w -= eta*dw</span><br><span class="line">        b -= eta*db</span><br></pre></td></tr></table></figure><h2 id="SGD">SGD</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">do_stochastic_gradient_descent</span>():</span><br><span class="line">w,b,eta,max_epochs = -<span class="number">2</span>,-<span class="number">2</span>,<span class="number">1.0</span>,<span class="number">1000</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(max_epochs):</span><br><span class="line">        dw,db = <span class="number">0</span>,<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> x,y <span class="keyword">in</span> <span class="built_in">zip</span>(X,Y):</span><br><span class="line">            dw = grad_w(w,b,x,y)</span><br><span class="line">            db = grad_b(w,b,x,y)</span><br><span class="line">            w -= eta*dw</span><br><span class="line">            b -= eta*db</span><br></pre></td></tr></table></figure><h2 id="MiniBatch">MiniBatch</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">do_mini_batch_gradient_descent</span>():</span><br><span class="line">    w,b,eta = -<span class="number">2</span>,-<span class="number">2</span>,<span class="number">1.0</span></span><br><span class="line">    mini_batch_size,num_points_seen = <span class="number">2</span>,<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(max_epochs):</span><br><span class="line">        dw,db,num_points = <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> x,y <span class="keyword">in</span> <span class="built_in">zip</span>(X,Y):</span><br><span class="line">            dw += grad_w(w,b,x,y)</span><br><span class="line">            db += grad_b(w,b,x,y)</span><br><span class="line">            num_points_seen += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> num_points_seen%mini_batch_size == <span class="number">0</span>:</span><br><span class="line">                w -= eta*dw</span><br><span class="line">                b -= eta*db</span><br><span class="line">                dw,db = <span class="number">0</span>,<span class="number">0</span></span><br></pre></td></tr></table></figure><h2 id="Momentum">Momentum</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">do_momentum_gradient_descent</span>():</span><br><span class="line">    w,b,eta = init_w,init_b,<span class="number">1.0</span></span><br><span class="line">    prev_v_w,prev_v_b,gamma = <span class="number">0</span>,<span class="number">0</span>,<span class="number">0.9</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(max_epochs):</span><br><span class="line">        dw,db = <span class="number">0</span>,<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> x,y <span class="keyword">in</span> <span class="built_in">zip</span>(X,Y):</span><br><span class="line">            dw += grad_w(w,b,x,y)</span><br><span class="line">            db += grad_b(w,b,x,y)</span><br><span class="line">        v_w = gamma * prev_v_w + eta*dw</span><br><span class="line">        v_b = gamma * prev_v_b + eta*db</span><br><span class="line">        w -= v_w</span><br><span class="line">        b -= v_b</span><br><span class="line">        prev_v_w = v_w</span><br><span class="line">        prev_v_b = v_b</span><br></pre></td></tr></table></figure><h2 id="NAGD">NAGD</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">do_nesterov_accelerated_gradient_descent</span>():</span><br><span class="line">    w,b,eta = init_w,init_b,<span class="number">1.0</span></span><br><span class="line">    prev_v_w,prev_v_b,gamma = <span class="number">0</span>,<span class="number">0</span>,<span class="number">0.9</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(max_epochs):</span><br><span class="line">        dw,db=<span class="number">0</span>,<span class="number">0</span></span><br><span class="line">       v_w = gamma * prev_v_w</span><br><span class="line">        v_b = gamma * prev_v_b</span><br><span class="line">        <span class="keyword">for</span> x,y <span class="keyword">in</span> <span class="built_in">zip</span>(X,Y):</span><br><span class="line">            dw += grad_w(w-v_w,b-v_b,x,y)</span><br><span class="line">            db += grad_b(w-v_w,b-v_b,x,y)</span><br><span class="line">        v_w = gamma*prev_v_w + eta*dw</span><br><span class="line">        v_b = gamma*prev_v_b + eta*db</span><br><span class="line">        w -= v_w</span><br><span class="line">        b -= v_b</span><br><span class="line">        prev_v_w = v_w</span><br><span class="line">        prev_v_b = v_b</span><br></pre></td></tr></table></figure><h2 id="Adagrad">Adagrad</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">do_adagrad</span>():</span><br><span class="line">    w,b,eta = init_w,init_b,<span class="number">0.1</span></span><br><span class="line">    v_w,v_b,eps = <span class="number">0</span>,<span class="number">0</span>,<span class="number">1e-8</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(max_epochs):</span><br><span class="line">        dw,db = <span class="number">0</span>,<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> x,y <span class="keyword">in</span> <span class="built_in">zip</span>(X,Y):</span><br><span class="line">            dw += grad_w(w,b,x,y)</span><br><span class="line">            db += grad_b(w,b,x,y)</span><br><span class="line">        v_w += dw**<span class="number">2</span></span><br><span class="line">        v_b += db**<span class="number">2</span></span><br><span class="line">        w -= (eta/np.sqrt(v_w+eps)) * dw</span><br><span class="line">        b -= (eta/np.sqrt(v_b+eps)) * db</span><br></pre></td></tr></table></figure><h2 id="RMSProp">RMSProp</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">do_rmsprop</span>():</span><br><span class="line">    w,b,eta = init_w,init_b,<span class="number">0</span>,<span class="number">1</span></span><br><span class="line">    v_w,v_b,eps,beta1 = <span class="number">0</span>,<span class="number">0</span>,<span class="number">1e-8</span>,<span class="number">0.9</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(max_epochs):</span><br><span class="line">        dw,db = <span class="number">0</span>,<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> x,y <span class="keyword">in</span> <span class="built_in">zip</span>(X,Y):</span><br><span class="line">            dw += grad_w(w,b,x,y)</span><br><span class="line">            db += grad_b(w,b,x,y)</span><br><span class="line">        v_w = beta1*v_w + (<span class="number">1</span>-beta1) * dw**<span class="number">2</span></span><br><span class="line">        v_b = beta1*v_b + (<span class="number">1</span>-beta1) * db**<span class="number">2</span></span><br><span class="line">        w -= (eta / np.sqrt(v_w+eps)) * dw</span><br><span class="line">        b -= (eta / np.sqrt(v_b+eps)) * db</span><br></pre></td></tr></table></figure><h2 id="Adam">Adam</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">do_adam</span>():</span><br><span class="line">    w,b,eta = init_w,init_b,<span class="number">0.1</span></span><br><span class="line">    m_w,m_b,v_w,v_b,m_w_hat,m_b_hat,v_w_hat,v_b_hat,eps,beta1,beta2 = <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1e-8</span>,<span class="number">0.9</span>,<span class="number">0.999</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(max_epochs):</span><br><span class="line">        dw,db = <span class="number">0</span>,<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> x,y <span class="keyword">in</span> <span class="built_in">zip</span>(X,Y):</span><br><span class="line">            dw += grad_w(w,b,x,y)</span><br><span class="line">            db += grad_b(w,b,x,y)</span><br><span class="line">        m_w = beta1*m_w + (<span class="number">1</span>-beta1) * dw</span><br><span class="line">        m_b = beta1*m_b + (<span class="number">1</span>-beta1) * db</span><br><span class="line">        v_w = beta2*v_w + (<span class="number">1</span>-beta2) * dw**<span class="number">2</span></span><br><span class="line">        v_b = beta2*v_b + (<span class="number">1</span>-beta2) * db**<span class="number">2</span></span><br><span class="line">        m_w_hat = m_w / (<span class="number">1</span>-math.<span class="built_in">pow</span>(beta1, i+<span class="number">1</span>))</span><br><span class="line">        m_b_hat = m_b / (<span class="number">1</span>-math.<span class="built_in">pow</span>(beta1, i+<span class="number">1</span>))</span><br><span class="line">        v_w_hat = v_w / (<span class="number">1</span>-math.<span class="built_in">pow</span>(beta2, i+<span class="number">1</span>))</span><br><span class="line">        v_b_hat = v_b / (<span class="number">1</span>-math.<span class="built_in">pow</span>(beta2, i+<span class="number">1</span>))</span><br><span class="line">        w -= (eta / np.sqrt(v_w_hat+eps)) * m_w_hat</span><br><span class="line">        b -= (eta / np.sqrt(v_b_hat+eps)) * m_b_hat</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;反向传播算法&lt;/h1&gt;
&lt;img src=&quot;../../img/DeepLearning/bp推导.jpg&quot; width=&quot;70%&quot; height=&quot;70%&quot; align=&quot;middle&quot;&gt;
&lt;h1&gt;梯度下降及其变体&lt;/h1&gt;
&lt;h2 id=&quot;批量梯度下降&quot;&gt;批量梯度下降</summary>
      
    
    
    
    
    <category term="深度学习" scheme="https://escapeey.github.io/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Unity-NGUI之三大基础组件</title>
    <link href="https://escapeey.github.io/post/b9d856e4.html"/>
    <id>https://escapeey.github.io/post/b9d856e4.html</id>
    <published>2023-12-30T10:48:47.000Z</published>
    <updated>2024-04-03T04:37:57.884Z</updated>
    
    <content type="html"><![CDATA[<h1>NGUI概述</h1><p>NGUI全称 下一代用户界面（Next-Gen UI）<br>它是第三方提供的Unity付费插件<br>专门用于制作Unity中游戏UI的第三方工具<br>相对于GUI它更适用于制作游戏UI功能<br>更方便使用，性能和效率更高</p><h1>Root组件</h1><h2 id="作用">作用</h2><ul><li>Root是用于 <strong>分辨率自适应</strong> 的 根对象</li><li>可以设置 基本分辨率,相当于设置 UI显示区域</li><li>并且管理所有UI控件的 分辨率自适应<br>可以简单理解 它管理一个 UI画布 所有的UI都是显示在这个画布上的<br>它会管理 UI画布 和 不同屏幕分辨率的 适应关系</li></ul><h2 id="Root参数相关">Root参数相关</h2><p>主要包含三种缩放模式</p><ol><li><p><strong>Flexible</strong> 适用于可以手动拖窗口改变分辨率的设备 比如pc端</p></li><li><p><strong>Constrained</strong> 适用于移动设备<br>因为移动设备都是全屏应用 不会频繁改变分辨率 只用适配不同分辨率的设备<br>一般使用：<strong>横屏勾选 高fit</strong> ; <strong>竖屏勾选 宽fit</strong><br>需要注意的是: <strong>背景图</strong> 一定要考虑 <strong>极限宽高比</strong>来出 <strong>最大宽高比</strong>  19.9:9</p></li><li><p><strong>Constrained On Mobiles</strong> 是上面两者的综合体 适用于多平台发布的游戏和应用</p></li></ol><img src="../../../img/Unity/NGUI_Root_缩放模式设置.bmp" width="70%" height="50%"><h1>Panel组件</h1><h2 id="作用-2">作用</h2><ul><li>管理一个UI面板的渲染顺序</li><li>管理一个UI面板上的所有子控件</li></ul><p><strong>tips</strong>:</p><ol><li>在Root下创建多个Panel对象(挂载着Panel组件的空对象), <strong>设置不同的depth</strong>, 一般一个Panel管理一个面板, 可以理解为 Panel的depth 控制 Panel与Panel之间的层级关系，<strong>类似于文件夹</strong></li><li>同一Panel下的对象通过<strong>自身的widget中的depth</strong>来控制在<strong>当前Panel下</strong>的层级，<strong>类似于文件夹中的文件</strong></li><li>没有Panel父对象 UI控件看不到</li></ol><h2 id="Panel参数相关">Panel参数相关</h2><img src="../../../img/Unity/NGUI_Panel参数.bmp" width="70%" height="50%"><h1>EventSystem组件</h1><p>也称为 <strong>UICamera</strong></p><h2 id="作用-3">作用</h2><p>主要作用是让摄像机渲染出来的物体 能接收到NGUI的<strong>输入事件</strong><br>大部分设置不需要我们去修改<br>有了它我们通过鼠标 触碰 键盘 控制器 操作UI 响应玩家的输入</p><p><strong>tips</strong>:</p><ol><li>EventSystem很重要，如果没有它，我们没有办法监听玩家输入</li><li>创建UI时的 2DUI 和3DUI 主要就是<strong>摄像机的模式</strong> (正交或透视) 不一样</li><li>EventSystem的2D和3D主要是 采用2D<strong>碰撞器</strong> 还是3D碰撞器, <strong>不能直接改变摄像机模式</strong></li></ol><h2 id="EventSystem参数相关">EventSystem参数相关</h2><img src="../../../img/Unity/NGUI_EventSystem参数1.bmp" width="70%" height="50%"><img src="../../../img/Unity/NGUI_EventSystem参数2.bmp" width="50%" height="50%"><h1>图集 Atlas</h1><h2 id="图集作用">图集作用</h2><p>NGUI中的最小图片控件<strong>Sprite</strong>要使用图集中的图片进行显示<br>图集 就是把很多单独的小图 合并为 一张大图 合并后的大图就是图集<br><strong>目的</strong>：提高渲染性能</p><h2 id="打开图集制作工具">打开图集制作工具</h2><ul><li>方法一：<strong>Project</strong>右键打开</li><li>方法二：上方工具栏<strong>NGUI——Open——Atlas Maker</strong></li></ul><h2 id="图集关键文件">图集关键文件</h2><ol><li>图集文件 (配置文件,包含小图在图集中的位置等信息)</li><li>图集材质球</li><li>图集图片</li></ol><h2 id="新建图集-及-创建修改删除图集元素">新建图集 及 创建修改删除图集元素</h2><ul><li>在图集工具<strong>Atlas Maker</strong>中操作</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;NGUI概述&lt;/h1&gt;
&lt;p&gt;NGUI全称 下一代用户界面（Next-Gen UI）&lt;br&gt;
它是第三方提供的Unity付费插件&lt;br&gt;
专门用于制作Unity中游戏UI的第三方工具&lt;br&gt;
相对于GUI它更适用于制作游戏UI功能&lt;br&gt;
更方便使用，性能和效率更高&lt;/p</summary>
      
    
    
    
    <category term="Unity" scheme="https://escapeey.github.io/categories/Unity/"/>
    
    
    <category term="C#" scheme="https://escapeey.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>形式语言与自动机</title>
    <link href="https://escapeey.github.io/post/b01f06ff.html"/>
    <id>https://escapeey.github.io/post/b01f06ff.html</id>
    <published>2023-12-28T11:22:09.000Z</published>
    <updated>2024-04-03T04:37:57.884Z</updated>
    
    <content type="html"><![CDATA[<h1>前言</h1><ul><li>形式语言理论：<font color="red">乔姆斯基发现文法</font>，用<strong>文法产生语言</strong>的每个句子。</li><li>自动机理论：<font color="red">克林建立了有穷状态自动机</font>,为识别语言的系统</li><li>文法与自动机是<strong>等价</strong>的</li><li>文法与自动机的运算对象：<strong>集合</strong></li></ul><img src="..\img\FL&FA\5方转换图.png" width="70%" height="70%" align="middle"><h1>文法</h1><h2 id="文法构造">文法构造</h2><ul><li><p>例1<br><img src="..\img\FL&FA\文法例1.png" width="40%" height="70%" align="middle"></p></li><li><p>例2<br><img src="..\img\FL&FA\文法例2.png" width="70%" height="70%" align="middle"></p></li><li><p>例3<br><img src="..\img\FL&FA\文法例3.png" width="70%" height="70%" align="middle"></p></li><li><p>例4<br><img src="..\img\FL&FA\文法例4.png" width="70%" height="70%" align="middle"><br><img src="..\img\FL&FA\文法例4_1.png" width="70%" height="70%" align="middle"></p></li><li><p>例5<br><img src="..\img\FL&FA\文法例5.png" width="70%" height="70%" align="middle"></p></li><li><p>例6<br><img src="..\img\FL&FA\文法例6_1.png" width="70%" height="70%" align="middle"><br><img src="..\img\FL&FA\文法例6_2.png" width="40%" height="70%" align="middle"></p></li></ul><h2 id="文法分类">文法分类</h2><ul><li><p>标准<br><img src="..\img\FL&FA\文法分类.png" width="70%" height="70%" align="middle"><br><img src="..\img\FL&FA\文法分类定义.png" width="70%" height="70%" align="middle"></p></li><li><p>例子<br><img src="..\img\FL&FA\文法分类例子.png" width="70%" height="70%" align="middle"></p></li></ul><h1>线性文法与FA的转换</h1><h2 id="右线性文法">右线性文法</h2><h3 id="FA-文法">FA -&gt; 文法</h3><img src="..\img\FL&FA\FA转右线性文法.png" width="70%" height="70%" align="middle"><h3 id="文法-FA">文法 -&gt; FA</h3><img src="..\img\FL&FA\右线性文法转FA.png" width="70%" height="70%" align="middle"><h2 id="左线性文法">左线性文法</h2><h3 id="FA-文法-2">FA -&gt; 文法</h3><ul><li><p>先预处理<br><img src="..\img\FL&FA\FA转左线性文法_预处理.png" width="70%" height="70%" align="middle"></p></li><li><p>规则：<br><img src="..\img\FL&FA\FA转左线性文法_规则.png" width="70%" height="70%" align="middle"></p></li><li><p>例子<br><img src="..\img\FL&FA\FA转左线性文法_例子.png" width="70%" height="70%" align="middle"></p></li></ul><h3 id="文法-FA-2">文法 -&gt; FA</h3><ul><li><p>规则<br><img src="..\img\FL&FA\左线性文法转FA_规则.png" width="70%" height="70%" align="middle"></p></li><li><p>例子<br><img src="..\img\FL&FA\左线性文法转FA_例子.png" width="70%" height="70%" align="middle"></p></li></ul><h1>DFA、NFA、ε-NFA转换</h1><h2 id="ε-NFA-NFA">ε-NFA -&gt; NFA</h2><h3 id="前置知识">前置知识</h3><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϵ</mi><mo>−</mo><mi>C</mi><mi>L</mi><mi>O</mi><mi>S</mi><mi>U</mi><mi>R</mi><mi>E</mi><mo stretchy="false">(</mo><msub><mi>q</mi><mn>0</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\epsilon-CLOSURE(q_0)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">ϵ</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord mathnormal">L</span><span class="mord mathnormal" style="margin-right:0.05764em;">OS</span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="mord mathnormal" style="margin-right:0.05764em;">RE</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> = { p | 从<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>q</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">q_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span></span></span></span>有一条标记为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">ϵ</span></span></span></span> 的路}</li><li>ε-NFA 的 状态转移函数<br><img src="..\img\FL&FA\epsilonNFA的状态转移函数.png" width="70%" height="70%" align="middle"></li></ul><h3 id="转换过程">转换过程</h3><ul><li><p>终止状态<br>F 为 ε-NFA 的<br>F2 为转化后NFA的<br><img src="..\img\FL&FA\epsilonNFA转NFA_终止状态.png" width="70%" height="70%" align="middle"></p></li><li><p>转化后NFA的 转移函数</p><ul><li>为 去除 <font color='red'>ε列</font> 的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>δ</mi><mo>^</mo></mover></mrow><annotation encoding="application/x-tex">\hat\delta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9579em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9579em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal" style="margin-right:0.03785em;">δ</span></span><span style="top:-3.2634em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.1944em;"><span class="mord">^</span></span></span></span></span></span></span></span></span></span></li></ul></li></ul><h3 id="例子">例子</h3><img src="..\img\FL&FA\epsilonNFA转NFA_例子0.png" width="70%" height="70%" align="middle"><img src="..\img\FL&FA\epsilonNFA转NFA_例子1.png" width="70%" height="70%" align="middle"><h2 id="NFA-DFA">NFA -&gt; DFA</h2><ul><li>带 NFA 中 终止状态 的 状态簇 为 新DFA 的终止状态</li><li>例子<br><img src="..\img\FL&FA\NFA转DFA_例子0.png" width="70%" height="70%" align="middle"><br><img src="..\img\FL&FA\NFA转DFA_例子1.png" width="70%" height="70%" align="middle"><br><img src="..\img\FL&FA\NFA转DFA_例子2.png" width="70%" height="70%" align="middle"></li></ul><h1>FA 与 RE 的转化</h1><h2 id="RE-ε-NFA">RE -&gt; ε-NFA</h2><ul><li><p>n = 0<br><img src="..\img\FL&FA\RE转NFA_0.png" width="70%" height="70%" align="middle"></p></li><li><p>n = k+1<br><img src="..\img\FL&FA\RE转NFA_1.png" width="60%" height="70%" align="middle"><br><img src="..\img\FL&FA\RE转NFA_2.png" width="60%" height="70%" align="middle"><br><img src="..\img\FL&FA\RE转NFA_3.png" width="60%" height="70%" align="middle"></p></li><li><p>例子<br><img src="..\img\FL&FA\RE转NFA_例子.png" width="60%" height="70%" align="middle"></p></li></ul><h2 id="DFA-RE">DFA -&gt; RE</h2><h3 id="例子-2">例子</h3><img src="..\img\FL&FA\DFA转RE_例子.png" width="60%" height="70%" align="middle"><ul><li><p>预处理：</p><ul><li>用标记为X和Y的状态将M“括起来”：<br>在状态转移图中增加标记为X和Y的状态, 从标记为X的状态到标记为q0的状态引一条标记为ε的弧；<br>从标记为q(q∈F)的状态到标记为Y的状态分别引一条标记为ε的弧。</li><li>去掉所有的不可达状态。<br><img src="..\img\FL&FA\DFA转RE_预处理.png" width="70%" height="70%" align="middle"></li></ul></li><li><p>去掉状态q3：<br><img src="..\img\FL&FA\DFA转RE_例子0.png" width="70%" height="70%" align="middle"></p></li><li><p>去掉状态q4<br><img src="..\img\FL&FA\DFA转RE_例子1.png" width="70%" height="70%" align="middle"></p></li><li><p>合并从标记为q2的状态到标记为Y的状态的两条并行弧。<br><img src="..\img\FL&FA\DFA转RE_例子2.png" width="70%" height="70%" align="middle"></p></li><li><p>去掉状态q0<br><img src="..\img\FL&FA\DFA转RE_例子3.png" width="70%" height="70%" align="middle"></p></li><li><p>并弧<br><img src="..\img\FL&FA\DFA转RE_例子4.png" width="70%" height="70%" align="middle"></p></li><li><p>去掉状态q1<br><img src="..\img\FL&FA\DFA转RE_例子5.png" width="70%" height="70%" align="middle"></p></li><li><p>去掉状态q2<br><img src="..\img\FL&FA\DFA转RE_例子6.png" width="70%" height="70%" align="middle"></p></li></ul><h3 id="注意事项">注意事项</h3><ul><li>不计算自身到自身的弧,如果状态q的入度为n,出度为m,则将状态q及其相关的弧去掉之后,需要添加n*m条新弧。</li></ul><h1>泵引理 与 封闭性</h1><h2 id="泵引理">泵引理</h2><h3 id="定理">定理</h3><img src="..\img\FL&FA\泵引理_定理.png" width="70%" height="70%" align="middle"><h3 id="应用">应用</h3><ul><li><p>例1<br><img src="..\img\FL&FA\泵引理_例1.png" width="70%" height="70%" align="middle"></p></li><li><p>例2<br><img src="..\img\FL&FA\泵引理_例2.png" width="70%" height="70%" align="middle"></p></li><li><p>例3<br><img src="..\img\FL&FA\泵引理_例3.png" width="70%" height="70%" align="middle"></p></li><li><p>例4<br><img src="..\img\FL&FA\泵引理_例4.png" width="70%" height="70%" align="middle"></p></li></ul><h2 id="封闭性">封闭性</h2><h3 id="定义">定义</h3><p><font color='red'>交、并、补、连接、闭包、反转、同态、逆同态 运算都具有封闭性</font></p><ul><li><p>补运算的封闭性<br>如果 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi></mrow><annotation encoding="application/x-tex">L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">L</span></span></span></span> 是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Σ</mi></mrow><annotation encoding="application/x-tex">\Sigma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">Σ</span></span></span></span> 上的RE, 那么 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>L</mi><mo stretchy="true">‾</mo></mover><mo>=</mo><msup><mi mathvariant="normal">Σ</mi><mo lspace="0em" rspace="0em">∗</mo></msup><mo>−</mo><mi>L</mi></mrow><annotation encoding="application/x-tex">\overline{L} = \Sigma^{*} - L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8833em;"></span><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8833em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">L</span></span></span><span style="top:-3.8033em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.772em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">Σ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6887em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">∗</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">L</span></span></span></span> 也是 正则的。</p></li><li><p>交运算的封闭性<br>如果 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi></mrow><annotation encoding="application/x-tex">L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">L</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span> 是 RE, 那么 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo>∩</mo><mi>M</mi></mrow><annotation encoding="application/x-tex">L\cap M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">L</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∩</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span> 也是 正则的。</p></li><li><p>同态 的定义<br><img src="..\img\FL&FA\同态的定义.png" width="70%" height="70%" align="middle"></p></li><li><p>逆同态 的定义<br><img src="..\img\FL&FA\逆同态的定义.png" width="70%" height="70%" align="middle"></p></li></ul><h3 id="例子-3">例子</h3><ul><li><p>例1<br><img src="..\img\FL&FA\封闭性_例1.png" width="70%" height="70%" align="middle"></p></li><li><p>例2<br><img src="..\img\FL&FA\封闭性_例2.png" width="70%" height="70%" align="middle"></p></li><li><p>例3<br><img src="..\img\FL&FA\封闭性_例3.png" width="70%" height="70%" align="middle"></p></li></ul><h1>Myhill-Nerode定理</h1><p>定理规定以下三个命题同时成立:</p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo>⊆</mo><msup><mi mathvariant="normal">Σ</mi><mo>∗</mo></msup></mrow><annotation encoding="application/x-tex">L \subseteq \Sigma^*</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.136em;"></span><span class="mord mathnormal">L</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⊆</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6887em;"></span><span class="mord"><span class="mord">Σ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6887em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span></span></span></span> 是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mi>L</mi></mrow><annotation encoding="application/x-tex">RL</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mord mathnormal">L</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi></mrow><annotation encoding="application/x-tex">L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">L</span></span></span></span> 是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi mathvariant="normal">Σ</mi><mo>∗</mo></msup></mrow><annotation encoding="application/x-tex">\Sigma^*</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6887em;"></span><span class="mord"><span class="mord">Σ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6887em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span></span></span></span>上的某一个具有 <font color='red'>有穷指数</font> 的<font color='red'> 右不变等价关系</font> 的 <font color='red'>并</font></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>R</mi><mi>L</mi></msub></mrow><annotation encoding="application/x-tex">R_L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">L</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>具有有穷指数</li></ul><h2 id="右不变等价关系">右不变等价关系</h2><p><strong>定义</strong>：设<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span>是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi mathvariant="normal">Σ</mi><mo lspace="0em" rspace="0em">∗</mo></msup></mrow><annotation encoding="application/x-tex">\Sigma^{*}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6887em;"></span><span class="mord"><span class="mord">Σ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6887em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">∗</span></span></span></span></span></span></span></span></span></span></span></span>上的等价关系，对于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∀</mi><mrow><mi>x</mi><mo separator="true">,</mo><mi>y</mi></mrow><mo>∈</mo><msup><mi mathvariant="normal">Σ</mi><mo lspace="0em" rspace="0em">∗</mo></msup></mrow><annotation encoding="application/x-tex">\forall{x,y} \in \Sigma^{*}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord">∀</span><span class="mord"><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6887em;"></span><span class="mord"><span class="mord">Σ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6887em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">∗</span></span></span></span></span></span></span></span></span></span></span></span>, 如果<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mi>R</mi><mi>y</mi></mrow><annotation encoding="application/x-tex">xRy</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">x</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span>成立，则<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mi>z</mi><mi>R</mi><mi>y</mi><mi>z</mi></mrow><annotation encoding="application/x-tex">xzRyz</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">x</span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mord mathnormal" style="margin-right:0.04398em;">yz</span></span></span></span>也成立，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>z</mi><mo>∈</mo><msup><mi mathvariant="normal">Σ</mi><mo lspace="0em" rspace="0em">∗</mo></msup></mrow><annotation encoding="application/x-tex">z\in\Sigma^{*}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6887em;"></span><span class="mord"><span class="mord">Σ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6887em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">∗</span></span></span></span></span></span></span></span></span></span></span></span>, 则<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span>被称为 右不变等价关系</p><ul><li>关系<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>R</mi><mi>m</mi></msub></mrow><annotation encoding="application/x-tex">R_m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>R</mi><mi>L</mi></msub></mrow><annotation encoding="application/x-tex">R_L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">L</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>是 右不变等价关系</li></ul><h3 id="关系RM">关系RM</h3><ul><li>设DFA M，M所确定的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi mathvariant="normal">Σ</mi><mo>∗</mo></msup></mrow><annotation encoding="application/x-tex">Σ^*</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6887em;"></span><span class="mord"><span class="mord">Σ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6887em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span></span></span></span>上的关系 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>R</mi><mi>M</mi></msub></mrow><annotation encoding="application/x-tex">R_M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">M</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 定义为：<br>对于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∀</mi><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo>∈</mo><mi mathvariant="normal">Σ</mi><mo>∗</mo></mrow><annotation encoding="application/x-tex">∀x,y∈Σ*</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord">∀</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">Σ</span><span class="mord">∗</span></span></span></span><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><msub><mi>R</mi><mi>M</mi></msub><mi>y</mi><mo>⇔</mo><mi>δ</mi><mo stretchy="false">(</mo><mi>q</mi><mn>0</mn><mo separator="true">,</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>δ</mi><mo stretchy="false">(</mo><mi>q</mi><mn>0</mn><mo separator="true">,</mo><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">x R_M y ⇔ δ(q0,x)=δ(q0,y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">x</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">M</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⇔</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03785em;">δ</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03785em;">δ</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span></li><li>也就是说： <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><msub><mi>R</mi><mi>M</mi></msub><mi>y</mi><mo>⇔</mo><mi mathvariant="normal">∃</mi><mi>q</mi><mo>∈</mo><mi>Q</mi><mtext>，</mtext><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo>∈</mo><mi>s</mi><mi>e</mi><mi>t</mi><mo stretchy="false">(</mo><mi>q</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">x R_M y ⇔ ∃q∈Q，x,y∈set(q)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">x</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">M</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⇔</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord">∃</span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">Q</span><span class="mord cjk_fallback">，</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">se</span><span class="mord mathnormal">t</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="mclose">)</span></span></span></span>。</li><li>或者说：<font color='red'>M从<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>q</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">q_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>开始读入x和y以后进入同一个状态。</font></li></ul></li></ul><h3 id="关系RL：">关系RL：</h3><ul><li>设<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo>⊆</mo><mi mathvariant="normal">Σ</mi><mo>∗</mo></mrow><annotation encoding="application/x-tex">L ⊆ Σ*</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.136em;"></span><span class="mord mathnormal">L</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⊆</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">Σ</span><span class="mord">∗</span></span></span></span>，L确定的Σ*上的关系 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>R</mi><mi>L</mi></msub></mrow><annotation encoding="application/x-tex">R_L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">L</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 定义为：<br>对于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∀</mi><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo>∈</mo><mi mathvariant="normal">Σ</mi><mo>∗</mo></mrow><annotation encoding="application/x-tex">∀x,y∈Σ*</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord">∀</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">Σ</span><span class="mord">∗</span></span></span></span><br><font color='red'><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><msub><mi>R</mi><mi>L</mi></msub><mi>y</mi><mo>⇔</mo><mo stretchy="false">(</mo><mi mathvariant="normal">∀</mi><mi>z</mi><mo>∈</mo><msup><mi mathvariant="normal">Σ</mi><mo>∗</mo></msup><mtext>，</mtext><mi>x</mi><mi>z</mi><mo>∈</mo><mi>L</mi><mo>⇔</mo><mi>y</mi><mi>z</mi><mo>∈</mo><mi>L</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">x R_L y ⇔ (∀z∈Σ^*，xz∈L ⇔ yz∈L)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">x</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">L</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⇔</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">∀</span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0391em;"></span><span class="mord"><span class="mord">Σ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6887em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span><span class="mord cjk_fallback">，</span><span class="mord mathnormal">x</span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">L</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⇔</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7335em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.04398em;">yz</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class="mclose">)</span></span></span></span></font></li></ul><h3 id="二者关系">二者关系</h3><ul><li>如果<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><msub><mi>R</mi><mi>M</mi></msub><mi>y</mi></mrow><annotation encoding="application/x-tex">x R_M y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">x</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">M</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span>，则 <font color='red'>一定有</font> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><msub><mi>R</mi><mrow><mi>L</mi><mo stretchy="false">(</mo><mi>M</mi><mo stretchy="false">)</mo></mrow></msub><mi>y</mi></mrow><annotation encoding="application/x-tex">x R_{L(M)} y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0385em;vertical-align:-0.3552em;"></span><span class="mord mathnormal">x</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.5198em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">L</span><span class="mopen mtight">(</span><span class="mord mathnormal mtight" style="margin-right:0.10903em;">M</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3552em;"><span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span></li><li>如果<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><msub><mi>R</mi><mrow><mi>L</mi><mo stretchy="false">(</mo><mi>M</mi><mo stretchy="false">)</mo></mrow></msub><mi>y</mi></mrow><annotation encoding="application/x-tex">x R_{L(M)} y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0385em;vertical-align:-0.3552em;"></span><span class="mord mathnormal">x</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.5198em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">L</span><span class="mopen mtight">(</span><span class="mord mathnormal mtight" style="margin-right:0.10903em;">M</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3552em;"><span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span>，则 <font color='red'>不一定有</font> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><msub><mi>R</mi><mi>M</mi></msub><mi>y</mi></mrow><annotation encoding="application/x-tex">x R_M y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">x</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">M</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span></li><li><font color='red'><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><msup><mi mathvariant="normal">Σ</mi><mo lspace="0em" rspace="0em">∗</mo></msup><mi mathvariant="normal">/</mi><msub><mi>R</mi><mrow><mi>L</mi><mo stretchy="false">(</mo><mi>M</mi><mo stretchy="false">)</mo></mrow></msub><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">|\Sigma^{*}/R_{L(M)}|</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1052em;vertical-align:-0.3552em;"></span><span class="mord">∣</span><span class="mord"><span class="mord">Σ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6887em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">∗</span></span></span></span></span></span></span></span></span><span class="mord">/</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.5198em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">L</span><span class="mopen mtight">(</span><span class="mord mathnormal mtight" style="margin-right:0.10903em;">M</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3552em;"><span></span></span></span></span></span></span><span class="mord">∣</span></span></span></span> ≤ <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><msup><mi mathvariant="normal">Σ</mi><mo lspace="0em" rspace="0em">∗</mo></msup><mi mathvariant="normal">/</mi><msub><mi>R</mi><mi>M</mi></msub><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">|\Sigma^{*}/R_M|</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord"><span class="mord">Σ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6887em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">∗</span></span></span></span></span></span></span></span></span><span class="mord">/</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">M</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">∣</span></span></span></span> ≤ <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Q</mi></mrow><annotation encoding="application/x-tex">Q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">Q</span></span></span></span></font>, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>R</mi><mi>M</mi></msub></mrow><annotation encoding="application/x-tex">R_M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">M</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>R</mi><mrow><mi>L</mi><mo stretchy="false">(</mo><mi>M</mi><mo stretchy="false">)</mo></mrow></msub></mrow><annotation encoding="application/x-tex">R_{L(M)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0385em;vertical-align:-0.3552em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.5198em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">L</span><span class="mopen mtight">(</span><span class="mord mathnormal mtight" style="margin-right:0.10903em;">M</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3552em;"><span></span></span></span></span></span></span></span></span></span> 的 <font color='red'>加细</font></li></ul><h3 id="例子-4">例子</h3><img src="..\img\FL&FA\RM和RL例子.png" width="70%" height="70%" align="middle"><h2 id="关系的指数">关系的指数</h2><h3 id="R-的指数"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span> 的指数</h3><p>设<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span>是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi mathvariant="normal">Σ</mi><mo lspace="0em" rspace="0em">∗</mo></msup></mrow><annotation encoding="application/x-tex">\Sigma^{*}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6887em;"></span><span class="mord"><span class="mord">Σ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6887em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">∗</span></span></span></span></span></span></span></span></span></span></span></span>上的等价关系,则称 <font color='red'><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><msup><mi mathvariant="normal">Σ</mi><mo lspace="0em" rspace="0em">∗</mo></msup><mi mathvariant="normal">/</mi><mi>R</mi><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">|\Sigma^{*} / R|</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord"><span class="mord">Σ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6887em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">∗</span></span></span></span></span></span></span></span></span><span class="mord">/</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mord">∣</span></span></span></span></font> 是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span> 关于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi mathvariant="normal">Σ</mi><mo lspace="0em" rspace="0em">∗</mo></msup></mrow><annotation encoding="application/x-tex">\Sigma^{*}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6887em;"></span><span class="mord"><span class="mord">Σ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6887em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">∗</span></span></span></span></span></span></span></span></span></span></span></span>的指数。</p><h3 id="R-的一个等价类"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span> 的一个等价类</h3><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi mathvariant="normal">Σ</mi><mo lspace="0em" rspace="0em">∗</mo></msup></mrow><annotation encoding="application/x-tex">\Sigma^{*}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6887em;"></span><span class="mord"><span class="mord">Σ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6887em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">∗</span></span></span></span></span></span></span></span></span></span></span></span>的关于R的一个等价类,也就是<font color='red'><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi mathvariant="normal">Σ</mi><mo lspace="0em" rspace="0em">∗</mo></msup><mi mathvariant="normal">/</mi><mi>R</mi></mrow><annotation encoding="application/x-tex">\Sigma^{*}/R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord">Σ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6887em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">∗</span></span></span></span></span></span></span></span></span><span class="mord">/</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span></font>的任意一个<strong>元素</strong></p><h1>极小化</h1><h2 id="定义-2">定义</h2><p>最小状态DFA的含义:</p><ul><li><p>没有多余状态(死状态)</p><ul><li>如何消除多余状态？删除即可。<br><img src="..\img\FL&FA\极小化_定义.png" width="70%" height="70%" align="middle"></li></ul></li><li><p>没有两个状态是互相等价（不可区别）</p><ul><li>兼容性（一致性）条件——同是终态或同是非终态</li><li>传播性（蔓延性）条件——对于所有输入符号，状态s和状态t必须转换到等价的状态里。</li></ul></li></ul><h2 id="例子：">例子：</h2><p><strong>最小化下图所示的DFA</strong><br><img src="..\img\FL&FA\极小化_例1.png" width="60%" height="70%" align="middle"></p><ol><li>分成终态和非终态：</li></ol><ul><li>将Ｍ的状态分为两个子集一个由终态 k1=｛Ｃ，Ｄ，Ｅ，Ｆ｝组成，一个由非终态 k2=｛Ｓ，Ａ，Ｂ｝组成。</li></ul><ol start="2"><li><p>考察｛Ｓ，Ａ，Ｂ｝是否可分。<br><img src="..\img\FL&FA\极小化_例2.png" width="20%" height="10%" align="middle"><br>因为Ａ经过a到达C属于k1.而S经过a到达A属于k2。B经过a到达A属于k2，所以K2继续划分为{S，B}，{A}。</p></li><li><p>考察｛Ｓ，Ｂ｝是否可再分：<br>B经过b到达D属于k1。S经过b到达B属于k2，所以S，B可以划分。划分为{S},{B}</p></li><li><p>考察｛Ｃ，Ｄ，Ｅ，Ｆ｝是否可再分：<br>因为Ｃ，Ｄ，Ｅ，Ｆ经过 a和b 到达的状态都属于｛Ｃ，Ｄ，Ｅ，Ｆ｝=k1 所以相同，所以不可再分。</p></li><li><p>｛Ｃ，Ｄ，Ｅ，Ｆ｝以｛Ｄ｝来代替则，因为CDEF相同，你也可以用C来代替。无所谓的最小化的DFA如图：<br><img src="..\img\FL&FA\极小化_例3.png" width="50%" height="70%" align="middle" alt="极小化_例3"></p></li></ol><h1>RE运算</h1><h2 id="定义-3">定义</h2><p>正则表达式(regular expression,RE)</p><ol><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Φ</mi></mrow><annotation encoding="application/x-tex">\Phi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">Φ</span></span></span></span> 是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Σ</mi></mrow><annotation encoding="application/x-tex">\Sigma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">Σ</span></span></span></span>上的RE,它表示语言 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Φ</mi></mrow><annotation encoding="application/x-tex">\Phi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">Φ</span></span></span></span>；</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">ϵ</span></span></span></span> 是∑上的RE,它表示语言<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">{</mo><mi>ϵ</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\{\epsilon\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord mathnormal">ϵ</span><span class="mclose">}</span></span></span></span>；</li><li>对于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∀</mi><mi>a</mi><mo>∈</mo><mi mathvariant="normal">Σ</mi></mrow><annotation encoding="application/x-tex">\forall{a}\in \Sigma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7335em;vertical-align:-0.0391em;"></span><span class="mord">∀</span><span class="mord"><span class="mord mathnormal">a</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">Σ</span></span></span></span>, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">{a}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord"><span class="mord mathnormal">a</span></span></span></span></span>是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Σ</mi></mrow><annotation encoding="application/x-tex">\Sigma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">Σ</span></span></span></span>上的RE,它表示语言<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">{</mo><mi>a</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\{a\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord mathnormal">a</span><span class="mclose">}</span></span></span></span>；</li><li>如果r和s分别是∑上表示语言R和S的RE,则：<ul><li>r与s的“和” (r+s)是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Σ</mi></mrow><annotation encoding="application/x-tex">\Sigma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">Σ</span></span></span></span>上的RE,(r+s)表达的语言为R∪S；</li><li>r与s的“乘积” (rs)是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Σ</mi></mrow><annotation encoding="application/x-tex">\Sigma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">Σ</span></span></span></span>上的RE,(rs)表达的语言为RS；</li><li>r的克林闭包(r*)是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Σ</mi></mrow><annotation encoding="application/x-tex">\Sigma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">Σ</span></span></span></span>上的RE,(r*)表达的语言为R*。</li></ul></li><li>只有满足1、2、3、4的才是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Σ</mi></mrow><annotation encoding="application/x-tex">\Sigma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">Σ</span></span></span></span>上的RE。</li></ol><h2 id="表示">表示</h2><ul><li>0,表示语言{0}</li><li>1,表示语言{1}</li><li>(0+1),表示语言{0,1}</li><li>(01),表示语言{01}</li><li>((0+1)*),表示语言{0,1}*</li></ul><h2 id="运算">运算</h2><ul><li>结合律：<br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>r</mi><mi>s</mi><mo stretchy="false">)</mo><mi>t</mi><mo>=</mo><mi>r</mi><mo stretchy="false">(</mo><mi>s</mi><mi>t</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(rs)t=r(st)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">rs</span><span class="mclose">)</span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mopen">(</span><span class="mord mathnormal">s</span><span class="mord mathnormal">t</span><span class="mclose">)</span></span></span></span><br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>r</mi><mo>+</mo><mi>s</mi><mo stretchy="false">)</mo><mo>+</mo><mi>t</mi><mo>=</mo><mi>r</mi><mo>+</mo><mo stretchy="false">(</mo><mi>s</mi><mo>+</mo><mi>t</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(r+s)+t=r+(s+t)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">s</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6151em;"></span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">t</span><span class="mclose">)</span></span></span></span></li><li>分配律：<br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mo stretchy="false">(</mo><mi>s</mi><mo>+</mo><mi>t</mi><mo stretchy="false">)</mo><mo>=</mo><mi>r</mi><mi>s</mi><mo>+</mo><mi>r</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">r(s+t)=rs+rt</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mopen">(</span><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">t</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">rs</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6151em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">t</span></span></span></span><br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>s</mi><mo>+</mo><mi>t</mi><mo stretchy="false">)</mo><mi>r</mi><mo>=</mo><mi>s</mi><mi>r</mi><mo>+</mo><mi>t</mi><mi>r</mi></mrow><annotation encoding="application/x-tex">(s+t)r=sr+tr</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">t</span><span class="mclose">)</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">sr</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6151em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span></span></span></span></li><li>交换律：<br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mo>+</mo><mi>s</mi><mo>=</mo><mi>s</mi><mo>+</mo><mi>r</mi></mrow><annotation encoding="application/x-tex">r+s=s+r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span></span></span></span></li><li>幂等律：<br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mo>+</mo><mi>r</mi><mo>=</mo><mi>r</mi></mrow><annotation encoding="application/x-tex">r+r=r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span></span></span></span></li><li>加法运算零元素：<br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mo>+</mo><mi mathvariant="normal">Φ</mi><mo>=</mo><mi>r</mi></mrow><annotation encoding="application/x-tex">r+Φ=r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">Φ</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span></span></span></span></li><li>乘法运算单位元：<br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mi>ε</mi><mo>=</mo><mi>ε</mi><mi>r</mi><mo>=</mo><mi>r</mi></mrow><annotation encoding="application/x-tex">rε=εr=r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">ε</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">ε</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span></span></span></span></li><li>乘法运算零元素：<br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mi mathvariant="normal">Φ</mi><mo>=</mo><mi mathvariant="normal">Φ</mi><mi>r</mi><mo>=</mo><mi mathvariant="normal">Φ</mi></mrow><annotation encoding="application/x-tex">rΦ=Φr=Φ</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord">Φ</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">Φ</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">Φ</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo stretchy="false">(</mo><mi mathvariant="normal">Φ</mi><mo stretchy="false">)</mo><mo>=</mo><mi mathvariant="normal">Φ</mi></mrow><annotation encoding="application/x-tex">L(Φ)=Φ</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class="mopen">(</span><span class="mord">Φ</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">Φ</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo stretchy="false">(</mo><mi>ε</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">{</mo><mi>ε</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">L(ε)=\{ε\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class="mopen">(</span><span class="mord mathnormal">ε</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord mathnormal">ε</span><span class="mclose">}</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo stretchy="false">(</mo><mi>a</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">{</mo><mi>a</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">L(a)=\{a\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord mathnormal">a</span><span class="mclose">}</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo stretchy="false">(</mo><mi>r</mi><mi>s</mi><mo stretchy="false">)</mo><mo>=</mo><mi>L</mi><mo stretchy="false">(</mo><mi>r</mi><mo stretchy="false">)</mo><mi>L</mi><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">L(rs)=L(r)L(s)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class="mopen">(</span><span class="mord mathnormal">rs</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mclose">)</span><span class="mord mathnormal">L</span><span class="mopen">(</span><span class="mord mathnormal">s</span><span class="mclose">)</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo stretchy="false">(</mo><mi>r</mi><mo>+</mo><mi>s</mi><mo stretchy="false">)</mo><mo>=</mo><mi>L</mi><mo stretchy="false">(</mo><mi>r</mi><mo stretchy="false">)</mo><mo>∪</mo><mi>L</mi><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">L(r+s)=L(r)∪L(s)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">s</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∪</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class="mopen">(</span><span class="mord mathnormal">s</span><span class="mclose">)</span></span></span></span></li><li>$L(r*)=(L®)^* $</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo stretchy="false">(</mo><msup><mi mathvariant="normal">Φ</mi><mo>∗</mo></msup><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">{</mo><mi>ε</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">L(Φ^*)=\{ε\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class="mopen">(</span><span class="mord"><span class="mord">Φ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6887em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord mathnormal">ε</span><span class="mclose">}</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo stretchy="false">(</mo><mo stretchy="false">(</mo><mi>r</mi><mo>+</mo><mi>ε</mi><msup><mo stretchy="false">)</mo><mo>∗</mo></msup><mo stretchy="false">)</mo><mo>=</mo><mi>L</mi><mo stretchy="false">(</mo><msup><mi>r</mi><mo>∗</mo></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">L((r+ε)^*)=L(r^*)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class="mopen">((</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">ε</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6887em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6887em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo stretchy="false">(</mo><mo stretchy="false">(</mo><msup><mi>r</mi><mo>∗</mo></msup><msup><mo stretchy="false">)</mo><mo>∗</mo></msup><mo stretchy="false">)</mo><mo>=</mo><mi>L</mi><mo stretchy="false">(</mo><msup><mi>r</mi><mo>∗</mo></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">L((r^*)^*)=L(r^*)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class="mopen">((</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6887em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6887em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6887em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo stretchy="false">(</mo><mo stretchy="false">(</mo><msup><mi>r</mi><mo>∗</mo></msup><msup><mi>s</mi><mo>∗</mo></msup><msup><mo stretchy="false">)</mo><mo>∗</mo></msup><mo stretchy="false">)</mo><mo>=</mo><mi>L</mi><mo stretchy="false">(</mo><mo stretchy="false">(</mo><mi>r</mi><mo>+</mo><mi>s</mi><msup><mo stretchy="false">)</mo><mo>∗</mo></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">L((r^*s^*)^*)=L((r+s)^*)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class="mopen">((</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6887em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6887em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6887em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class="mopen">((</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">s</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6887em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></li><li>如果<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo stretchy="false">(</mo><mi>r</mi><mo stretchy="false">)</mo><mo>⊆</mo><mi>L</mi><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">L(r) \subseteq L(s)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⊆</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class="mopen">(</span><span class="mord mathnormal">s</span><span class="mclose">)</span></span></span></span>,则<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mo>+</mo><mi>s</mi><mo>=</mo><mi>s</mi></mrow><annotation encoding="application/x-tex">r+s=s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">s</span></span></span></span></li><li>$L(rn)=(L®)^n $</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>r</mi><mi>n</mi></msup><msup><mi>r</mi><mi>m</mi></msup><mo>=</mo><msup><mi>r</mi><mrow><mi>n</mi><mo>+</mo><mi>m</mi></mrow></msup></mrow><annotation encoding="application/x-tex">r^n r^m=r^{n+m}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6644em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7713em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7713em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">+</span><span class="mord mathnormal mtight">m</span></span></span></span></span></span></span></span></span></span></span></span><br>一般地, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mo>+</mo><mi>ε</mi><mo mathvariant="normal">≠</mo><mi>r</mi><mo separator="true">,</mo><mo stretchy="false">(</mo><mi>r</mi><mi>s</mi><msup><mo stretchy="false">)</mo><mi>n</mi></msup><mo mathvariant="normal">≠</mo><msup><mi>r</mi><mi>n</mi></msup><msup><mi>s</mi><mi>n</mi></msup><mo separator="true">,</mo><mi>r</mi><mi>s</mi><mo mathvariant="normal">≠</mo><mi>s</mi><mi>r</mi></mrow><annotation encoding="application/x-tex">r+ε≠r,(rs)^n ≠r^ns^n,rs≠sr</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">ε</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel"><span class="mrel"><span class="mord vbox"><span class="thinbox"><span class="rlap"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="inner"><span class="mord"><span class="mrel"></span></span></span><span class="fix"></span></span></span></span></span><span class="mrel">=</span></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mopen">(</span><span class="mord mathnormal">rs</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel"><span class="mrel"><span class="mord vbox"><span class="thinbox"><span class="rlap"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="inner"><span class="mord"><span class="mrel"></span></span></span><span class="fix"></span></span></span></span></span><span class="mrel">=</span></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">rs</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel"><span class="mrel"><span class="mord vbox"><span class="thinbox"><span class="rlap"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="inner"><span class="mord"><span class="mrel"></span></span></span><span class="fix"></span></span></span></span></span><span class="mrel">=</span></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">sr</span></span></span></span></li><li>幂<br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>r</mi><mn>0</mn></msup><mo>=</mo><mi>ε</mi></mrow><annotation encoding="application/x-tex">r^0=ε</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">ε</span></span></span></span><br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>r</mi><mi>n</mi></msup><mo>=</mo><msup><mi>r</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msup><mi>r</mi></mrow><annotation encoding="application/x-tex">r^n=r^{n-1}r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6644em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span></span></span></span></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;前言&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;形式语言理论：&lt;font color=&quot;red&quot;&gt;乔姆斯基发现文法&lt;/font&gt;，用&lt;strong&gt;文法产生语言&lt;/strong&gt;的每个句子。&lt;/li&gt;
&lt;li&gt;自动机理论：&lt;font color=&quot;red&quot;&gt;克林建立了有穷状态自动机&lt;/</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Unity-物理系统之刚体加力</title>
    <link href="https://escapeey.github.io/post/3912f0e7.html"/>
    <id>https://escapeey.github.io/post/3912f0e7.html</id>
    <published>2023-12-27T21:39:19.000Z</published>
    <updated>2024-04-03T04:37:57.884Z</updated>
    
    <content type="html"><![CDATA[<h2 id="刚体自带添加力的方法">刚体自带添加力的方法</h2><p>给刚体加力的目标是 让其有一个<strong>速度</strong> 朝向<strong>某一个方向移动</strong></p><h3 id="获取刚体组件">获取刚体组件</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Rigidbody rigidBody = <span class="keyword">this</span>.GetComponent&lt;Rigidbody&gt;();</span><br></pre></td></tr></table></figure><h3 id="添加力">添加力</h3><p>相对世界坐标 <font color="green">rigidBody.AddForce()</font></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rigidBody.AddForce(Vector3.forward * <span class="number">10</span>);</span><br></pre></td></tr></table></figure><p>相对本地坐标 <font color="green">rigidBody.AddRelativeForce()</font></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rigidBody.AddRelativeForce(Vector3.forward * <span class="number">10</span>);</span><br></pre></td></tr></table></figure><h3 id="添加扭矩力">添加扭矩力</h3><p>相对世界坐标 <font color="green">rigidBody.AddTorque()</font></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rigidBody.AddTorque(Vector3.up * <span class="number">10</span>);</span><br></pre></td></tr></table></figure><p>相对本地坐标 <font color="green">rigidBody.AddRelativeTorque()</font></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rigidBody.AddRelativeTorque(Vector3.up * <span class="number">10</span>);</span><br></pre></td></tr></table></figure><h3 id="直接改变速度">直接改变速度</h3><p><font color="green">rigidBody.velocity</font></p><p>这个速度方向 是相对于 世界坐标系的</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rigidBody.velocity = Vector3.forward * <span class="number">5</span>;</span><br></pre></td></tr></table></figure><h3 id="模拟爆炸效果">模拟爆炸效果</h3><p><font color="green">rigidBody.AddExplosionForce()</font></p><ul><li>模拟爆炸的力 一定是 <strong>所有希望产生爆炸效果影响的对象都需要得到他们的刚体</strong> 来执行这个方法 才能都有效果</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rigidBody.AddExplosionForce(<span class="number">100</span>, Vector3.zero, <span class="number">10</span>);</span><br></pre></td></tr></table></figure><h2 id="力的几种模式">力的几种模式</h2><ul><li>第二个参数 力的模式 主要的作用 就是 计算方式不同</li><li>由于4中计算方式的不同 最终的移动速度就会不同</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rigidBody.AddForce(Vector3.forward * <span class="number">10</span>, ForceMode.Acceleration);</span><br></pre></td></tr></table></figure><h3 id="Acceleration">Acceleration</h3><ul><li>给物体增加一个持续的加速度，忽略其质量</li><li>v = Ft/m</li><li>F:(0,0,10)</li><li>t:0.02s</li><li>m:默认为1</li><li>v = 10*0.02/ 1 = 0.2m/s</li><li>每物理帧移动0.2m/s*0.02 = 0.004m</li></ul><h3 id="Force">Force</h3><ul><li>给物体添加一个持续的力，与物体的质量有关</li><li>v = Ft/m</li><li>F:(0,0,10)</li><li>t:0.02s</li><li>m:2kg</li><li>v = 10*0.02/ 2 = 0.1m/s</li><li>每物理帧移动0.1m/s*0.02 = 0.002m</li></ul><h3 id="Impulse">Impulse</h3><ul><li>给物体添加一个瞬间的力，与物体的质量有关,忽略时间 默认为1</li><li>v = Ft/m</li><li>F:(0,0,10)</li><li>t:默认为1</li><li>m:2kg</li><li>v = 10*1/ 2 = 5m/s</li><li>每物理帧移动5m/s*0.02 = 0.1m</li></ul><h3 id="VelocityChange">VelocityChange</h3><ul><li>给物体添加一个瞬时速度，忽略质量，忽略时间</li><li>v = Ft/m</li><li>F:(0,0,10)</li><li>t:默认为1</li><li>m:默认为1</li><li>v = 10*1/ 1 = 10m/s</li><li>每物理帧移动10m/s*0.02 = 0.2m</li></ul><h2 id="立场脚本">立场脚本</h2><figure class="highlight plaintext"><figcaption><span>Force```组件</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">添加恒定力</span><br><span class="line"></span><br><span class="line">## 补充 刚体的休眠</span><br><span class="line">Unity为了**节约性能**，会对一些最近没改变的刚体进行休眠，可能会影响后续操作</span><br><span class="line">获取刚体是否处于休眠状态</span><br><span class="line">```C#</span><br><span class="line">if (rigidBody.IsSleeping())</span><br><span class="line">&#123;</span><br><span class="line">    //就唤醒它</span><br><span class="line">    rigidBody.WakeUp();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;刚体自带添加力的方法&quot;&gt;刚体自带添加力的方法&lt;/h2&gt;
&lt;p&gt;给刚体加力的目标是 让其有一个&lt;strong&gt;速度&lt;/strong&gt; 朝向&lt;strong&gt;某一个方向移动&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;获取刚体组件&quot;&gt;获取刚体组件&lt;/h3&gt;
&lt;figure</summary>
      
    
    
    
    <category term="Unity" scheme="https://escapeey.github.io/categories/Unity/"/>
    
    
    <category term="C#" scheme="https://escapeey.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Unity-物理系统之射线检测</title>
    <link href="https://escapeey.github.io/post/4d19935.html"/>
    <id>https://escapeey.github.io/post/4d19935.html</id>
    <published>2023-12-26T16:34:42.000Z</published>
    <updated>2024-04-03T04:37:57.884Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是射线检测">什么是射线检测</h2><p>解决以下问题：</p><ul><li>鼠标选择场景上一物体</li><li>FPS射击游戏（无弹道-不产生实际的子弹对象进行移动）</li><li>等需要判断一条线和物体的碰撞情况<br>它可以在<strong>指定点</strong>发射一个<strong>指定方向</strong>的射线<br>判断该射线与哪些<strong>碰撞器</strong>相交，得到对应对象</li></ul><h2 id="射线对象">射线对象</h2><p>单独的射线对于我们来说没有实际的意义,我们需要用它<strong>结合物理系统</strong>进行<strong>射线碰撞判断</strong></p><h3 id="3D世界中的射线">3D世界中的射线</h3><ul><li>参数一：起点</li><li>参数二：方向</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ray r = <span class="keyword">new</span> Ray(Vector3.right, Vector3.forward);</span><br></pre></td></tr></table></figure><h3 id="摄像机发射出的射线">摄像机发射出的射线</h3><p><strong>屏幕位置</strong> 为起点<br><strong>摄像机视口方向</strong> 为方向</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ray r2 = Camera.main.ScreenPointToRay(Input.mousePosition);</span><br></pre></td></tr></table></figure><h2 id="碰撞检测-API">碰撞检测 API</h2><p>射线检测也是<strong>瞬时</strong>的<br>执行代码时进行<strong>一次射线检测</strong></p><h3 id="最原始的射线检测">最原始的射线检测</h3><p>准备一条射线</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ray r = <span class="keyword">new</span> Ray(Vector3.zero, Vector3.forward);</span><br></pre></td></tr></table></figure><p><font color='green'>Physics.Raycast()</font></p><ul><li>参数一：射线</li><li>参数二: 检测的最大距离 超出这个距离不检测</li><li>参数三：检测指定层级（不填检测所有层）</li><li>参数四：是否忽略触发器 <code>UseGlobal</code>-使用全局设置 <code>Collide</code>-检测触发器<br><code>Ignore</code>-忽略触发器  不填使用<code>UseGlobal</code></li><li>返回值：bool 当碰撞到对象时 返回 true 没有 返回false</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (Physics.Raycast(r, <span class="number">1000</span>, <span class="number">1</span> &lt;&lt; LayerMask.NameToLayer(<span class="string">&quot;Monster&quot;</span>), </span><br><span class="line">    QueryTriggerInteraction.UseGlobal))</span><br><span class="line">&#123;</span><br><span class="line">    print(<span class="string">&quot;碰撞到了对象&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有一种重载 不用传入 射线 直接传入起点 和 方向 也可以用于判断</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (Physics.Raycast(Vector3.zero, Vector3.forward, <span class="number">1000</span>, </span><br><span class="line">    <span class="number">1</span> &lt;&lt; LayerMask.NameToLayer(<span class="string">&quot;Monster&quot;</span>),QueryTriggerInteraction.UseGlobal))</span><br><span class="line">&#123;</span><br><span class="line">    print(<span class="string">&quot;碰撞到了对象&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="获取相交的单个物体信息">获取相交的单个物体信息</h3><p>物体信息类<br>通过<font color='green'>RaycastHit</font>类 我们得到得到 <strong>碰撞到的对象信息</strong><br>还可以得到一些 碰撞的点 距离 法线等等的信息</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RaycastHit hitInfo;</span><br></pre></td></tr></table></figure><ul><li>参数一：射线</li><li>参数二：<code>RaycastHit</code>是结构体 是<strong>值类型</strong> Unity会通过<strong>out</strong><br>在函数内部处理后 得到碰撞数据后返回到该参数中</li><li>参数三：距离</li><li>参数四：检测指定层级</li><li>参数五：是否忽略触发器</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>( Physics.Raycast(r, <span class="keyword">out</span> hitInfo, <span class="number">1000</span>, <span class="number">1</span>&lt;&lt;LayerMask.NameToLayer(<span class="string">&quot;Monster&quot;</span>), </span><br><span class="line">    QueryTriggerInteraction.UseGlobal) )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//碰撞器信息</span></span><br><span class="line">    print(<span class="string">&quot;碰撞到物体的名字&quot;</span> + hitInfo.collider.gameObject.name);</span><br><span class="line">    <span class="comment">//碰撞到的点</span></span><br><span class="line">    print(hitInfo.point);</span><br><span class="line">    <span class="comment">//法线信息</span></span><br><span class="line">    print(hitInfo.normal);</span><br><span class="line">    <span class="comment">//得到碰撞到对象的位置</span></span><br><span class="line">    print(hitInfo.transform.position);</span><br><span class="line">    <span class="comment">//得到碰撞到对象 离自己的距离</span></span><br><span class="line">    print(hitInfo.distance);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同理 还有一种重载 不用传入 射线 直接传入起点 和 方向 也可以用于判断</p><h3 id="获取相交的多个物体">获取相交的多个物体</h3><p><font color='green'>Physics.RaycastAll()</font></p><p>可以得到<strong>碰撞到的多个对象</strong>，如果没有 就是容量为0的数组</p><ul><li>参数一：射线</li><li>参数二：距离</li><li>参数三：检测指定层级</li><li>参数四：是否忽略触发器</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">RaycastHit[] hits = Physics.RaycastAll(r, <span class="number">1000</span>, <span class="number">1</span> &lt;&lt; LayerMask.NameToLayer(<span class="string">&quot;Monster&quot;</span>),</span><br><span class="line">                                       QueryTriggerInteraction.UseGlobal);</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; hits.Length; i++)</span><br><span class="line">&#123;</span><br><span class="line">    print(<span class="string">&quot;碰到的所有物体 名字分别是&quot;</span> + hits[i].collider.gameObject.name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有一种NonAlloc型的函数 返回的碰撞的数量 通过out得到数据<br><font color='green'>Physics.RaycastNonAlloc()</font></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RaycastHit[] hits;</span><br><span class="line"><span class="keyword">if</span>(Physics.RaycastNonAlloc(r, hits, <span class="number">1000</span>, <span class="number">1</span> &lt;&lt; LayerMask.NameToLayer(<span class="string">&quot;Monster&quot;</span>), </span><br><span class="line">                           QueryTriggerInteraction.UseGlobal) &gt; <span class="number">0</span> )&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用时注意的问题">使用时注意的问题</h3><p><strong>注意</strong>：<br><strong>距离</strong>、<strong>层级</strong>两个参数 都是<strong>int类型</strong><br>当我们传入参数时 一定要明确传入的参数代表的是距离还是层级</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;什么是射线检测&quot;&gt;什么是射线检测&lt;/h2&gt;
&lt;p&gt;解决以下问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;鼠标选择场景上一物体&lt;/li&gt;
&lt;li&gt;FPS射击游戏（无弹道-不产生实际的子弹对象进行移动）&lt;/li&gt;
&lt;li&gt;等需要判断一条线和物体的碰撞情况&lt;br&gt;
它可以在&lt;str</summary>
      
    
    
    
    <category term="Unity" scheme="https://escapeey.github.io/categories/Unity/"/>
    
    
    <category term="C#" scheme="https://escapeey.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Unity-物理系统之范围检测</title>
    <link href="https://escapeey.github.io/post/43ff44cd.html"/>
    <id>https://escapeey.github.io/post/43ff44cd.html</id>
    <published>2023-12-26T10:41:26.000Z</published>
    <updated>2024-04-03T04:37:57.884Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是范围检测">什么是范围检测</h2><p>游戏中<strong>瞬时</strong>的攻击范围判断一般会使用范围检测<br>举例：</p><ul><li>玩家在前方5m处释放一个地刺魔法，在此处范围内的对象将受到地刺伤害</li><li>玩家攻击，在前方1米圆形范围内对象都受到害</li></ul><p>类似这种并<strong>没有实体物体</strong> 只想要检测在指定<strong>某一范围</strong>是否让敌方受到伤害时 便可以使用范围判断</p><h2 id="范围检测">范围检测</h2><p><strong>必备条件</strong>：想要<strong>被</strong>范围检测到的对象必须<strong>具备碰撞器</strong><br>注意点：</p><ul><li>范围检测相关API <strong>只有当执行该句代码时</strong> 进行一次范围检测 它是<font color='red'>瞬时</font>的</li><li>范围检测相关API 并<font color='red'>不会真正产生一个碰撞器</font> 只是<strong>碰撞判断计算</strong>而已</li></ul><h3 id="盒状范围检测API">盒状范围检测API</h3><p><font color='green'>Physics.OverlapBox()</font></p><ul><li>参数一：立方体中心点</li><li>参数二：立方体三边大小</li><li>参数三：立方体角度</li><li>参数四：检测指定层级（不填检测所有层）</li><li>参数五：是否忽略触发器 <code>UseGlobal</code>-使用全局设置 <code>Collide</code>-检测触发器 <code>Ignore</code>-忽略触发器 不填使用<code>UseGlobal</code></li><li>返回值：在该范围内的碰撞器（得到了对象碰撞器就可以得到对象的所有信息）</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Collider[] colliders = Physics.OverlapBox(Vector3.zero, Vector3.one, </span><br><span class="line">                    Quaternion.AngleAxis(<span class="number">45</span>, Vector.Up), </span><br><span class="line">                    <span class="number">1</span> &lt;&lt; LayerMask.NameToLayer(<span class="string">&quot;UI&quot;</span>) | </span><br><span class="line">                    <span class="number">1</span> &lt;&lt; LayerMask.NameToLayer(<span class="string">&quot;Default&quot;</span>), </span><br><span class="line">                    QueryTriggerInteraction.UseGlobal);</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; colliders.Length; i++)</span><br><span class="line">&#123;</span><br><span class="line">    print(colliders[i].gameObject.name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另一个API <font color='green'>Physics.OverlapBoxNonAlloc()</font></p><ul><li>返回值：碰撞到的碰撞器<strong>数量</strong></li><li>参数：<strong>传入一个数组</strong>进行存储</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(Physics.OverlapBoxNonAlloc(Vector3.zero, Vector3.one, colliders) != <span class="number">0</span>)&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="球形范围检测API">球形范围检测API</h3><p><font color='green'>Physics.OverlapSphere()</font></p><ul><li>参数一：中心点</li><li>参数二：球半径</li><li>参数三：检测指定层级（不填检测所有层）</li><li>参数四：是否忽略触发器</li><li>返回值：在该范围内的触发器</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">colliders = Physics.OverlapSphere(Vector3.zero, <span class="number">5</span>, </span><br><span class="line">            <span class="number">1</span> &lt;&lt; LayerMask.NameToLayer(<span class="string">&quot;Default&quot;</span>));</span><br></pre></td></tr></table></figure><p>另一个API <font color='green'>Physics.OverlapSphereNonAlloc()</font></p><ul><li>返回值：碰撞到的碰撞器<strong>数量</strong></li><li>参数：传入一个<strong>数组</strong>进行存储</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>( Physics.OverlapSphereNonAlloc(Vector3.zero, <span class="number">5</span>, colliders) != <span class="number">0</span> )&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="胶囊范围检测API">胶囊范围检测API</h3><p><font color='green'>Physics.OverlapCapsule()</font></p><ul><li>参数一：半圆一中心点</li><li>参数二：半圆二中心点</li><li>参数三：半圆半径</li><li>参数四：检测指定层级（不填检测所有层）</li><li>参数五：是否忽略触发器</li><li>返回值：在该范围内的触发器</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">colliders = Physics.OverlapCapsule(Vector3.zero, Vector3.up, <span class="number">1</span>, </span><br><span class="line">            <span class="number">1</span> &lt;&lt; LayerMask.NameToLayer(<span class="string">&quot;UI&quot;</span>), </span><br><span class="line">            QueryTriggerInteraction.UseGlobal);</span><br></pre></td></tr></table></figure><p>另一个API <font color='green'>Physics.OverlapCapsuleNonAlloc()</font></p><ul><li>返回值：碰撞到的碰撞器数量</li><li>参数：传入一个数组进行存储</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( Physics.OverlapCapsuleNonAlloc(Vector3.zero, Vector3.up, <span class="number">1</span>, colliders ) != <span class="number">0</span> )&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结">总结</h2><ul><li>范围检测主要用于<strong>瞬时</strong>的<strong>碰撞范围</strong>检测</li><li>主要掌握 <strong>Physics类中的静态方法：球形 盒装 胶囊三种API的使用</strong>即可</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;什么是范围检测&quot;&gt;什么是范围检测&lt;/h2&gt;
&lt;p&gt;游戏中&lt;strong&gt;瞬时&lt;/strong&gt;的攻击范围判断一般会使用范围检测&lt;br&gt;
举例：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;玩家在前方5m处释放一个地刺魔法，在此处范围内的对象将受到地刺伤害&lt;/li&gt;
&lt;li&gt;玩家攻击</summary>
      
    
    
    
    <category term="Unity" scheme="https://escapeey.github.io/categories/Unity/"/>
    
    
    <category term="C#" scheme="https://escapeey.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Unity-LineRenderer组件</title>
    <link href="https://escapeey.github.io/post/af0e4a0a.html"/>
    <id>https://escapeey.github.io/post/af0e4a0a.html</id>
    <published>2023-12-25T21:48:47.000Z</published>
    <updated>2024-04-03T04:37:57.884Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LineRenderer是什么">LineRenderer是什么</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">使用它我们可以在场景中绘制线段,一般可以用于</span><br><span class="line">- 绘制攻击范围</span><br><span class="line">- 武器红外线</span><br><span class="line">- 辅助功能</span><br><span class="line">- 其它画线功能</span><br><span class="line"></span><br><span class="line">## LineRender参数相关</span><br><span class="line">- ```Corner Vertices```(角顶点，圆角)</span><br><span class="line">此属性指示在一条线中绘制角时使用了多少个额外的顶点</span><br><span class="line">增加此值，使**线角看起来更圆**</span><br><span class="line">- ```End Cap Vertices```(终端顶点，圆角)</span><br><span class="line">终点圆角</span><br><span class="line">- 其余重点参数在代码部分介绍</span><br><span class="line">## LineRender代码相关</span><br><span class="line">- 动态添加一个线段</span><br><span class="line">```C#</span><br><span class="line">GameObject line = new GameObject();</span><br><span class="line">LineRenderer lineR = line.AddComponent&lt;LineRenderer&gt;;</span><br></pre></td></tr></table></figure><ul><li>首尾相连</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lineR.loop = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><ul><li>开始结束宽</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lineR.startWidth = <span class="number">0.02f</span>;</span><br><span class="line">lineR.endWidth = <span class="number">0.02f</span>;</span><br></pre></td></tr></table></figure><ul><li>开始结束颜色</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lineR.startColor = Color.white;</span><br><span class="line">lineR.endColor = Color.red;</span><br></pre></td></tr></table></figure><ul><li>设置材质</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">m = Resources.Load&lt;Material&gt;(<span class="string">&quot;M&quot;</span>);</span><br><span class="line">lineR.material = m;</span><br></pre></td></tr></table></figure><ul><li>设置点<br>一定注意设置点要<strong>先设置点的个数</strong><br>接着就设置 对应每个点的位置<br>当设置的位置数少于先前设置点的个数时，剩余的点坐标都默认为原点</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">lineR.positionCount = <span class="number">4</span>;</span><br><span class="line">lineR.SetPositions(<span class="keyword">new</span> Vector3[] &#123; <span class="keyword">new</span> Vector3(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>),</span><br><span class="line">                                   <span class="keyword">new</span> Vector3(<span class="number">0</span>,<span class="number">0</span>,<span class="number">5</span>),</span><br><span class="line">                                   <span class="keyword">new</span> Vector3(<span class="number">5</span>,<span class="number">0</span>,<span class="number">5</span>)&#125;);</span><br><span class="line">lineR.SetPosition(<span class="number">3</span>, <span class="keyword">new</span> Vector3(<span class="number">5</span>, <span class="number">0</span>, <span class="number">0</span>));</span><br></pre></td></tr></table></figure><ul><li>是否使用世界坐标系<br>决定了 是否随对象移动而移动</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lineR.useWorldSpace = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><ul><li>让线段受光影响 会接受光数据 进行着色器计算</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lineR.generateLightingData = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><h2 id="例子">例子</h2><h3 id="练习一">练习一</h3><p><strong>请写一个方法，传入一个中心点，传入一个半径，用LineRender画一个圆出来</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DrawLineRenderer</span>(<span class="params">Vector3 centerPos, <span class="built_in">float</span> r, <span class="built_in">int</span> pointNum</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//动态创建 画线对象</span></span><br><span class="line">    GameObject obj = <span class="keyword">new</span> GameObject();</span><br><span class="line">    obj.name = <span class="string">&quot;R&quot;</span>;</span><br><span class="line">    LineRenderer line = obj.AddComponent&lt;LineRenderer&gt;();</span><br><span class="line">    <span class="comment">//设置有多少个点</span></span><br><span class="line">    line.positionCount = pointNum;</span><br><span class="line">    <span class="comment">//让其首尾相连</span></span><br><span class="line">    line.loop = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">//得到每个点之间 间隔的度数</span></span><br><span class="line">    <span class="built_in">float</span> angle = <span class="number">360f</span> / pointNum;</span><br><span class="line">    <span class="comment">//准备得到每一个点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; pointNum; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//知识点</span></span><br><span class="line">        <span class="comment">//1.点加向量 相当于平移点</span></span><br><span class="line">        <span class="comment">//2.四元数 * 向量 相当于在 旋转向量</span></span><br><span class="line">        line.SetPosition(i, centerPos + Quaternion.AngleAxis(angle * i, Vector3.up) * Vector3.forward * r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="练习二">练习二</h3><p><strong>在Game窗口长按鼠标用LineRenderer画出鼠标移动的轨迹</strong></p><ul><li>重点是 如何得到鼠标转世界坐标的 对应点</li><li>知识点<ul><li>得到鼠标位置 <code>Input.mousePosition</code></li><li>把鼠标 转世界坐标 <code>Camera.main.ScreenToWorldPoint(Input.mousePosition);</code></li></ul></li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> LineRenderer line2;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    line2 = <span class="keyword">this</span>.gameObject.AddComponent&lt;LineRenderer&gt;();</span><br><span class="line">    line2.loop = <span class="literal">false</span>;</span><br><span class="line">    line2.startWidth = <span class="number">0.5f</span>;</span><br><span class="line">    line2.endWidth = <span class="number">0.5f</span>;</span><br><span class="line">    line2.positionCount = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> Vector3 nowPos;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>( Input.GetMouseButton(<span class="number">0</span>) )</span><br><span class="line">    &#123;</span><br><span class="line">        line2.positionCount += <span class="number">1</span>;</span><br><span class="line">        nowPos = Input.mousePosition;</span><br><span class="line">        <span class="comment">//设置z轴为横截面深度</span></span><br><span class="line">        nowPos.z = <span class="number">10</span>;</span><br><span class="line">        line2.SetPosition(line2.positionCount - <span class="number">1</span>, Camera.main.ScreenToWorldPoint(nowPos));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;LineRenderer是什么&quot;&gt;LineRenderer是什么&lt;/h2&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/s</summary>
      
    
    
    
    <category term="Unity" scheme="https://escapeey.github.io/categories/Unity/"/>
    
    
    <category term="C#" scheme="https://escapeey.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Unity-场景异步切换</title>
    <link href="https://escapeey.github.io/post/33841c46.html"/>
    <id>https://escapeey.github.io/post/33841c46.html</id>
    <published>2023-12-25T15:58:08.000Z</published>
    <updated>2024-04-03T04:37:57.884Z</updated>
    
    <content type="html"><![CDATA[<h2 id="场景同步切换">场景同步切换</h2><p><font color='green'>SceneManger.LoadScene()</font></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SceneManger.LoadScene(<span class="string">&quot;TestScene&quot;</span>);</span><br></pre></td></tr></table></figure><p>场景同步切换的<strong>缺点</strong>：</p><ul><li>因为先删除当前场景中所有对象，且去加载新场景的相关信息，会很耗时，造成卡顿</li></ul><h2 id="场景异步切换">场景异步切换</h2><p><font color='green'>SceneManger.LoadSceneAsync()</font></p><p>和<strong>资源异步加载</strong>几乎一致，有两种方法</p><h3 id="通过事件回调函数-异步加载">通过事件回调函数 异步加载</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">AsyncOperation ao = SceneManger.LoadSceneAsync(<span class="string">&quot;TestScene&quot;</span>);</span><br><span class="line">ao.completed += (a) =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    print(<span class="string">&quot;加载结束&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="通过协程-异步加载">通过协程 异步加载</h3><ul><li>需要注意的是 加载场景会把当前场景上<strong>没有特别处理</strong>的对象<strong>都删除了</strong>，所以<strong>协程中的部分逻辑执行不了</strong></li><li>解决思路：<br>让处理场景加载的<strong>脚本依附的对象</strong> 过场景时<strong>不被移除</strong></li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">DontDestroyOnLoad(<span class="keyword">this</span>.gameObject);</span><br><span class="line">StartCoroutine(LoadScene(<span class="string">&quot;TestScene&quot;</span>));</span><br><span class="line"><span class="function">IEnumerator <span class="title">LoadScene</span>(<span class="params"><span class="built_in">string</span> name</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//第一步</span></span><br><span class="line">    <span class="comment">//异步加载场景</span></span><br><span class="line">    AsyncOperation ao = SceneManager.LoadSceneAsync(name);</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">return</span> ao;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用协程的好处">使用协程的好处</h4><ul><li>可以在异步<strong>加载场景的同时</strong>做一些别的逻辑，比如<strong>更新进度条</strong></li></ul><h5 id="方法一">方法一</h5><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//利用 场景异步加载的进度去更新 不是特别准确</span></span><br><span class="line"><span class="function">IEnumerator <span class="title">LoadScene</span>(<span class="params"><span class="built_in">string</span> name</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//第一步</span></span><br><span class="line">    <span class="comment">//异步加载场景</span></span><br><span class="line">    AsyncOperation ao = SceneManager.LoadSceneAsync(name);</span><br><span class="line">    <span class="keyword">while</span>(!ao.isDone)</span><br><span class="line">    &#123;</span><br><span class="line">        print(ao.progress);</span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//离开循环后 就会认为场景加载结束</span></span><br><span class="line"><span class="comment">//可以把进度条顶满 然后 隐藏进度条</span></span><br></pre></td></tr></table></figure><h5 id="方法二">方法二</h5><p>根据游戏规则<strong>自定义</strong>进度条变化的条件,例如：</p><ul><li>场景加载结束 更新20%进度</li><li>动态加载怪物 再更新20%进度</li><li>动态加载场景模型 认为加载结束 进度条顶满</li><li>隐藏进度条</li></ul><h2 id="总结">总结</h2><h3 id="事件回调函数">事件回调函数</h3><ul><li>优点：写法简单，逻辑清晰</li><li>缺点：只能<strong>加载完场景</strong>做一些事情 不能再加载过程中处理逻辑</li></ul><h3 id="协程异步加载">协程异步加载</h3><ul><li>优点：可以在<strong>加载过程中</strong>处理逻辑，比如进度条更新等</li><li>缺点：写法较为麻烦，要通过协程</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;场景同步切换&quot;&gt;场景同步切换&lt;/h2&gt;
&lt;p&gt;&lt;font color=&#39;green&#39;&gt;SceneManger.LoadScene()&lt;/font&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight c#&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gut</summary>
      
    
    
    
    <category term="Unity" scheme="https://escapeey.github.io/categories/Unity/"/>
    
    
    <category term="C#" scheme="https://escapeey.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Unity-物理系统之碰撞检测</title>
    <link href="https://escapeey.github.io/post/2b4a076a.html"/>
    <id>https://escapeey.github.io/post/2b4a076a.html</id>
    <published>2023-12-10T16:35:16.000Z</published>
    <updated>2024-04-03T04:37:57.884Z</updated>
    
    <content type="html"><![CDATA[<p><strong>碰撞</strong>和<strong>触发</strong>响应函数 属于 特殊的<font color="red">生命周期函数</font> 也是<strong>通过反射调用</strong></p><h2 id="知识点回顾">知识点回顾</h2><ul><li>如何让两个游戏物体之间<strong>产生碰撞</strong> – <font color="blue">至少1个刚体 和 两个碰撞器</font></li><li>如何让两个物体之间<strong>碰撞时表现出不同效果</strong> – <font color="blue">物理材质</font></li><li><strong>触发器</strong>的作用是什么 – <font color="blue">让两个物体碰撞没有物理效果，只进行碰撞处理</font></li></ul><h2 id="物理碰撞检测响应函数">物理碰撞检测响应函数</h2><figure class="highlight plaintext"><figcaption><span>参数 包含了 **碰到自己的对象**的相关信息</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- 碰撞对象 的碰撞器 ```collision.collider```</span><br><span class="line">- 碰撞对象 的依附对象 ```collision.gameObject```</span><br><span class="line">- 碰撞对象 的依附对象的位置 ```collision.transform```</span><br><span class="line">- 触碰点 个数 ```collision.contactCount```</span><br><span class="line">- 接触点 具体坐标 ```ContactPoint[] pos = collision.contacts;```</span><br><span class="line">- 只要得到了 碰撞到的对象的 任意一个信息 就可以得到它的所有信息</span><br><span class="line"></span><br><span class="line">### 碰撞 接触时 自动执行</span><br><span class="line">&lt;font color=&quot;green&quot;&gt;OncollisionEnter(Collision collision)&lt;/font&gt;</span><br><span class="line"></span><br><span class="line">```C#</span><br><span class="line">private void OncollisionEnter(Collision collision)</span><br><span class="line">&#123;</span><br><span class="line">    print(this.name + &quot;被&quot; + collision.gameObject.name + &quot;撞到了&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="碰撞-结束分离时-自动执行">碰撞 结束分离时 自动执行</h3><p><font color="green">OnCollisionExit(Collision collision)</font></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnCollisionExit</span>(<span class="params">Collision collision</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    print(<span class="keyword">this</span>.name + <span class="string">&quot;被&quot;</span> + collision.gameObject.name + <span class="string">&quot;结束碰撞了&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="碰撞-相互接触时-自动不停执行">碰撞 相互接触时 自动不停执行</h3><p><font color="green">OnCollisionStay(Collision collision)</font></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnCollisionStay</span>(<span class="params">Collision collision</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    print(<span class="keyword">this</span>.name + <span class="string">&quot;一直在和&quot;</span> + collision.gameObject.name + <span class="string">&quot;接触&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="触发器检测响应函数">触发器检测响应函数</h2><h3 id="触发-开始时-自动调用">触发 开始时 自动调用</h3><p><font color="green">OnTriggerEnter(Collider other)</font></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnTriggerEnter</span>(<span class="params">Collider other</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    print(<span class="keyword">this</span>.name + <span class="string">&quot;被&quot;</span> + other.gameObject.name + <span class="string">&quot;触发了&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="触发-结束时-自动调用">触发 结束时 自动调用</h3><p><font color="green">OnTriggerExit(Collider other)</font></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnTriggerExit</span>(<span class="params">Collider other</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    print(<span class="keyword">this</span>.name + <span class="string">&quot;被&quot;</span> + other.gameObject.name + <span class="string">&quot;结束相融的状态了&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="触发-相融时-自动不停调用">触发 相融时 自动不停调用</h3><p><font color="green">OnTriggerStay(Collider other)</font></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnTriggerStay</span>(<span class="params">Collider other</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    print(<span class="keyword">this</span>.name + <span class="string">&quot;和&quot;</span> + other.gameObject.name + <span class="string">&quot;正在相融&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="要明确什么时候会响应函数">要明确什么时候会响应函数</h2><ul><li><font color="red">！！！</font>碰撞和触发都是<strong>相互的</strong>，不是说只有isTrigger为True的对象才能触发，和这个触发的对象也会被触发</li><li>只要挂载的对象 能和别的物体产生碰撞或者触发 那么对应的这6个函数 就能够被响应</li><li>6个函数根据需求来进行选择书写</li><li>如果是一个异形物体，刚体在父对象上，如果你想通过子对象上挂脚本检测碰撞是不行的 必须<strong>挂载到这个刚体父对象上</strong>才行</li><li>要明确 物理碰撞和触发器响应的区别</li></ul><h2 id="6个函数都可以写成虚函数">6个函数都可以写成虚函数</h2><p>一般会把想要重写的 碰撞和触发函数 写成<strong>保护类型</strong>的 没有必要写成public 因为不会自己手动调用 都是Unity通过反射帮助我们自动调用的</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;碰撞&lt;/strong&gt;和&lt;strong&gt;触发&lt;/strong&gt;响应函数 属于 特殊的&lt;font color=&quot;red&quot;&gt;生命周期函数&lt;/font&gt; 也是&lt;strong&gt;通过反射调用&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;知识点回顾&quot;&gt;知识点回顾&lt;/h2&gt;</summary>
      
    
    
    
    <category term="Unity" scheme="https://escapeey.github.io/categories/Unity/"/>
    
    
    <category term="C#" scheme="https://escapeey.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>数据库系统5-数据库设计</title>
    <link href="https://escapeey.github.io/post/4c0f8279.html"/>
    <id>https://escapeey.github.io/post/4c0f8279.html</id>
    <published>2023-11-25T10:42:14.000Z</published>
    <updated>2024-04-03T04:37:57.880Z</updated>
    
    <content type="html"><![CDATA[<h1>1 数据库设计概论</h1><ul><li>数据库设计是指设计<strong>数据库应用程序</strong></li></ul><h1>2 数据库设计的基本步骤</h1><h2 id="2-1-需求分析">2.1 需求分析</h2><ul><li><strong>收集</strong>用户业务活动及活动数据，由系统分析人员按照分析方法加以<strong>总结提炼</strong>，<strong>描述</strong>用户使用中<strong>的业务信息</strong></li></ul><h2 id="2-2-概念结构设计">2.2 概念结构设计</h2><ul><li>将需求分析结果<strong>抽象为概念模型</strong>的过程，具体内容为<strong>建立概念模型(E-R图)</strong></li></ul><h2 id="2-3-逻辑结构设计">2.3 逻辑结构设计</h2><ul><li><strong>选择</strong>使用的数据模型类型</li><li>将E-R图<strong>转换</strong>为数据模型</li><li>对数据模型进行<strong>优化</strong></li><li>设计子模式</li></ul><h2 id="2-4-数据库物理设计">2.4 数据库物理设计</h2><ul><li><strong>确定</strong>数据库的<strong>物理结构</strong></li><li>对物理结构进行<strong>评价</strong>，评价的重点是<strong>空间和时间效率</strong></li><li>若评价结果满足设计要求则进入物理实施阶段</li><li>关系数据库物理设计的内容:<ul><li>为关系模式选择<strong>存取方法</strong>(建立存取路径)</li><li>设计<strong>关系</strong>、<strong>索引</strong>等数据库文件的<strong>物理存储结构</strong></li></ul></li></ul><h2 id="2-5-数据库实施">2.5 数据库实施</h2><ul><li>用DDL<strong>定义</strong>数据库结构</li><li><strong>组织</strong>数据入库</li><li><strong>编制与调试</strong>应用程序</li><li>数据库<strong>试运行</strong></li></ul><h2 id="2-6-数据库运行和维护">2.6 数据库运行和维护</h2><p>维护工作主要由DBA完成</p><ul><li>数据库的<strong>转储和恢复</strong></li><li>数据库的<strong>安全性、完整性控制</strong></li><li>数据库<strong>性能</strong>的<strong>监督、分析和改进</strong></li><li>数据库的<strong>重组织</strong>和<strong>重构造</strong></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;1 数据库设计概论&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;数据库设计是指设计&lt;strong&gt;数据库应用程序&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;2 数据库设计的基本步骤&lt;/h1&gt;
&lt;h2 id=&quot;2-1-需求分析&quot;&gt;2.1 需求分析&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;str</summary>
      
    
    
    
    <category term="数据库系统" scheme="https://escapeey.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="知识点" scheme="https://escapeey.github.io/tags/%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    
  </entry>
  
  <entry>
    <title>数据库系统6-数据库恢复技术</title>
    <link href="https://escapeey.github.io/post/487a1363.html"/>
    <id>https://escapeey.github.io/post/487a1363.html</id>
    <published>2023-11-24T14:31:13.000Z</published>
    <updated>2024-04-03T04:37:57.880Z</updated>
    
    <content type="html"><![CDATA[<h1>1 事务的基本概念</h1><h2 id="1-1-事务概念">1.1 事务概念</h2><ul><li><strong>事务</strong>：是用户定义的一个数据库操作序列，这些操作要么全做，要么全不做，是一个不可分割的<strong>工作单位</strong></li><li>一个事务可以是一条SQL语句、一组SQL语句或整个程序</li><li>一个应用程序通常包含多个事务</li><li>事务是<strong>恢复和并发控制的基本单位</strong></li></ul><h2 id="1-2-如何定义事务">1.2 如何定义事务</h2><ul><li><strong>COMMIT</strong>语句表示：事务<strong>正常结束</strong>，<strong>提交事务的所有操作</strong>(读+更新)，事务中所有对数据库的更新永久生效</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BEGIN TRANSACTION</span><br><span class="line">    SQL语句1</span><br><span class="line">    SQL语句2</span><br><span class="line">    …………</span><br><span class="line">COMMIT</span><br></pre></td></tr></table></figure><ul><li><strong>ROLLBACK</strong>语句表示：事务<strong>异常终止</strong>，<strong>回滚事务的所有更新操作</strong>，使事务<strong>回滚到开始时</strong>的状态</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BEGIN TRANSACTION</span><br><span class="line">    SQL语句1</span><br><span class="line">    SQL语句2</span><br><span class="line">    …………</span><br><span class="line">ROLLBACK</span><br></pre></td></tr></table></figure><h2 id="1-3-事务的特性-ACID">1.3 事务的特性 ACID</h2><ul><li><strong>原子性</strong>(Atomicity)<ul><li>事务中包含的诸操作要么都做，要么都不做</li></ul></li><li><strong>一致性</strong>(Consistency)<ul><li>事务执行使数据库从一个一致性状态变到另一个一致性状态</li></ul></li><li><strong>隔离性</strong>(Isolation)<ul><li>一个事务的执行不能被其他事务干扰，而影响它对数据的正常使用和修改</li></ul></li><li><strong>持续性</strong>(Durability)<ul><li>一个事务一旦提交，它对数据库中数据的改变就应该是永久性的，接下来的其他操作或故障不应该对其执行结果由任何影响</li></ul></li></ul><h1>2 故障的种类</h1><h2 id="2-1-事务故障">2.1 事务故障</h2><h3 id="定义">定义</h3><ul><li>某个事务由于某种原因未运行至终止点就夭折了</li></ul><h3 id="恢复">恢复</h3><ul><li>对于<strong>可预见</strong>的错误，由<strong>事务程序来处理</strong>(如越界判断等)</li><li>对于<strong>不可预见</strong>的错误，由DBMS<strong>强行回滚</strong>该事务</li></ul><h2 id="2-2-系统故障">2.2 系统故障</h2><h3 id="定义-2">定义</h3><ul><li>整个系统的正常运行突然被破坏</li><li>所有正在运行的事务都非正常终止</li></ul><h3 id="恢复-2">恢复</h3><ul><li>清除尚未完成的事务对数据库的所有修改</li><li>将缓冲区中已完成的事务提交的结果写入数据库</li></ul><h2 id="2-3-介质故障">2.3 介质故障</h2><h3 id="定义-3">定义</h3><ul><li>存储数据库的设备(如硬盘)发生故障导致存储在其上的数据部分丢失或全部丢失</li></ul><h3 id="恢复-3">恢复</h3><ul><li>装入数据库发生介质故障前某个时刻的数据副本</li><li>重做自此时开始的所有成功事务，将这些事务已提交的结果重新记入数据库</li></ul><h1>3 恢复的实现技术</h1><h2 id="3-1-数据恢复的基本原理">3.1 数据恢复的基本原理</h2><ul><li>数据恢复的基本原理是<strong>冗余</strong>，即利用存储在系统其他地方的<strong>冗余数据</strong>来<strong>重建</strong>数据库中已被破坏或不正确的那部分数据<br>关键技术：</li></ul><ol><li>如何建立冗余数据<ul><li>数据转储(backup)</li><li>登录日志文件(logging)</li></ul></li><li>如何利用这些冗余数据实施数据库恢复</li></ol><h2 id="3-2-数据转储">3.2 数据转储</h2><h3 id="定义-4">定义</h3><ul><li>转储是指DBA将整个数据库复制到磁带或另一个磁盘上保存起来的过程</li><li>这些备用的数据文件称为后备副本或后援副本</li></ul><h3 id="分类">分类</h3><ol><li>静态转储<ul><li>转储必须等用户事务结束</li><li>新的事务必须等转储结束</li></ul></li><li>动态转储<ul><li>转储操作与用户事务并发进行</li><li>转储期间允许对数据库进行存储或修改</li></ul></li><li>海量转储<ul><li>每次转储全部数据库</li></ul></li><li>增量转储<ul><li>只转储上次转储后更新过的数据</li></ul></li></ol><h3 id="转储策略">转储策略</h3><ul><li>应定期进行海量转储</li><li>DBA应该更具使用情况确定适当的转储周期和转储方式</li></ul><h2 id="3-3-登录日志文件">3.3 登录日志文件</h2><h3 id="定义-5">定义</h3><ul><li>日志文件(log)是用来记录事务对数据库的更新操作的文件</li></ul><h3 id="格式和内容">格式和内容</h3><h4 id="以记录为单位的日志文件">以记录为单位的日志文件</h4><ul><li>格式<ul><li>各个事务开始标记 BEGIN TRANSACTION</li><li>各个事务结束标记 COMMIT 或 ROLLBACK</li></ul></li><li>内容<ul><li>各个事物的所有更新操作</li><li>各个事物的内部更新操作</li></ul></li></ul><h4 id="以数据块为单位的日志文件">以数据块为单位的日志文件</h4><ul><li>事务标识</li><li>操作类型(插入、删除或修改)</li><li>操作对象(记录ID、Block NO.)</li><li>更新前数据的旧值</li><li>更新后数据的新值</li></ul><h3 id="日志文件的用途">日志文件的用途</h3><ul><li>进行故障恢复</li></ul><h1>恢复策略</h1><h1>具有检查点的恢复技术</h1><h1>数据库镜像</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;1 事务的基本概念&lt;/h1&gt;
&lt;h2 id=&quot;1-1-事务概念&quot;&gt;1.1 事务概念&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;事务&lt;/strong&gt;：是用户定义的一个数据库操作序列，这些操作要么全做，要么全不做，是一个不可分割的&lt;strong&gt;工作单位&lt;/strong&gt;</summary>
      
    
    
    
    <category term="数据库系统" scheme="https://escapeey.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="知识点" scheme="https://escapeey.github.io/tags/%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    
  </entry>
  
</feed>
